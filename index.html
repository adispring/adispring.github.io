<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 3.9.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.ico">
  <link rel="icon" type="image/png" sizes="32x32" href="/favicon.ico">
  <link rel="icon" type="image/png" sizes="16x16" href="/favicon.ico">
  <link rel="mask-icon" href="/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"adispring.github.io","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="FE@Meituan.com">
<meta property="og:type" content="website">
<meta property="og:title" content="wangzengdi&#39;s Blog">
<meta property="og:url" content="https://adispring.github.io/index.html">
<meta property="og:site_name" content="wangzengdi&#39;s Blog">
<meta property="og:description" content="FE@Meituan.com">
<meta property="og:locale" content="en">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="wangzengdi&#39;s Blog">
<meta name="twitter:description" content="FE@Meituan.com">

<link rel="canonical" href="https://adispring.github.io/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en'
  };
</script>

  <title>wangzengdi's Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">wangzengdi's Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">Functional Programming</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://adispring.github.io/2021/07/25/Hexo-Workflow/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="wangzengdi">
      <meta itemprop="description" content="FE@Meituan.com">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="wangzengdi's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/07/25/Hexo-Workflow/" class="post-title-link" itemprop="url">Hexo Workflow</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-07-25 10:51:10" itemprop="dateCreated datePublished" datetime="2021-07-25T10:51:10+00:00">2021-07-25</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="quick-start">Quick Start</h2>
<h3 id="create-a-new-post">Create a new post</h3>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="run-server">Run server</h3>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="generate-static-files">Generate static files</h3>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="deploy-to-remote-sites">Deploy to remote sites</h3>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<h3 id="generate-amp-deploy-together">Generate &amp; Deploy together</h3>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo d -g</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>
<h3 id="hexo-zi-dong-hua-bu-shu">Hexo 自动化部署</h3>
<ul>
<li>官方自动化部署文档 – Hexo + Travis: <a href="https://hexo.io/docs/github-pages.html" target="_blank" rel="noopener">https://hexo.io/docs/github-pages.html</a></li>
<li>空白页问题的解决方案：<a href="http://magicse7en.github.io/2016/03/27/travis-ci-auto-deploy-hexo-github/" target="_blank" rel="noopener">http://magicse7en.github.io/2016/03/27/travis-ci-auto-deploy-hexo-github/</a></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://adispring.github.io/2021/07/25/VSCode-Cheat-Sheet/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="wangzengdi">
      <meta itemprop="description" content="FE@Meituan.com">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="wangzengdi's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/07/25/VSCode-Cheat-Sheet/" class="post-title-link" itemprop="url">VSCode Cheat Sheet -- 备忘录</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2021-07-25 10:07:23 / Modified: 10:51:10" itemprop="dateCreated datePublished" datetime="2021-07-25T10:07:23+00:00">2021-07-25</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>VSCode 入门简单、操作方便、扩展灵活的特点，让 VSCode 在编程届（尤其是前端）越来越流行；</p>
<p>而相比之下，Emacs 学习和维护成本都很高，导致用户群较小，开发和维护面临后继无人的局面。Emacs 相对于 VSCode 的优势已经不明显。Emacs 的优势：快捷键、magit 等，在 VSCode 上也都有相应的实现，因此从 Emacs 迁移到 VSCode 的成本也没有想象的那么大。</p>
<p>而缺点却比较多：</p>
<ul>
<li>出问题时，提示不友好，不知道错在哪里；</li>
<li>各种小问题不断，每个小问题可能都要查半天，时间成本比较高；</li>
<li>Emacs 配置比较复杂，需要学习 elisp 语言；</li>
</ul>
<p>鉴于上述几点，本人也要从使用了多年的 Emacs 迁移到 VSCode 了。在此想到了几句话：唯一不变的是变化，选择比努力更重要。</p>
<p>本文将是本人学习 VSCode 总结的备忘录，后面遇到之前用过、总结过、但不熟悉的地方，可以快速查找到解决方法。主要是快捷键</p>
<h2 id="mac-os-kuai-jie-jian">macOS 快捷键</h2>
<h3 id="ming-ci-jie-shi">名词解释</h3>
<ul>
<li>Explorer: 左侧边栏；</li>
<li>Editor: 编辑区；</li>
<li>Editor Group: 编辑组，一个编辑组可以包含多个打开的文件。可以使用 <code>CMD + \</code> 来分割编辑组;</li>
</ul>
<h3 id="ge-qu-yu-qie-huan">各区域切换</h3>
<table>
<thead>
<tr>
<th>快捷键</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>CMD + 0</td>
<td>左侧边栏</td>
</tr>
<tr>
<td>CMD + 1, CMD + 2, CMD + 3…</td>
<td>聚焦 1st，2nd，3rd editor group</td>
</tr>
<tr>
<td>CMD + B</td>
<td>切换左侧边栏是否可见</td>
</tr>
</tbody>
</table>
<h3 id="she-zhi">设置</h3>
<!-- | ⌘k ⌘s | 调出快捷键设置面板 | -->
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://adispring.github.io/2021/04/30/npm-cli-advance-guide/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="wangzengdi">
      <meta itemprop="description" content="FE@Meituan.com">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="wangzengdi's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/04/30/npm-cli-advance-guide/" class="post-title-link" itemprop="url">npm 命令高级指南</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-04-30 11:23:56" itemprop="dateCreated datePublished" datetime="2021-04-30T11:23:56+00:00">2021-04-30</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-07-25 10:51:10" itemprop="dateModified" datetime="2021-07-25T10:51:10+00:00">2021-07-25</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>本文整理了一些 npm 不常用、但非常有用的命令。主要分为以下几大类：</p>
<ul>
<li>
<p>查看 npm 源(registry) 上的 npm 包信息</p>
<ul>
<li>npm view</li>
</ul>
</li>
<li>
<p>开发 npm 包时，用到的命令</p>
<ul>
<li>npm publish</li>
<li>npm pack</li>
<li>npm link &amp; npm unlink</li>
<li>npm set-script</li>
</ul>
</li>
<li>
<p>查看已安装的 npm 包的本地信息</p>
<ul>
<li>npm ls</li>
<li>npm edit</li>
<li>npm explore</li>
<li>npm explain | npm why</li>
</ul>
</li>
<li>
<p>浏览器查看 npm 包信息</p>
<ul>
<li>npm docs</li>
<li>npm repo</li>
</ul>
</li>
<li>
<p>使用 npm 包开发其他项目时，用到的命令</p>
<ul>
<li>npm outdated</li>
<li>npm update</li>
</ul>
</li>
<li>
<p>其他 npm 命令</p>
<ul>
<li>npm config</li>
<li>npm bin</li>
<li>npm completion</li>
</ul>
</li>
</ul>
<h1 id="cha-kan-npm-yuan-registry-shang-de-npm-bao-xin-xi">查看 npm 源(registry) 上的 npm 包信息</h1>
<ul>
<li>npm view: 最为灵活、最为强大的 查看 npm 包信息的命令；</li>
</ul>
<p>由于 <code>npm view</code> 太灵活，所以需要单独一小节进行讲解。</p>
<h2 id="npm-view">npm view</h2>
<p>查看 npm 源上包的信息</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm view [&lt;@scope&gt;/]&lt;name&gt;[@&lt;version&gt;] [&lt;field&gt;[.&lt;subfield&gt;]...]</span><br><span class="line"></span><br><span class="line">aliases: info, show, v</span><br></pre></td></tr></table></figure>
<h3 id="cha-kan-bao-de-ji-ben-xin-xi">查看包的基本信息</h3>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm view &lt;pkg&gt;</span><br></pre></td></tr></table></figure>
<p>示例：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">› npm view ramda</span><br><span class="line"></span><br><span class="line">ramda@0.27.1 | MIT | deps: none | versions: 52</span><br><span class="line">A practical functional library <span class="keyword">for</span> JavaScript programmers.</span><br><span class="line">https://ramdajs.com/</span><br><span class="line"></span><br><span class="line">dist</span><br><span class="line">.tarball: http://r.npm.sankuai.com/ramda/download/ramda-0.27.1.tgz</span><br><span class="line">.shasum: 66fc2df3ef873874ffc2da6aa8984658abacf5c9</span><br><span class="line"></span><br><span class="line">maintainers:</span><br><span class="line">- aromano &lt;aromano@preemptsecurity.com&gt;</span><br><span class="line">- bradcomp &lt;notpmoc84@hotmail.com&gt;</span><br><span class="line">- ...</span><br><span class="line"></span><br><span class="line">dist-tags:</span><br><span class="line">0.2.0: 0.2.0          es-rc: 0.24.1-es.rc3  latest: 0.27.1</span><br><span class="line"></span><br><span class="line">published 9 months ago by davidchambers &lt;dc@davidchambers.me&gt;</span><br></pre></td></tr></table></figure>
<h3 id="geng-jia-ling-huo-de-cha-kan-bao-de-xiang-xi-xin-xi">更加灵活的查看包的详细信息</h3>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm view &lt;pkg&gt;@&lt;version&gt; &lt;field&gt;[.&lt;subfield&gt;]...</span><br></pre></td></tr></table></figure>
<h4 id="cha-kan-bao-de-yi-lai">查看包的依赖</h4>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">› npm view http-server dependencies</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">'basic-auth'</span>: <span class="string">'^1.0.3'</span>,</span><br><span class="line">  colors: <span class="string">'^1.4.0'</span>,</span><br><span class="line">  corser: <span class="string">'^2.0.1'</span>,</span><br><span class="line">  ecstatic: <span class="string">'^3.3.2'</span>,</span><br><span class="line">  <span class="string">'http-proxy'</span>: <span class="string">'^1.18.0'</span>,</span><br><span class="line">  minimist: <span class="string">'^1.2.5'</span>,</span><br><span class="line">  opener: <span class="string">'^1.5.1'</span>,</span><br><span class="line">  portfinder: <span class="string">'^1.0.25'</span>,</span><br><span class="line">  <span class="string">'secure-compare'</span>: <span class="string">'3.0.1'</span>,</span><br><span class="line">  union: <span class="string">'~0.5.0'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="cha-kan-bao-de-zui-xin-ban-ben">查看包的最新版本</h4>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">› npm view ramda version</span><br><span class="line">0.27.1</span><br></pre></td></tr></table></figure>
<h4 id="cha-kan-bao-fa-bu-de-suo-you-ban-ben">查看包发布的所有版本</h4>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">› npm view ramda versions</span><br><span class="line">[</span><br><span class="line">  <span class="string">'0.1.0'</span>,         <span class="string">'0.1.1'</span>,         <span class="string">'0.1.2'</span>,</span><br><span class="line">  <span class="string">'0.1.4'</span>,         <span class="string">'0.1.5'</span>,         <span class="string">'0.2.0'</span>,</span><br><span class="line">  <span class="string">'0.2.1'</span>,         <span class="string">'0.2.2'</span>,         <span class="string">'0.2.3'</span>,</span><br><span class="line">  <span class="string">'0.2.4'</span>,         <span class="string">'0.3.0'</span>,         <span class="string">'0.4.0'</span>,</span><br><span class="line">  <span class="string">'0.4.1'</span>,         <span class="string">'0.4.2'</span>,         <span class="string">'0.4.3'</span>,</span><br><span class="line">  <span class="string">'0.5.0'</span>,         <span class="string">'0.6.0'</span>,         <span class="string">'0.7.0'</span>,</span><br><span class="line">  <span class="string">'0.7.1'</span>,         <span class="string">'0.7.2'</span>,         <span class="string">'0.8.0'</span>,</span><br><span class="line">  <span class="string">'0.9.0'</span>,         <span class="string">'0.9.1'</span>,         <span class="string">'0.10.0'</span>,</span><br><span class="line">  <span class="string">'0.11.0'</span>,        <span class="string">'0.12.0'</span>,        <span class="string">'0.13.0'</span>,</span><br><span class="line">  <span class="string">'0.14.0'</span>,        <span class="string">'0.15.0'</span>,        <span class="string">'0.15.1'</span>,</span><br><span class="line">  <span class="string">'0.16.0'</span>,        <span class="string">'0.17.0'</span>,        <span class="string">'0.17.1'</span>,</span><br><span class="line">  <span class="string">'0.18.0'</span>,        <span class="string">'0.19.0'</span>,        <span class="string">'0.19.1'</span>,</span><br><span class="line">  <span class="string">'0.20.0'</span>,        <span class="string">'0.20.1'</span>,        <span class="string">'0.21.0'</span>,</span><br><span class="line">  <span class="string">'0.22.0'</span>,        <span class="string">'0.22.1'</span>,        <span class="string">'0.23.0'</span>,</span><br><span class="line">  <span class="string">'0.24.0'</span>,        <span class="string">'0.24.1-es.rc1'</span>, <span class="string">'0.24.1-es.rc2'</span>,</span><br><span class="line">  <span class="string">'0.24.1-es.rc3'</span>, <span class="string">'0.24.1'</span>,        <span class="string">'0.25.0'</span>,</span><br><span class="line">  <span class="string">'0.26.0'</span>,        <span class="string">'0.26.1'</span>,        <span class="string">'0.27.0'</span>,</span><br><span class="line">  <span class="string">'0.27.1'</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<h4 id="cha-kan-zhi-ding-ban-ben-fan-wei-nei-de-bao-de-fa-bu-qing-kuang">查看指定版本范围内的包的发布情况</h4>
<p>查看自 0.25.0 以来，所有版本 ramda 包的信息</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm view ramda@<span class="string">'&gt;=0.25.0'</span></span><br></pre></td></tr></table></figure>
<h4 id="cha-kan-npm-bao-guan-wang-di-zhi">查看 npm 包官网地址</h4>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm view ramda homepage</span><br></pre></td></tr></table></figure>
<h4 id="cha-kan-npm-bao-cang-ku-di-zhi">查看 npm 包仓库地址</h4>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm view ramda repository.url</span><br></pre></td></tr></table></figure>
<h4 id="tong-guo-shell-jiao-ben-zu-he-chu-ling-huo-de-cha-xun-ming-ling">通过 shell 脚本，组合出灵活的查询命令</h4>
<p>可以通过一些 Shell 脚本轻松查看有关依赖项的信息。例如，要查看有关ronn所依赖的opts版本的所有数据，如下所示：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm view opts@$(npm view ronn dependencies.opts)</span><br></pre></td></tr></table></figure>
<p>更多 <code>npm view</code> 的高级用法，可以查看 <a href="https://docs.npmjs.com/cli/v7/commands/npm-view" target="_blank" rel="noopener">npm view 官方文档</a></p>
<h1 id="kai-fa-npm-bao-she-ji-de-ming-ling">开发 npm 包涉及的命令</h1>
<ul>
<li>
<p>npm publish: 将包发布到 npm 源(registry) 上去;</p>
</li>
<li>
<p>npm pack: 打包;</p>
</li>
<li>
<p>npm link: 将当前 package 文件夹软链到全局 npm 环境中;</p>
</li>
<li>
<p>npm unlink: 断开全局软链时，其实就是 npm uninstall 的别名;</p>
</li>
<li>
<p>npm set-script: 在 package.json 的 <code>&quot;scripts&quot;</code> 字段中设置任务;</p>
</li>
</ul>
<h2 id="npm-publish-fa-bao">npm publish – 发包</h2>
<p>将包发布到 npm 源(registry) 上去。</p>
<h3 id="mo-ni-fa-bao">模拟发包</h3>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm publish --dry-run</span><br></pre></td></tr></table></figure>
<p><code>npm publish --dry-run</code> 只是模拟发包，并不会真正发包。会将发包过程中的所有信息都打印出来，用作发包前进行信息确认。也可以使用 <code>npm pack --dry-run</code></p>
<h3 id="fa-bu-de-bao-zhong-bao-han-de-wen-jian">发布的包中包含的文件</h3>
<p>要查看软件包中将包含的内容，请运行 <code>npx npm-packlist</code>。默认情况下，所有文件都包括在内，但以下情况除外：</p>
<ul>
<li>
<p>始终包含与软件包安装和分发相关的某些文件。例如，<code>package.json</code>，<code>README.md</code>，<code>LICENSE</code> 等。</p>
</li>
<li>
<p>如果 <code>package.json</code> 中有一个 <code>&quot;files&quot;</code> 列表字段，则仅包含 <code>&quot;files&quot;</code> 指定的文件。（如果指定了目录，则将遵循相同的忽略规则，以递归方式遍历目录并包含目录的内容。）</p>
</li>
<li>
<p>如果存在 <code>.gitignore</code> 或 <code>.npmignore</code> 文件，则其中的被忽略文件以及所有子目录都将从软件包中排除。如果两个文件都存在，则将忽略 <code>.gitignore</code>，而仅使用 <code>.npmignore</code>。</p>
<p><code>.npmignore</code> 文件遵循与 <code>.gitignore</code> 文件相同的模式规则</p>
</li>
<li>
<p><strong>需要特别注意的是：如果文件匹配某些模式，则除非明确将其添加到 <code>package.json</code> 的 “files” 列表中，否则将永远不会将其包括在内，或者在 <code>.npmignore</code> 或 <code>.gitignore</code> 文件中使用 <code>!</code> ，来强制包含需要发布的文件</strong>。</p>
<p>例如，npm 发包，默认是会忽略 <code>.npmrc</code> 文件的，如果我确实需要将 <code>.npmrc</code> 包含进发布的包中，则需要使用在 <code>.npmignore</code> 或 <code>.gitignore</code> 中写入规则 <code>!.npmrc</code>，<code>!.npmrc</code> 表示强制包含 <code>.npmrc</code>。</p>
</li>
<li>
<p>符号链接永远不会包含在 npm 软件包中。</p>
</li>
</ul>
<p>有关已发布的软件包中包含的内容以及如何构建该软件包的详细信息，请查看 <a href="https://docs.npmjs.com/cli/v7/using-npm/developers" target="_blank" rel="noopener">开发者须知</a> 。</p>
<h2 id="npm-pack-da-bao">npm pack – 打包</h2>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm pack [[&lt;@scope&gt;/]&lt;pkg&gt;...] [--dry-run]</span><br></pre></td></tr></table></figure>
<p>一般会用到 <code>npm pack --dry-run</code> ，看一下即将发布的包的打包情况。加了 <code>--dry-run</code> 会后，命令不会真正的执行，只是把之间结果打印出来，以供调试使用。</p>
<h2 id="npm-link-amp-npm-unlink-ben-di-kai-fa">npm link &amp; npm unlink - 本地开发</h2>
<p>本地调试利器</p>
<h3 id="npm-link">npm link</h3>
<p>将当前 package 文件夹软链到全局 npm 环境中。开发某个 npm 包时，本地调试非常好用。避免了在开发过程中不断重复发包的困扰。</p>
<p>npm link 分两步：</p>
<ul>
<li>
<p>软链当前的 package；</p>
</li>
<li>
<p>使用软链过的 package；</p>
</li>
</ul>
<p>如下所示：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/projects/node-redis    <span class="comment"># go into the package directory</span></span><br><span class="line">npm link                    <span class="comment"># creates global link</span></span><br><span class="line"><span class="built_in">cd</span> ~/projects/node-bloggy   <span class="comment"># go into some other package directory.</span></span><br><span class="line">npm link redis              <span class="comment"># link-install the package</span></span><br></pre></td></tr></table></figure>
<h3 id="npm-unlink">npm unlink</h3>
<p>当本地调试完成，想要断开全局软链时，运行下面命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm unlink &lt;pkg&gt; -g</span><br></pre></td></tr></table></figure>
<p><code>npm unlink</code> 会将 <pkg> 从全局的 npm 环境中移除（断开软链）。</pkg></p>
<p>注：<code>npm unlink</code> 其实是 <code>npm uninstall</code> 的别名，所以运行 <code>npm unlink &lt;pkg&gt; -g</code> 等价于 <code>npm uninstall &lt;pkg&gt; -g</code> 。</p>
<h3 id="npm-set-script">npm set-script</h3>
<p>在 package.json 的 <code>&quot;scripts&quot;</code> 字段中设置任务。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm <span class="built_in">set</span>-script [&lt;script&gt;] [&lt;<span class="built_in">command</span>&gt;]</span><br></pre></td></tr></table></figure>
<p>如果开发的 npm 包在安装时，需要动态修改项目中 <code>package.json</code> 文件的 <code>&quot;scripts&quot;</code> ，则可以使用该命令进行设置。</p>
<p>示例:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm <span class="built_in">set</span>-script start <span class="string">"http-server ."</span></span><br></pre></td></tr></table></figure>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"name"</span>: <span class="string">"my-project"</span>,</span><br><span class="line">  <span class="attr">"scripts"</span>: &#123;</span><br><span class="line">    <span class="attr">"start"</span>: <span class="string">"http-server ."</span>,</span><br><span class="line">    <span class="attr">"test"</span>: <span class="string">"some existing value"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>向 <code>&quot;scripts&quot;</code> 中添加 <code>&quot;start&quot;</code> 脚本。</p>
<h1 id="cha-kan-yi-an-zhuang-de-npm-bao-de-ben-di-xin-xi">查看已安装的 npm 包的本地信息</h1>
<ul>
<li>
<p>npm ls: 列出安装的 packages，或者指定 package 的依赖树；</p>
</li>
<li>
<p>npm edit: 使用默认的编辑器打开当前项目中指定的 npm 包；</p>
</li>
<li>
<p>npm explore: 进入指定的被安装的 npm 包的目录；</p>
</li>
<li>
<p>npm explain | npm why: 解释 packages 被安装的原因。主要是把指定包的依赖链条打印出来；</p>
</li>
</ul>
<h2 id="npm-ls">npm ls</h2>
<p>列出安装的 packages。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm ls [&lt;pkg&gt; -g]</span><br></pre></td></tr></table></figure>
<h3 id="da-yin-chu-dang-qian-xiang-mu-yi-an-zhuang-de-shou-ceng-packages">打印出当前项目已安装的首层 packages</h3>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm ls</span><br></pre></td></tr></table></figure>
<h3 id="suo-you-de-yi-lai-yi-yi-lai-shu-de-xing-shi-da-yin-chu-lai">所有的依赖以依赖树的形式打印出来</h3>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm ls -all</span><br></pre></td></tr></table></figure>
<p>当使用 <code>--all</code> 时，会将所有的依赖以依赖树的形式打印出来。</p>
<h3 id="da-yin-quan-ju-an-zhuang-de-packages">打印全局安装的 packages</h3>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm ls -g</span><br></pre></td></tr></table></figure>
<h3 id="da-yin-zhi-ding-packages-de-an-zhuang-qing-kuang">打印指定 packages 的安装情况</h3>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm ls name@version-range</span><br></pre></td></tr></table></figure>
<p><code>npm ls name@version-range</code> 可以以结构树的形式打印出指定 package 在项目中的安装情况。</p>
<p>也可以使用 <code>npm explain</code> 查看指定的 package 为什么会被安装，作用相当于 <code>npm ls</code> ，只不过展示的顺序是反向的。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm explain name</span><br></pre></td></tr></table></figure>
<h2 id="npm-edit">npm edit</h2>
<p>使用默认的编辑器，直接打开当前项目已经安装的 package 的文件夹。可以省去手动到 node_modules 中查找 package 的麻烦。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm edit &lt;pkg&gt;</span><br></pre></td></tr></table></figure>
<p>例如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm edit prettier</span><br></pre></td></tr></table></figure>
<p>会打开当前项目下的 <code>./node_modules/prettier</code> 目录。</p>
<h3 id="zhi-ding-mo-ren-de-bian-ji-qi-xiu-gai-code-editor-code-bian-liang">指定默认的编辑器，修改 <code>$EDITOR</code> 变量</h3>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="built_in">export</span> EDITOR=<span class="string">"emacsclient -t"</span> &gt;&gt; ~/.zshrc</span><br></pre></td></tr></table></figure>
<h2 id="npm-explore">npm explore</h2>
<p>在命令行中，进入指定的被安装的 package 文件夹中。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm explore &lt;pkg&gt; [ -- &lt;<span class="built_in">command</span>&gt;]</span><br></pre></td></tr></table></figure>
<p>示例：</p>
<ol>
<li>进入当前项目中某 package 的目录</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 进入当前项目中安装的 prettier 目录</span><br><span class="line">npm explore prettier</span><br><span class="line"></span><br><span class="line"><span class="built_in">pwd</span></span><br><span class="line">// project/node_modules/prettier</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>进入全局安装的某 package 目录</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 进入全局安装的 prettier 目录</span><br><span class="line">npm explore prettier -g</span><br><span class="line"></span><br><span class="line"><span class="built_in">pwd</span></span><br><span class="line">// /Users/wangzengdi/.nvm/versions/node/v14.15.4/lib/node_modules/prettier</span><br></pre></td></tr></table></figure>
<h2 id="npm-explain-npm-why">npm explain | npm why</h2>
<p>解释已安装的 packages，被安装的原因。</p>
<p>会将当前指定包的依赖关系打印出来（哪些包依赖的指定的包），可以用于解释为什么一个依赖为什么会被安装多次。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm explain &lt;folder | specifier&gt;</span><br><span class="line"></span><br><span class="line"><span class="built_in">alias</span>: why</span><br></pre></td></tr></table></figure>
<p>例如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">› npm explain eslint</span><br><span class="line"></span><br><span class="line">eslint@7.25.0 dev</span><br><span class="line">node_modules/eslint</span><br><span class="line">  dev eslint@<span class="string">"^7.25.0"</span> from the root project</span><br><span class="line">  peer eslint@<span class="string">"&gt;= 4.12.1"</span> from babel-eslint@10.1.0</span><br><span class="line">  node_modules/babel-eslint</span><br><span class="line">    dev babel-eslint@<span class="string">"^10.1.0"</span> from the root project</span><br><span class="line">  peer eslint@<span class="string">"&gt;=7.0.0"</span> from eslint-config-prettier@8.3.0</span><br><span class="line">  node_modules/eslint-config-prettier</span><br><span class="line">    dev eslint-config-prettier@<span class="string">"^8.3.0"</span> from the root project</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure>
<p>表示当前项目在 devDependencies 中安装了 7.25.0 版本的 eslint，安装的位置为 <code>node_modules/eslint</code> 。后面的部分表明是哪些包的依赖，导致了 eslint 的安装。</p>
<h1 id="liu-lan-qi-cha-kan-npm-bao-xin-xi">浏览器查看 npm 包信息</h1>
<ul>
<li>
<p>npm docs | npm home: 在浏览器中打开 npm 包官网；</p>
</li>
<li>
<p>npm repo: 在浏览器中打开 npm 包仓库地址；</p>
</li>
</ul>
<h2 id="npm-docs">npm docs</h2>
<p>在浏览器中打开指定 npm 包的官方网站。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm docs [pakname]</span><br><span class="line"></span><br><span class="line">aliases: home</span><br></pre></td></tr></table></figure>
<p>例如</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 会打开 react 官网: https://reactjs.org/</span></span><br><span class="line">npm docs react</span><br><span class="line"></span><br><span class="line"><span class="comment"># 会打开 ramda 官网: https://ramdajs.com/</span></span><br><span class="line">npm docs ramda</span><br></pre></td></tr></table></figure>
<p>npm 的官方网站一般写在 package.json 中的 “homepage” 字段中。</p>
<h2 id="npm-repo">npm repo</h2>
<p>在浏览器中打开指定 npm 包的仓库（一般为 github 仓库）地址。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm repo [&lt;pkgname&gt; [&lt;pkgname&gt; ...]]</span><br></pre></td></tr></table></figure>
<p>例如</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 会打开 ramda github 仓库: https://github.com/ramda/ramda</span></span><br><span class="line">npm repo ramda</span><br></pre></td></tr></table></figure>
<h1 id="shi-yong-npm-bao-kai-fa-qi-ta-xiang-mu-shi-yong-dao-de-ming-ling">使用 npm 包开发其他项目时，用到的命令</h1>
<h2 id="npm-outdated-vs-npm-update">npm outdated vs npm update</h2>
<h3 id="npm-outdated">npm outdated</h3>
<p>查看项目中是否存在过期的 packages，或者指定的 packages 是否过期</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm outdated [&lt;pkg&gt; ...]</span><br></pre></td></tr></table></figure>
<p>举例</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">› npm outdated</span><br><span class="line">Package       Current  Wanted  Latest  Location                   Depended by</span><br><span class="line">semver-regex    3.1.2   3.1.2   4.0.0  node_modules/semver-regex  fe.cli</span><br></pre></td></tr></table></figure>
<p>在某一项目下运行 <code>npm outdated</code>，便可以列出当前项目中所有已经过期的依赖。</p>
<p>如上所示，semver-regex 已经过期了，当前版本为 <code>3.1.2</code>，最新版本为 <code>4.0.0</code>。</p>
<p>想要查看 package 的详细信息，可以使用<code>npm view &lt;pkg&gt;</code>，如查看 semver-regex： <code>npm view semver-regex</code>。</p>
<h4 id="cha-kan-quan-ju-yi-jing-guo-qi-de-package">查看全局已经过期的 package</h4>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm outdated -g</span><br></pre></td></tr></table></figure>
<h3 id="npm-update-amp-npm-upgrade">npm update &amp; npm upgrade</h3>
<p>更新 packages，npm update 会将 package 更新到当前已发布的 <strong>最新版本</strong>。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm update [-g] [&lt;pkg&gt;...]</span><br><span class="line"></span><br><span class="line">aliases: up, upgrade</span><br></pre></td></tr></table></figure>
<p>在上文中，我们已经介绍了使用 <code>npm outdated</code> 查看过期的 packages。本段将介绍如何使用 <code>npm update</code> 更新过期的 packages</p>
<h4 id="geng-xin-dang-qian-xiang-mu-zhong-suo-you-guo-qi-de-xiang-mu">更新当前项目中所有过期的项目</h4>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm update</span><br></pre></td></tr></table></figure>
<h4 id="geng-xin-quan-ju-de-guo-qi-xiang-mu">更新全局的过期项目</h4>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm update -g</span><br></pre></td></tr></table></figure>
<h4 id="geng-xin-zhi-ding-de-packages">更新指定的 packages</h4>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm update pkg1 pkg2 ...</span><br></pre></td></tr></table></figure>
<h1 id="qi-ta-npm-ming-ling">其他 npm 命令</h1>
<ul>
<li>
<p>npm config: npm 配置</p>
</li>
<li>
<p>npm bin: 打印 npm 可执行命令 bin 的文件夹</p>
</li>
<li>
<p>npm completion: npm 补全脚本</p>
</li>
</ul>
<h2 id="npm-config">npm config</h2>
<p>npm 配置。用于列出当前 npm 环境的配置信息，或管理 npm 配置文件，一般是 .npmrc。</p>
<h3 id="lie-chu-dang-qian-de-npm-pei-zhi">列出当前的 npm 配置</h3>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">npm config list</span><br><span class="line"></span><br><span class="line"><span class="comment"># 列出详细配置</span></span><br><span class="line">npm config list -l</span><br></pre></td></tr></table></figure>
<h2 id="npm-bin">npm bin</h2>
<p>打印 npm 可执行命令 bin 的文件夹</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm bin [-g | --global]</span><br></pre></td></tr></table></figure>
<h2 id="npm-completion">npm completion</h2>
<p>npm 补全命令脚本， 可以通过下列命令将命令补全脚本注入到 .bashrc 或 .zshrc 中，这样即可以在终端的任何地方使用。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm completion &gt;&gt; ~/.bashrc</span><br><span class="line">npm completion &gt;&gt; ~/.zshrc</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://adispring.github.io/2018/09/09/Hexo-Init/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="wangzengdi">
      <meta itemprop="description" content="FE@Meituan.com">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="wangzengdi's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/09/09/Hexo-Init/" class="post-title-link" itemprop="url">Hexo-Init</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2018-09-09 08:54:45" itemprop="dateCreated datePublished" datetime="2018-09-09T08:54:45+00:00">2018-09-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-07-25 10:51:10" itemprop="dateModified" datetime="2021-07-25T10:51:10+00:00">2021-07-25</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="hexo-cai-keng-zhi-nan">Hexo 踩坑指南</h2>
<h3 id="an-zhuang-zhu-ti">安装主题</h3>
<p>我选用 <a href="https://github.com/theme-next/hexo-theme-next" target="_blank" rel="noopener">next</a> 主题，简洁、素雅</p>
<p>安装指南：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> hexo</span><br><span class="line">$ git <span class="built_in">clone</span> https://github.com/theme-next/hexo-theme-next themes/next</span><br></pre></td></tr></table></figure>
<h3 id="favicon-pei-zhi">favicon 配置</h3>
<p>需要在 <code>themes/next/_config.yml</code> 中对 favicon 进行配置，我的配置如下</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ---------------------------------------------------------------</span></span><br><span class="line"><span class="comment"># Site Information Settings</span></span><br><span class="line"><span class="comment"># ---------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># To get or check favicons visit: https://realfavicongenerator.net</span></span><br><span class="line"><span class="comment"># Put your favicons into `hexo-site/source/` (recommend) or `hexo-site/themes/next/source/images/` directory.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Default NexT favicons placed in `hexo-site/themes/next/source/images/` directory.</span></span><br><span class="line"><span class="comment"># And if you want to place your icons in `hexo-site/source/` root directory, you must remove `/images` prefix from pathes.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># For example, you put your favicons into `hexo-site/source/images` directory.</span></span><br><span class="line"><span class="comment"># Then need to rename &amp; redefine they on any other names, otherwise icons from Next will rewrite your custom icons in Hexo.</span></span><br><span class="line">favicon:</span><br><span class="line">  small: /favicon.ico</span><br><span class="line">  medium: /favicon.ico</span><br><span class="line">  apple_touch_icon: /images/apple-touch-icon-next.ico</span><br><span class="line">  safari_pinned_tab: /logo.svg</span><br><span class="line">  <span class="comment">#android_manifest: /images/manifest.json</span></span><br><span class="line">  <span class="comment">#ms_browserconfig: /images/browserconfig.xml</span></span><br></pre></td></tr></table></figure>
<h3 id="guan-yu-mao-dian-shi-xiao-wen-ti">关于锚点失效问题</h3>
<p>这是 <a href="https://github.com/hexojs/hexo-renderer-markdown-it" target="_blank" rel="noopener">hexo-renderer-markdown-it</a> 的一个 bug，但作者不想修复，认为是其他库的坑，所以我们要参考这个 <a href="https://github.com/hexojs/hexo-renderer-markdown-it/issues/40" target="_blank" rel="noopener">issue</a> ，手动到 node_modules 中修改该库，具体如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">'use strict'</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span> (<span class="params">data, options</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> MdIt = <span class="built_in">require</span>(<span class="string">'markdown-it'</span>);</span><br><span class="line">  <span class="keyword">var</span> cfg = <span class="keyword">this</span>.config.markdown;</span><br><span class="line">  <span class="keyword">var</span> opt = (cfg) ? cfg : <span class="string">'default'</span>;</span><br><span class="line">  <span class="keyword">var</span> parser = (opt === <span class="string">'default'</span> || opt === <span class="string">'commonmark'</span> || opt === <span class="string">'zero'</span>) ?</span><br><span class="line">    <span class="keyword">new</span> MdIt(opt) :</span><br><span class="line">    <span class="keyword">new</span> MdIt(opt.render);</span><br><span class="line"></span><br><span class="line">  parser.use(<span class="built_in">require</span>(<span class="string">'markdown-it-named-headings'</span>)) <span class="comment">// 只需要添加这行代码</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (opt.plugins) &#123;</span><br><span class="line">    parser = opt.plugins.reduce(<span class="function"><span class="keyword">function</span> (<span class="params">parser, pugs</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> parser.use(<span class="built_in">require</span>(pugs));</span><br><span class="line">    &#125;, parser);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (opt.anchors) &#123;</span><br><span class="line">    parser = parser.use(<span class="built_in">require</span>(<span class="string">'./anchors'</span>), opt.anchors);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> parser.render(data.text);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="zi-dong-hua-xiu-fu-yi-shang-wen-ti-de-jiao-ben">自动化修复以上问题的脚本</h3>
<p>写了一个自动化脚本，git pull 下我的博客备份后，自动安装、修复上述问题。</p>
<p>运行工程目录下的 <code>./hexo-init.sh</code>，内容如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line">npm i hexo-cli -g</span><br><span class="line"></span><br><span class="line">yarn</span><br><span class="line"></span><br><span class="line">git <span class="built_in">clone</span> https://github.com/theme-next/hexo-theme-next themes/next</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修复锚点不生效问题</span></span><br><span class="line">cp ./init_source/hexo-renderer-markdown-it/lib/renderer.js ./node_modules/hexo-renderer-markdown-it/lib/renderer.js</span><br><span class="line"></span><br><span class="line"><span class="comment"># 自动配置 favicon</span></span><br><span class="line">cp ./init_source/next/_config.yml ./themes/next/_config.yml</span><br></pre></td></tr></table></figure>
<h3 id="git-pull-xia-lai-de-hexo-gong-cheng-hexo-deploy-hou-jiang-zheng-ge-xiang-mu-du-push-shang-qu-liao">Git pull 下来的 Hexo 工程，hexo deploy 后将整个项目都 push 上去了</h3>
<p>每次 git pull 备份的工程后，需要清理一下 hexo 工程，具体方法如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> adispring.github.io</span><br><span class="line">rm -rf .git .deploy_git hexo clean</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://adispring.github.io/2018/09/08/Fantasy-Land-Specification/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="wangzengdi">
      <meta itemprop="description" content="FE@Meituan.com">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="wangzengdi's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/09/08/Fantasy-Land-Specification/" class="post-title-link" itemprop="url">Fantasy-Land-Specification</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2018-09-08 16:45:36" itemprop="dateCreated datePublished" datetime="2018-09-08T16:45:36+00:00">2018-09-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-07-25 10:51:10" itemprop="dateModified" datetime="2021-07-25T10:51:10+00:00">2021-07-25</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>(又名 “代数 JavaScript 规范”)</p>
<p><img src="./logo.png" alt="logo"></p>
<p>该项目规定了通用代数数据结构的互操作性：</p>
<ul>
<li><a href="#setoid">Setoid</a></li>
<li><a href="#ord">Ord</a></li>
<li><a href="#semigroupoid">Semigroupoid</a></li>
<li><a href="#category">Category</a></li>
<li><a href="#semigroup">Semigroup</a></li>
<li><a href="#monoid">Monoid</a></li>
<li><a href="#group">Group</a></li>
<li><a href="#filterable">Filterable</a></li>
<li><a href="#functor">Functor</a></li>
<li><a href="#contravariant">Contravariant</a></li>
<li><a href="#apply">Apply</a></li>
<li><a href="#applicative">Applicative</a></li>
<li><a href="#alt">Alt</a></li>
<li><a href="#plus">Plus</a></li>
<li><a href="#alternative">Alternative</a></li>
<li><a href="#foldable">Foldable</a></li>
<li><a href="#traversable">Traversable</a></li>
<li><a href="#chain">Chain</a></li>
<li><a href="#chainrec">ChainRec</a></li>
<li><a href="#monad">Monad</a></li>
<li><a href="#extend">Extend</a></li>
<li><a href="#comonad">Comonad</a></li>
<li><a href="#bifunctor">Bifunctor</a></li>
<li><a href="#profunctor">Profunctor</a></li>
</ul>
<p><img src="./dependencies.png" alt="dependencies"></p>
<h2 id="gai-lan">概览</h2>
<p>代数是遵循一定法则的、具有封闭性的，一系列值及一系列操作的集合。</p>
<p>每个 Fantasy Land 代数是一个单独的规范。一个代数可能依赖于其他必需实现的代数。</p>
<h2 id="zhu-yu">术语</h2>
<ol>
<li>
<p>“值”：任何 JavaScript 值，包括下面定义的结构的任何值。</p>
</li>
<li>
<p>“等价”：对给定值的等价性的恰当定义。这个定义应该保证两个值可以在其对应的抽象的程序中，能够安全地进行交换。例如：</p>
<ul>
<li>当两个列表对应的索引上的值都相等时，它们是等价的。</li>
<li>当两个普通的 JavaScript 对象所有键值对都相等时，它们（作为字典）是等价的。</li>
<li>当两个 promises 生成相等的值时，它们是等价的。</li>
<li>当两个函数给定相同的输入，产生相同的输出时，它们是等价的。</li>
</ul>
</li>
</ol>
<h2 id="lei-xing-qian-ming-fu-hao">类型签名符号</h2>
<p>本文档使用的类型签名符号如下所述：[^1]</p>
<ul>
<li><code>::</code> _<em>“是 xx 的成员”。</em>
<ul>
<li><code>e :: t</code> 读作：“表达式 <code>e</code> 是类型 <code>t</code> 的成员”。</li>
<li><code>true :: Boolean</code> - “<code>true</code> 是类型 <code>Boolean</code> 的成员”。</li>
<li><code>42 :: Integer, Number</code> - “<code>42</code> 是类型 <code>Integer</code> 和 <code>Number</code> 的成员”。</li>
</ul>
</li>
<li><em>新类型可以通过类型构造函数创建。</em>
<ul>
<li>类型构造函数可以接受零或多个类型参数。</li>
<li><code>Array</code> 是一个接受单个参数的类型构造函数。</li>
<li><code>Array String</code> 代表包含字符串的数组的类型。后面每个都是 <code>Array String</code> 类型的：<code>[]</code>，<code>['foo', 'bar', 'baz']</code>。</li>
<li><code>Array (Array String)</code> 代表包含字符串的数组的数组的类型。后面每个都是 <code>Array (Array String)</code> 类型的：<code>[]</code>，<code>[[], []]</code>， <code>[[], ['foo'], ['bar', 'baz']]</code>。</li>
</ul>
</li>
<li><em>小写字母代表类型变量。</em>
<ul>
<li>类型变量可以接受任何类型，除非受到类型约束的限制（参见下面的胖箭头）。</li>
<li><code>-&gt;</code> (箭头) <em>函数类型的构造函数</em></li>
<li><code>-&gt;</code> 是一个 <em>中缀</em> 构造函数，它接受两个类型参数，左侧参数为输入的类型，右侧参数为输出的类型。</li>
<li><code>-&gt;</code> 的输入类型可以通过一组类型创建出来，该函数接受零个或多个参数。其语法是：<code>(&lt;input-types&gt;) -&gt; &lt;output-type&gt;</code>，其中 <code>&lt;input-types&gt;</code> 包含零个或多个 “逗号-空格” （<code>, </code>）分开的类型表示，对于一元函数，圆括号也可以省略。</li>
<li><code>String -&gt; Array String</code> 是一种接受一个 <code>String</code> 并返回一个 <code>Array String</code> 的函数的类型。</li>
<li><code>String -&gt; Array String -&gt; Array String</code> 是一种函数类型，它接受一个 <code>String</code> 并返回一个函数，返回的函数接受一个 <code>Array String</code> 并返回一个 <code>Array String</code>。</li>
<li><code>(String, Array String) -&gt; Array String</code> 是一种函数类型，它接受一个 <code>String</code> 和 <code>Aray String</code> 作为参数，并返回一个 <code>Array String</code> 。</li>
<li><code>() -&gt; Number</code> 是一种不带输入参数，返回 <code>Number</code> 的函数类型。</li>
</ul>
</li>
<li><code>~&gt;</code> (波浪形箭头) <em>方法类型的构造函数。</em>
<ul>
<li>当一个函数是一个对象（Object）的属性时，它被称为方法。所有方法都有一个隐含的参数类型 - 它是属性所在对象的类型。</li>
<li><code>a ~&gt; a -&gt; a</code> 是一种对象中方法的类型，它接受 <code>a</code> 类型的参数，并返回一个 <code>a</code> 类型的值。</li>
</ul>
</li>
<li><code>=&gt;</code> (胖箭头) 表示对类型变量的约束。
<ul>
<li>在 <code>a ~&gt; a -&gt; a</code>（参见上面的波浪形箭头）中，<code>a</code> 可以为任意类型。半群 <code>a =&gt; a ~&gt; a -&gt; a</code> 会添加一个约束，使得类型 <code>a</code> 现在必须满足该半群的类型类。满足类型类意味着，须合法地实现该类型类指定所有函数/方法。</li>
</ul>
</li>
</ul>
<p>例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">traverse :: Applicative f, Traversable t =&gt; t a ~&gt; (TypeRep f, a -&gt; f b) -&gt; f (t b)</span><br><span class="line">&apos;------&apos;    &apos;--------------------------&apos;    &apos;-&apos;    &apos;-------------------&apos;    &apos;-----&apos;</span><br><span class="line"> &apos;           &apos;                               &apos;      &apos;                        &apos;</span><br><span class="line"> &apos;           &apos; - type constraints            &apos;      &apos; - argument types       &apos; - return type</span><br><span class="line"> &apos;                                           &apos;</span><br><span class="line"> &apos;- method name                              &apos; - method target type</span><br></pre></td></tr></table></figure>
<p>[^1]: 更多相关信息，请参阅 Sanctuary 文档中的 <a href="https://sanctuary.js.org/#types" target="_blank" rel="noopener">Types</a> 部分。</p>
<h2 id="qian-zhui-fang-fa-ming">前缀方法名</h2>
<p>为了使数据类型与 Fantasy Land 兼容，其值必须具有某些属性。这些属性都以 <code>fantasy-land/</code> 为前缀。例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  MyType#fantasy-land/map :: MyType a ~&gt; (a -&gt; b) -&gt; MyType b</span></span><br><span class="line">MyType.prototype[<span class="string">'fantasy-land/map'</span>] = ...</span><br></pre></td></tr></table></figure>
<p>在本文中，不使用前缀的名称，只是为了减少干扰。</p>
<p>为了方便起见，你可以使用 <code>fantasy-land</code> 包：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fl = <span class="built_in">require</span>(<span class="string">'fantasy-land'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">MyType.prototype[fl.map] = ...</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> foo = bar[fl.map](<span class="function"><span class="params">x</span> =&gt;</span> x + <span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<h2 id="lei-xing-biao-shi-java-script-zhong-de-gou-zao-han-shu">类型表示 (JavaScript 中的构造函数？)</h2>
<p>某些行为是从类型成员的角度定义的。而另外一些行为不需要类型成员。因此，某些代数需要一个类型来提供值层面上的表示（具有某些属性）。例如，Identity 类型可以提供 <code>Id</code> 作为其类型表示：<code>Id :: TypeRep Identity</code>。</p>
<p>如果一个类型提供了类型表示，那么这个类型的每个成员都必须有一个指向该类型表示的 <code>contructor</code> 属性。</p>
<h2 id="dai-shu">代数</h2>
<h3 id="setoid">Setoid</h3>
<ol>
<li><code>a.equals(a) === true</code> (自反性)</li>
<li><code>a.equals(b) === b.equals(a)</code> (对称性)</li>
<li>如果 <code>a.equals(b)</code> 并且 <code>b.equals(a)</code>，则 <code>a.equals(c)</code> (传递性)</li>
</ol>
<h4 id="code-equals-code-fang-fa"><code>equals</code> 方法</h4>
<figure class="highlight hs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">equals</span> :: <span class="type">Setoid</span> a =&gt; a ~&gt; a -&gt; <span class="type">Boolean</span></span><br></pre></td></tr></table></figure>
<p>具有 Setoid 的值必须提供 <code>equals</code> 方法。<code>equals</code> 方法接受一个参数：</p>
<pre><code>a.equals(b)
</code></pre>
<ol>
<li><code>b</code> 必须是相同 Setoid 的值
<ol>
<li>如果 <code>b</code> 不是相同的 Setoid，则 <code>equals</code> 的行为未指定（建议返回 <code>false</code>）。</li>
<li><code>equals</code> 必须返回一个布尔值（<code>true</code> 或 <code>false</code>）。</li>
</ol>
</li>
</ol>
<h3 id="ord">Ord</h3>
<p>实现 Ord 规范的值还必须实现 <a href="#setoid">Setoid</a> 规范。</p>
<ol>
<li><code>a.lte(b)</code> 或 <code>b.lte(a)</code> (完全性)</li>
<li>如果 <code>a.lte(b)</code> 且 <code>b.lte(a)</code>，则 <code>a.equals(b)</code> (反对称性)</li>
<li>如果 <code>a.lte(b)</code> 且 <code>b.lte(c)</code>，则 <code>a.lte(c)</code> (传递性)</li>
</ol>
<h4 id="code-lte-code-fang-fa"><code>lte</code> 方法</h4>
<figure class="highlight hs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">lte</span> :: <span class="type">Ord</span> a =&gt; a ~&gt; a -&gt; <span class="type">Boolean</span></span><br></pre></td></tr></table></figure>
<p>具有 Ord 的值必须提供 <code>lte</code> 方法。<code>lte</code> 方法接受一个参数：</p>
<pre><code>`a.lte(b)`
</code></pre>
<ol>
<li><code>b</code> 必须是相同 Ord 的值。
<ol>
<li>如果 <code>b</code> 不是相同的 Ord，则 <code>lte</code> 的行为未指定 (建议返回 <code>false</code>)。</li>
</ol>
</li>
<li><code>lte</code> 必须返回布尔值（<code>true</code> 或 <code>false</code>）。</li>
</ol>
<h3 id="semigroupoid">Semigroupoid</h3>
<ol>
<li><code>a.compose(b).compose(c) === a.compose(b.compose(c))</code> (结合性)</li>
</ol>
<h4 id="code-compose-code-fang-fa"><code>compose</code> 方法</h4>
<figure class="highlight hs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">compose</span> :: <span class="type">Semigroupoid</span> c =&gt; c i j ~&gt; c j k -&gt; c i k</span><br></pre></td></tr></table></figure>
<p>具有 Semigoupoid 的值必须提供 <code>compose</code> 组合方法。<code>compose</code> 方法接受一个参数：</p>
<pre><code>a.compose(b)
</code></pre>
<ol>
<li><code>b</code> 必须返回相同 Semigroupoid 规范。
<ol>
<li>如果 <code>b</code> 不是相同的 Semigroupoid，compose 的行为未指定。</li>
</ol>
</li>
<li><code>compose</code> 必须返回相同 Semigroupoid 的值。</li>
</ol>
<h3 id="category">Category</h3>
<p>实现范畴规范的值还必须实现<a href="#semigroupoid">半群</a>规范。</p>
<ol>
<li><code>a.compose(C.id())</code> 等价于 <code>a</code> (右同一性)</li>
<li><code>C.id().compose(a)</code> 等价于 <code>a</code> (左同一性)</li>
</ol>
<h4 id="code-id-code-fang-fa"><code>id</code> 方法</h4>
<figure class="highlight hs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">id</span> :: <span class="type">Category</span> c =&gt; () -&gt; c a a</span><br></pre></td></tr></table></figure>
<p>具有范畴的值必须在其<a href="#type-representatives">类型表示</a>中提供一个 <code>id</code> 函数。</p>
<pre><code>C.id()
</code></pre>
<p>给定值 <code>c</code>，可以通过 <code>contructor</code> 属性来访问其类型表示：</p>
<pre><code>c.constructgor.id()
</code></pre>
<ol>
<li><code>id</code> 必须返回相同范畴的值。</li>
</ol>
<h3 id="semigroup">Semigroup</h3>
<ol>
<li><code>a.concat(b).concat(c)</code> 等价于 <code>a.concat(b.concat(c))</code> （结合性）</li>
</ol>
<h4 id="code-concat-code-fang-fa"><code>concat</code> 方法</h4>
<figure class="highlight hs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">concat</span> :: <span class="type">Semigroup</span> a =&gt; a ~&gt; a -&gt; a</span><br></pre></td></tr></table></figure>
<p>具有 Semigroup 的值必须提供 <code>concat</code> 方法。<code>concat</code> 方法接受一个参数：</p>
<pre><code>s.concat(b)
</code></pre>
<ol>
<li><code>b</code> 必须是相同 Semigroup 的值
<ol>
<li>如果 <code>b</code> 不是相同的 Semigroup，则 <code>concat</code> 的行为未指定。</li>
</ol>
</li>
<li><code>concat</code> 必须返回相同 Semigroup 的值。</li>
</ol>
<h3 id="monoid">Monoid</h3>
<p>实现 Monoid 规范的值还必须实现 <a href="#semigroup">Semigroup</a> 规范</p>
<ol>
<li><code>m.concat(M.empty())</code> 等价于 <code>m</code> (右结合性)</li>
<li><code>M.empty().concat(m)</code> 等价于 <code>m</code> (左结合性)</li>
</ol>
<h4 id="code-empty-code-fang-fa"><code>empty</code> 方法</h4>
<figure class="highlight hs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">empty</span> :: <span class="type">Monoid</span> m =&gt; () -&gt; m</span><br></pre></td></tr></table></figure>
<p>具有 Monoid 的值必须在其类型表示上提供 <code>empty</code> 方法：</p>
<pre><code>M.empty()
</code></pre>
<p>给定值<code> </code>m，可以通过 <code>constructor</code> 属性来访问其类型表示：</p>
<pre><code>m.constructor.empty()
</code></pre>
<ol>
<li><code>empty</code> 必须返回相同 Monoid 的值。</li>
</ol>
<h3 id="group">Group</h3>
<p>实现 Group 规范的值还必须实现 <a href="#monoid">Monoid</a> 规范。</p>
<ol>
<li><code>g.concat(g.invert())</code> 等价于 <code>g.constructor.empty()</code> (右反转性??)</li>
<li><code>g.invert().concat(g)</code> 等价于 <code>g.constructor.empty()</code> (左翻转性??)</li>
</ol>
<h4 id="code-invert-code-fang-fa"><code>invert</code> 方法</h4>
<figure class="highlight hs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">invert</span> :: <span class="type">Group</span> g =&gt; g ~&gt; () -&gt; g</span><br></pre></td></tr></table></figure>
<p>具有 Semigroup 的值必须提供 <code>invert</code> 方法。<code>invert</code> 方法接受零个参数：</p>
<pre><code>g.invert()
</code></pre>
<ol>
<li><code>invert</code> 必须返回相同 Group 的值。</li>
</ol>
<h3 id="filterable">Filterable</h3>
<ol>
<li><code>v.filter(x =&gt; p(x) &amp;&amp; q(x))</code> 等价于 <code>v.filter(p).filter(q)</code> (分配性)</li>
<li><code>v.filter(x =&gt; true)</code> 等价于 <code>v</code> (同一性)</li>
<li><code>v.filter(x -&gt; false)</code> 等价于 <code>w.filter(x =&gt; false)</code>，如果 <code>v</code> 和 <code>w</code> 具有相同的 Filterable 值 (湮灭??)</li>
</ol>
<h4 id="code-filter-code-fang-fa"><code>filter</code> 方法</h4>
<figure class="highlight hs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">filter</span> :: <span class="type">Filterable</span> f =&gt; f a ~&gt; (a -&gt; <span class="type">Boolean</span>) -&gt; f a</span><br></pre></td></tr></table></figure>
<p>具有 Filterable 的值必须提供 <code>filter</code> 方法。<code>filter</code> 方法接受一个参数：</p>
<pre><code>v.filter(p)
</code></pre>
<ol>
<li>
<p><code>p</code> 必须是一个函数。</p>
<ol>
<li>如果 <code>p</code> 不是函数，则 <code>filter</code> 的行为未指定。</li>
<li><code>p</code> 必须返回 <code>ture</code> 或 <code>false</code>。如果返回任何其它值，<code>filter</code> 的行为未指定。</li>
</ol>
</li>
<li>
<p><code>filter</code> 必须返回相同 Filterable 的值。</p>
</li>
</ol>
<h3 id="functor">Functor</h3>
<ol>
<li><code>u.map(a =&gt; a)</code> 等价于 <code>u</code> (同一性)</li>
<li><code>u.map(x =&gt; f(g(x)))</code> 等价于 <code>u.map(g).map(f)</code> (组合性)</li>
</ol>
<h4 id="code-map-code-fang-fa"><code>map</code> 方法</h4>
<figure class="highlight hs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">map</span> :: <span class="type">Functor</span> f =&gt; f a ~&gt; (a -&gt; b) -&gt; f b</span><br></pre></td></tr></table></figure>
<p>具有 Functor 的值必须提供 <code>map</code> 方法。<code>map</code> 方法接受一个参数：</p>
<pre><code>u.map(f)
</code></pre>
<ol>
<li>
<p><code>f</code> 必须是一个函数，</p>
<ol>
<li>如果 <code>f</code> 不是函数，则 <code>map</code> 的行为未指定。</li>
<li><code>f</code> 可以返回任何值。</li>
<li><code>f</code> 返回值的任何部分都不应该被检查(??)。</li>
</ol>
</li>
<li>
<p><code>map</code> 必须返回相同 Functor 的值。</p>
</li>
</ol>
<h3 id="contravariant">Contravariant</h3>
<ol>
<li><code>u.contramap(a =&gt; a)</code> 等价于 <code>u</code> (同一性)</li>
<li><code>u.contramap(x =&gt; f(g(x)))</code> 等价于 <code>u.contramap(f).contramap(g)</code> (组合性)</li>
</ol>
<h4 id="code-contramap-code-fang-fa"><code>contramap</code> 方法</h4>
<figure class="highlight hs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">contramap</span> :: <span class="type">Contravariant</span> f =&gt; f a ~&gt; (b -&gt; a) -&gt; f b</span><br></pre></td></tr></table></figure>
<p>具有 Contravariant 的值必须提供 <code>contramap</code> 方法。<code>contramap</code> 方法接受一个参数：</p>
<pre><code>u.contramap(f)
</code></pre>
<ol>
<li><code>f</code> 必须是一个函数，
<ol>
<li>如果 <code>f</code> 不是函数，则 <code>contramap</code> 的行为未指定。</li>
<li><code>f</code> 可以返回任何值。</li>
<li><code>f</code> 返回值的任何部分都不应该被检查(??)。</li>
</ol>
</li>
<li><code>contramap</code> 必须返回相同 Contravariant 的值。</li>
</ol>
<h3 id="apply">Apply</h3>
<p>实现 Apply 规范的值还必须实现 <a href="#functor">Functor</a> 规范。</p>
<ol>
<li><code>v.ap(u.ap(a.map(f =&gt; g =&gt; x =&gt; f(g(x)))))</code> 等价于 <code>v.ap(u).ap(a)</code> (组合型)，推导过程??</li>
</ol>
<h4 id="code-ap-code-fang-fa"><code>ap</code> 方法</h4>
<figure class="highlight hs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">ap</span> :: <span class="type">Apply</span> f =&gt; f a ~&gt; f (a -&gt; b) -&gt; f b</span><br></pre></td></tr></table></figure>
<p>具有 Apply 的值必须提供 <code>ap</code> 方法。<code>ap</code> 方法接受一个参数：</p>
<pre><code>a.ap(b)
</code></pre>
<ol>
<li><code>b</code> 必须是一个函数的 Apply
<ol>
<li>如果 <code>b</code> 不代表函数，则 <code>ap</code> 的行为未指定。</li>
<li><code>b</code> 必须与 a 具有相同的 Apply。</li>
</ol>
</li>
<li><code>a</code> 可以是任意值的 Apply。(??)</li>
<li><code>ap</code> 必须能将 Apply <code>b</code> 内的函数应用于 Apply <code>a</code> 的值上
<ol>
<li>函数返回值的任何部分都不应该被检查。</li>
</ol>
</li>
<li>由 <code>ap</code> 返回的 <code>Apply</code> 必须与 <code>a</code> 和 <code>b</code> 的相同。</li>
</ol>
<h3 id="applicative">Applicative</h3>
<p>实现 Applicative 规范的值还必须实现 <a href="#apply">Apply</a> 规范。</p>
<ol>
<li><code>v.ap(A.of(x =&gt; x))</code> 等价于 <code>v</code> (同一性)</li>
<li><code>A.of(x).ap(A.of(f))</code> 等价于 <code>A.of(f(x))</code> (同态性, homomorphism)</li>
<li><code>A.of(y).ap(u)</code> 等价于 <code>u.ap(A.of(f =&gt; f(y)))</code> (交换性)</li>
</ol>
<h4 id="code-of-code-fang-fa"><code>of</code> 方法</h4>
<figure class="highlight hs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">of</span> :: <span class="type">Applicative</span> f =&gt; a -&gt; f a</span><br></pre></td></tr></table></figure>
<p>具有 Applicative 的值必须在其类型表示中提供 <code>of</code> 函数。<code>of</code> 函数接受一个参数：</p>
<pre><code>F.of(a)
</code></pre>
<p>给定值 <code>f</code>，可以通过 <code>contructor</code> 属性访问其类型表示：</p>
<pre><code>f.contructor.of(a)
</code></pre>
<ol>
<li><code>of</code> 必须提供相同的 Applicative
<ol>
<li>a 的任何部分都不应该被检查</li>
</ol>
</li>
</ol>
<h3 id="alt">Alt</h3>
<p>实现 Alt 规范的值还必须实现 <a href="#functor">Functor</a> 规范。</p>
<ol>
<li><code>a.alt(b).alt(c)</code> 等价于 <code>a.alt(b.alt(c))</code> (结合性)</li>
<li><code>a.alt(b).map(f)</code> 等价于 <code>a.map(f).alt(b.map(f))</code> (分配性) (看起来像乘法，有什么实际用途呢？)</li>
</ol>
<h4 id="code-alt-code-fang-fa"><code>alt</code> 方法</h4>
<figure class="highlight hs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">alt</span> :: <span class="type">Alt</span> f =&gt; f a ~&gt; f a -&gt; f a</span><br></pre></td></tr></table></figure>
<p>具有 Alt 的值必须提供 <code>alt</code> 方法。<code>alt</code> 方法接受一个参数：</p>
<pre><code>a.alt(b)
</code></pre>
<ol>
<li><code>b</code> 必须是相同 Alt 的值
<ol>
<li>如果 <code>b</code> 不是相同的 Alt，则 <code>alt</code> 的行为未指定。</li>
<li><code>a</code> 和 <code>b</code> 可以包含相同类型的任何值。</li>
<li><code>a</code> 和 <code>b</code> 包含值的任何部分都不应该被检查。</li>
</ol>
</li>
<li><code>alt</code> 必须返回相同 Alt 的值。</li>
</ol>
<h3 id="plus">Plus</h3>
<p>实现 Plus 规范的值还必须实现 <a href="#alt">Alt</a> 规范。</p>
<ol>
<li><code>x.alt(A.zero())</code> 等价于 <code>x</code> (右同一性)</li>
<li><code>A.zero().alt(x)</code> 等价于 <code>x</code> (左同一性)</li>
<li><code>A.zero().map(f)</code> 等价于 <code>A.zero()</code> (湮灭??)</li>
</ol>
<h4 id="code-zero-code-fang-fa"><code>zero</code> 方法</h4>
<figure class="highlight hs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">zero</span> :: <span class="type">Plus</span> f =&gt; () -&gt; f a</span><br></pre></td></tr></table></figure>
<p>具有 Plus 的值必须在其类型表示中提供 <code>zero</code> 函数：</p>
<pre><code>A.zero()
</code></pre>
<p>给定值 <code>x</code>，可以通过 <code>contructor</code> 属性访问其类型表示：</p>
<pre><code>x.contructor.zero()
</code></pre>
<p><code>zero</code> 必须返回相同 Plus 的值。</p>
<h3 id="alternative">Alternative</h3>
<p>实现 Alternative 规范的值还必须实现 <a href="#applicative">Applicative</a> 和 <a href="#plus">Plus</a> 规范。</p>
<ol>
<li><code>x.ap(f.alt(g))</code> 等价于 <code>x.ap(f).alt(x.ap(g))</code> (分配性)</li>
<li><code>x.ap(A.zero())</code> 等价于 <code>A.zero()</code> (湮灭)</li>
</ol>
<h3 id="foldable">Foldable</h3>
<p><code>u.reduce</code> 等价于 <code>u.reduce((acc, x) =&gt; acc.concat([x]), []).reduce</code></p>
<h4 id="code-reduce-code-fang-fa"><code>reduce</code> 方法</h4>
<figure class="highlight hs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">reduce</span> :: <span class="type">Foldable</span> f =&gt; f a ~&gt; ((b, a) -&gt; b, b) -&gt; b</span><br></pre></td></tr></table></figure>
<p>具有 Foldable 的值必须在其类型表示中提供 <code>reduce</code> 函数。<code>reduce</code> 函数接受两个参数：</p>
<pre><code>u.reduce(f, x)
</code></pre>
<ol>
<li><code>f</code> 必须是一个二元函数
<ol>
<li>如果 <code>f</code> 不是函数，则 <code>reduce</code> 的行为未指定。</li>
<li><code>f</code> 的第一个参数类型必须与 <code>x</code> 的相同。</li>
<li><code>f</code> 的返回值类型必须与 <code>x</code> 的相同。</li>
<li><code>f</code> 返回值的任何部分都不应该被检查。</li>
</ol>
</li>
<li><code>x</code> 是归约的初始累积值
<ol>
<li><code>x</code> 的任何部分都不应该被检查</li>
</ol>
</li>
</ol>
<h3 id="traversable">Traversable</h3>
<p>实现 Traversable 规范的值还必须实现 <a href="#functor">Functor</a> 和 <a href="#foldable">Foldable</a> 规范。</p>
<ol>
<li>对于任意 <code>t</code>，<code>t(u.traverse(F, x =&gt; x))</code> 等价于 <code>u.traverse(G, t)</code> ，因为 <code>t(a).map(f)</code> 等价于 <code>t(a.map(f))</code> (自然性)</li>
<li>对于任意 Applicative <code>F</code>，<code>u.traverse(F, F.of)</code> 等价于 <code>F.of(u)</code> (同一性)</li>
<li><code>u.traverse(Compose, x =&gt; new Compose(x))</code> 等价于 <code>new Compose(u.traverse(F, x =&gt; x).map(x =&gt; x.traverse(G, x =&gt; x)))</code>，对下面定义的 <code>Compose</code> 和 任意 Applicatives <code>F</code> 和 <code>G</code> 都适用 (组合性)</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Compose = <span class="function"><span class="keyword">function</span>(<span class="params">c</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.c = c;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Compose.of = <span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> Compose(F.of(G.of(x)));</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Compose.prototype.ap = <span class="function"><span class="keyword">function</span>(<span class="params">f</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> Compose(<span class="keyword">this</span>.c.ap(f.c.map(<span class="function"><span class="params">u</span> =&gt;</span> <span class="function"><span class="params">y</span> =&gt;</span> y.ap(u))))</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Compose.prototype.map = <span class="function"><span class="keyword">function</span>(<span class="params">f</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> Compose(<span class="keyword">this</span>.c.map(<span class="function"><span class="params">y</span> =&gt;</span> y.map(f)));</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="code-traverse-code-fang-fa"><code>traverse</code> 方法</h4>
<figure class="highlight hs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">traverse</span> :: <span class="type">Applicative</span> f, <span class="type">Traversable</span> t =&gt; t a ~&gt; (<span class="type">TypeRep</span> f, a -&gt; f b) -&gt; f (t b)</span><br></pre></td></tr></table></figure>
<p>具有 Traversable 的值必须提供 <code>traverse</code> 函数。<code>traverse</code> 函数接受两个参数：</p>
<pre><code>u.traverse(A, f)
</code></pre>
<ol>
<li><code>A</code> 必须是一个 Applicative 的类型表示。</li>
<li><code>f</code> 必须是一个返回值的函数
<ol>
<li>如果 <code>f</code> 不是函数，则 <code>traverse</code> 的行为未指定。</li>
<li><code>f</code> 必须返回类型表示为 <code>A</code> 的值。</li>
</ol>
</li>
<li><code>traverse</code> 必须返回类型表示为 <code>A</code> 的值。</li>
</ol>
<h3 id="chain">Chain</h3>
<p>实现 Chain 规范的值还必须实现 <a href="#apply">Apply</a> 规范。</p>
<ol>
<li><code>m.chain(f).chain(g)</code> 等价于 <code>m.chain(x =&gt; f(x).chain(g))</code> (结合性)</li>
</ol>
<h4 id="code-chain-code-fang-fa"><code>chain</code> 方法</h4>
<figure class="highlight hs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">chain</span> :: <span class="type">Chain</span> m =&gt; m a ~&gt; (a -&gt; m b) -&gt; m b</span><br></pre></td></tr></table></figure>
<p>具有 Chain 的值必须提供 <code>chain</code> 函数。<code>chain</code> 函数接受一个参数：</p>
<pre><code>m.chain(f)
</code></pre>
<ol>
<li><code>f</code> 必须是一个返回值的函数
<ol>
<li>如果 <code>f</code> 不是函数，则 <code>chain</code> 的行为未指定。</li>
<li><code>f</code> 必须返回相同 Chain 的值。</li>
</ol>
</li>
<li><code>chain</code> 必须返回相同 Chain 的值。</li>
</ol>
<h3 id="chain-rec">ChainRec</h3>
<p>实现 ChainRec 规范的值还必须实现 <a href="#chain">Chain</a> 规范。</p>
<ol>
<li><code>M.chainRec((next, done, v) =&gt; p(v) ? d(v).map(done) : n(v).map(next), i)</code> 等价于 <code>function step(v) { return p(v) ? d(v) : n(v).chain(step); }(i)</code> (等价性)</li>
<li><code>M.chainRec(f, i)</code> 栈的用量必须是 <code>f</code> 自身栈用量的常数倍。</li>
</ol>
<h4 id="code-chain-rec-code-fang-fa"><code>chainRec</code> 方法</h4>
<figure class="highlight hs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">chainRec</span> :: <span class="type">ChainRec</span> m =&gt; ((a -&gt; c), b -&gt; c, a) -&gt; m b</span><br></pre></td></tr></table></figure>
<p>具有 ChainRec 的值必须在其类型表示中提供 <code>chainRec</code> 函数。<code>chainRec</code> 函数接受两个参数：</p>
<pre><code>M.chainRec(f, i)
</code></pre>
<p>给定值 <code>m</code>，可以通过 <code>contructor</code> 属性访问其类型表示：</p>
<pre><code>m.constructor.chainRec(f, i)
</code></pre>
<ol>
<li><code>f</code> 必须是一个返回值的函数
<ol>
<li>如果 <code>f</code> 不是函数，则 <code>chainRec</code> 的行为未指定。</li>
<li><code>f</code> 接受三个参数 <code>next</code>，<code>done</code>，<code>value</code>
<ol>
<li><code>next</code> 是一个函数，其接受一个与 i 类型相同的参数，可以返回任意值</li>
<li><code>done</code> 也是一个函数，其接受一个参数，并返回一个与 <code>next</code> 返回值类型相同的值</li>
<li><code>value</code> 是一个与 i 类型相同的值。</li>
</ol>
</li>
<li><code>f</code> 必须返回一个相同 ChainRec 的值，其中包含的是从 <code>done</code> 或 <code>next</code> 返回的值。</li>
</ol>
</li>
<li><code>chainRec</code> 必须返回一个相同 ChainRec 的值，其中包含的值的类型与 <code>done</code> 的参数类型相同。</li>
</ol>
<h3 id="monad">Monad</h3>
<p>实现 Monad 规范的值还必须实现 <a href="#applicative">Applicative</a> 和 <a href="#chain">Chain</a> 规范。</p>
<ol>
<li><code>M.of(a).chain(f)</code> 等价于 <code>f(a)</code> (左同一性)</li>
<li><code>m.chain(M.of)</code> 等价于 <code>m</code> (右同一性)</li>
</ol>
<h3 id="extend">Extend</h3>
<p>实现 Extend 规范的值还必须实现 <a href="#functor">Functor</a> 规范。</p>
<ol>
<li><code>w.extend(g).extend(f)</code> 等价于 <code>w.extend(\_w =&gt; f(\_w.extend(g)))</code></li>
</ol>
<p><code>extend</code> 方法</p>
<figure class="highlight hs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">extend</span> :: <span class="type">Extend</span> w =&gt; w a ~&gt; (w a -&gt; b) -&gt; w b</span><br></pre></td></tr></table></figure>
<p>具有 Extend 的值必须提供 <code>extend</code> 函数。<code>extend</code> 函数接受一个参数：</p>
<pre><code>w.extend(f)
</code></pre>
<ol>
<li><code>f</code> 必须是一个返回值的函数，
<ol>
<li>如果 <code>f</code> 不是函数，则 extend 的行为未指定。</li>
<li><code>f</code> 必须返回一个 <code>v</code> 类型的值，其中 <code>v</code> 是 <code>w</code> 中包含的某个变量 <code>v</code> (??)</li>
<li><code>f</code> 返回值的任何部分都不应该被检查。</li>
</ol>
</li>
<li><code>extend</code> 必须返回相同 Extend 的值。</li>
</ol>
<h3 id="comonad">Comonad</h3>
<p>实现 Comonad 规范的值还必须实现 <a href="#extend">Extend</a> 规范。</p>
<ol>
<li><code>w.extend(_w =&gt; _w.extract())</code> 等价于 <code>w</code> (左同一性)</li>
<li><code>w.extend(f).extract()</code> 等价于 <code>f(w)</code> (右同一性)</li>
</ol>
<h4 id="code-extract-code-fang-fa"><code>extract</code> 方法</h4>
<p>具有 Comonad 的值必须提供 <code>extract</code> 函数。<code>extract</code> 函数接受零个参数：</p>
<pre><code>w.extract()
</code></pre>
<ol>
<li><code>extract</code> 必须返回一个 <code>v</code> 类型的值，其中 <code>v</code> 是 <code>w</code> 中包含的某个变量 <code>v</code> (??)
<ol>
<li><code>v</code> 必须与在 <code>extend</code> 中的 <code>f</code> 返回的类型相同。</li>
</ol>
</li>
</ol>
<h3 id="bifunctor">Bifunctor</h3>
<p>实现 Bifunctor 规范的值还必须实现 <a href="#functor">Functor</a> 规范。</p>
<ol>
<li><code>p.bimap(a =&gt; a, b =&gt; b)</code> 等价于 <code>p</code> (同一性)</li>
<li><code>p.bimap(a =&gt; f(g(a)), b =&gt; h(i(b)))</code> 等价于 <code>p.bimap(g, i).bimap(f, h)</code> (组合性)</li>
</ol>
<h3 id="code-bimap-code-fang-fa"><code>bimap</code> 方法</h3>
<figure class="highlight hs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">bimap</span> :: <span class="type">Bifunctor</span> f =&gt; f a c ~&gt; (a -&gt; b, c -&gt; d) -&gt; f b d</span><br></pre></td></tr></table></figure>
<p>具有 Bifunctor 的值必须提供 <code>bimap</code> 函数。<code>bimap</code> 函数接受两个参数：</p>
<pre><code>c.bimap(f, g)
</code></pre>
<ol>
<li><code>f</code> 必须是一个返回值的函数，
<ol>
<li>如果 <code>f</code> 不是函数，则 <code>bimap</code> 的行为未指定。</li>
<li><code>f</code> 可以返回任意值</li>
<li><code>f</code> 返回值的任何部分都不应该被检查。</li>
</ol>
</li>
<li><code>g</code> 必须是一个返回值的函数，
<ol>
<li>如果 <code>g</code> 不是函数，则 <code>bimap</code> 的行为未指定。</li>
<li><code>g</code> 可以返回任意值<br>
3.<code>g</code> 返回值的任何部分都不应该被检查。</li>
</ol>
</li>
<li><code>bimap</code> 必须返回相同 Bifunctor 的值。</li>
</ol>
<h3 id="profunctor">Profunctor</h3>
<p>实现 Profunctor 规范的值还必须实现 <a href="#functor">Functor</a> 规范。</p>
<ol>
<li><code>p.promap(a =&gt; a, b =&gt; b)</code> 等价于 <code>p</code> (同一性)</li>
<li><code>p.promap(a =&gt; f(g(a)), b =&gt; h(i(b)))</code> 等价于 <code>p.promap(f, i).promap(g, h)</code> (组合性)</li>
</ol>
<h4 id="code-promap-code-fang-fa"><code>promap</code> 方法</h4>
<figure class="highlight hs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">promap</span> :: <span class="type">Profunctor</span> p =&gt; p b c ~&gt; (a -&gt; b, c -&gt; d) -&gt; p a d</span><br></pre></td></tr></table></figure>
<ol>
<li><code>f</code> 必须是一个返回值的函数，
<ol>
<li>如果 <code>f</code> 不是函数，则 <code>promap</code> 的行为未指定。</li>
<li><code>f</code> 可以返回任意值</li>
<li><code>f</code> 返回值的任何部分都不应该被检查。</li>
</ol>
</li>
<li><code>g</code> 必须是一个返回值的函数，
<ol>
<li>如果 <code>g</code> 不是函数，则 <code>promap</code> 的行为未指定。</li>
<li><code>g</code> 可以返回任意值</li>
<li><code>g</code> 返回值的任何部分都不应该被检查。</li>
</ol>
</li>
<li><code>promap</code> 必须返回相同 Profunctor 的值。</li>
</ol>
<h2 id="tui-dao">推导</h2>
<p>当创建满足多个代数的数据类型是，作者可以选择实现某些方法，然后推导出剩余的方法。推导：</p>
<ul>
<li>
<p><a href="#code-equals-code-fang-fa"><code>equals</code></a> 可以由 <a href="#code-lte-code-fang-fa"><code>lte</code></a> 推导出：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>(<span class="params">other</span>) </span>&#123; retrun <span class="keyword">this</span>.lte(other) &amp;&amp; other.lte(<span class="keyword">this</span>) &#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><a href="#code-map-code-fang-fa"><code>map</code></a> 可以由 <a href="#code-ap-code-fang-fa"><code>ap</code></a> 和 <a href="#code-of-code-fang-fa"><code>of</code></a> 推导出：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>(<span class="params">f</span>) </span>&#123; <span class="keyword">return</span> <span class="keyword">this</span>.ap(<span class="keyword">this</span>.of(f))&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><a href="#code-map-code-fang-fa"><code>map</code></a> 可以由 <a href="#code-chain-code-fang-fa"><code>chain</code></a> 和 <a href="#code-of-code-fang-fa"><code>of</code></a> 推导出：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>(<span class="params">f</span>) </span>&#123; <span class="keyword">return</span> <span class="keyword">this</span>.chain(<span class="function"><span class="params">a</span> =&gt;</span> <span class="keyword">this</span>.of(f(a))); &#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><a href="#code-map-code-fang-fa"><code>map</code></a> 可以由 <a href="#code-bimap-code-fang-fa"><code>bimap</code></a> 推导出 (??)：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>(<span class="params">f</span>) </span>&#123; <span class="keyword">return</span> <span class="keyword">this</span>.bimap(<span class="function"><span class="params">a</span> =&gt;</span> a, f); &#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><a href="#code-map-code-fang-fa"><code>map</code></a> 可以由 <a href="#code-promap-code-fang-fa"><code>promap</code></a> 推导出：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>(<span class="params">f</span>) </span>&#123; <span class="keyword">return</span> <span class="keyword">this</span>.promap(<span class="function"><span class="params">a</span> =&gt;</span> a, f); &#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><a href="#code-ap-code-fang-fa"><code>ap</code></a> 可以由 <a href="#code-chain-code-fang-fa"><code>chain</code></a> 推导出：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>(<span class="params">m</span>) </span>&#123; <span class="keyword">return</span> m.chain(<span class="function"><span class="params">f</span> =&gt;</span> <span class="keyword">this</span>.map(f)); &#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><a href="#code-reduce-code-fang-fa"><code>reduce</code></a> 可以由下列推导出：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>(<span class="params">f, acc</span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">Const</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.value = value;</span><br><span class="line">  &#125;</span><br><span class="line">  Const.of = <span class="function"><span class="keyword">function</span>(<span class="params">\_</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Const(acc);</span><br><span class="line">  &#125;</span><br><span class="line">  Const.prototype.map = <span class="function"><span class="keyword">function</span>(<span class="params">\_</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  Const.prototype.ap = <span class="function"><span class="keyword">function</span>(<span class="params">b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Const(f(b.value, <span class="keyword">this</span>.value));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.traverse(<span class="function"><span class="params">x</span> =&gt;</span> <span class="keyword">new</span> Const(x), Const.of).value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><a href="#code-map-code-fang-fa"><code>map</code></a> 的推导如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>(<span class="params">f</span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">Id</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.value = value;</span><br><span class="line">  &#125;</span><br><span class="line">  Id.of = <span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Id(x);</span><br><span class="line">  &#125;</span><br><span class="line">  Id.prototype.map = <span class="function"><span class="keyword">function</span>(<span class="params">f</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Id(f(b.value));</span><br><span class="line">  &#125;</span><br><span class="line">  Id.prototype.ap = <span class="function"><span class="keyword">function</span>(<span class="params">b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Id(<span class="keyword">this</span>.value(b.value));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.traverse(<span class="function"><span class="params">x</span> =&gt;</span> Id.of(f(x)), Id.of).value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><a href="#code-filter-code-fang-fa"><code>filter</code></a> 可以由 <a href="#code-of-code-fang-fa"><code>of</code></a>，<a href="#code-chain-code-fang-fa"><code>chain</code></a> 和 <a href="#code-zero-code-fang-fa"><code>zero</code></a> 推导出：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>(<span class="params">pred</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> F = <span class="keyword">this</span>.constructor;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.chain(<span class="function"><span class="params">x</span> =&gt;</span> pred(x) ? F.of(x) : F.zero());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><a href="#code-filter-code-fang-fa"><code>filter</code></a> 还可以由 <a href="#code-concat-code-fang-fa"><code>concat</code></a>，<a href="#code-of-code-fang-fa"><code>of</code></a>，<a href="#code-zero-code-fang-fa"><code>zero</code></a> 和 <a href="#code-reduce-code-fang-fa"><code>reduce</code></a>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>(<span class="params">pred</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> F = <span class="keyword">this</span>.constructor;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.reduce(<span class="function">(<span class="params">f, x</span>) =&gt;</span> pred(x) ? f.concat(F.of(x)) : f, F.zero());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="zhu-yi">注意</h2>
<ol>
<li>如果实现的方法和规则不止一种，应该选择一种实现，并为其他用途提供包装。</li>
<li>我们不鼓励重载特定的方法。那样会很容易造成崩溃和错误的行为。</li>
<li>建议对未指定的行为抛出异常。</li>
<li>在 <a href="https://github.com/sanctuary-js/sanctuary-identity" target="_blank" rel="noopener">sanctuary-identity</a> 中提供了一个实现了许多方法的 Id 容器。</li>
</ol>
<h2 id="bei-xuan-fang-an">备选方案</h2>
<p>此外，还存在一个 Static Land 规范，其思想与 Fantasy Land 完全相同，但是是基于静态方法而非实例方法。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://adispring.github.io/2017/12/16/The-Philosophy-of-Ramda/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="wangzengdi">
      <meta itemprop="description" content="FE@Meituan.com">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="wangzengdi's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2017/12/16/The-Philosophy-of-Ramda/" class="post-title-link" itemprop="url">Ramda 的哲学</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2017-12-16 21:39:27" itemprop="dateCreated datePublished" datetime="2017-12-16T21:39:27+00:00">2017-12-16</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-07-25 10:51:10" itemprop="dateModified" datetime="2021-07-25T10:51:10+00:00">2021-07-25</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="mu-biao">目标</h1>
<p>我们编写 Ramda 的目的是，用比原生 JavaScript 更好的方式进行编程。给定数据如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// `projects` 是一个以下形式的对象类型的数组</span></span><br><span class="line"><span class="comment">//     &#123;codename: 'atlas', due: '2013-09-30', budget: 300000, </span></span><br><span class="line"><span class="comment">//      completed: '2013-10-15', cost: 325000&#125;,</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// `assignments` 是将工程名映射到员工名的对象类型的数组，如下所示:</span></span><br><span class="line"><span class="comment">//     &#123;codename: 'atlas', name: 'abby'&#125;,</span></span><br><span class="line"><span class="comment">//     &#123;codename: 'atlas', name: 'greg'&#125;,</span></span><br></pre></td></tr></table></figure>
<p>我们想按以下形式进行编程：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> employeesByProjectName = R.pipe(</span><br><span class="line">  R.propEq(<span class="string">'codename'</span>), </span><br><span class="line">  R.flip(R.filter)(assignments), </span><br><span class="line">  R.map(R.prop(<span class="string">'name'</span>))</span><br><span class="line">);</span><br><span class="line"><span class="keyword">var</span> onTime = R.filter(<span class="function"><span class="params">proj</span> =&gt;</span> proj.completed &lt;= proj.due);</span><br><span class="line"><span class="keyword">var</span> withinBudget = R.filter(<span class="function"><span class="params">proj</span> =&gt;</span> proj.cost &lt;= proj.budget);</span><br><span class="line"><span class="keyword">var</span> topProjects = R.converge(R.intersection, [onTime, withinBudget]);</span><br><span class="line"><span class="keyword">var</span> bonusEligible = R.pipe(</span><br><span class="line">  topProjects, </span><br><span class="line">  R.map(R.prop(<span class="string">'codename'</span>)), </span><br><span class="line">  R.map(employeesByProjectName), </span><br><span class="line">  R.flatten, </span><br><span class="line">  R.uniq</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(bonusEligible(projects));</span><br><span class="line"><span class="comment">// Live version at https://codepen.io/adispring/pen/WdQjXL?editors=0012</span></span><br><span class="line"><span class="comment">// 译者注：原文用的 ramda@0.22.1 版本比较旧了，converge 第二个之后的函数未加中括号</span></span><br><span class="line"><span class="comment">//         本文采用 ramda@0.25.0</span></span><br></pre></td></tr></table></figure>
<p>这段代码是一段 “函数式” 的 <code>pipeline</code>。它是由模块化、可组合的函数构建而成，这些函数拼接在一起形成长长的管道，然后我们可以从管道入口传入待处理的数据。上面的每个 var 变量声明都代表一个单输入单输出的函数。每个函数的输出结果在管道中继续传递下去。</p>
<p>这些函数对数据进行转换并将转换结果传给下一个函数。需要注意的是，这些函数都不会改变输入参数的值。</p>
<p>Ramda 的目标是让这种风格的编码在 JavaScript 中更容易些。这就是它的目的，我们的设计决策都是由这个目标驱动的。还有一个唯二值得关注的点：简洁（Simplicity）。我们追求的是简洁（Simple），而不是简单（容易，Easy）。如果你没有看过 Rich Hickey 的 “Simple Made Easy”，你应该花点时间看看。简洁，意味着不要将独立的功能点耦合或纠缠到一起。Ramda 努力坚持这个原则。（单一职责原则）</p>
<h1 id="zuo-you-ming">座右铭</h1>
<p>Ramda 自认为是 “一个实用的 JavaScript 函数式编程库”。什么意思呢？</p>
<p>在本文接下来的部分，我们将这句话的解释分成几部分，并在下文中分别讨论每部分在 Ramda 中的含义。</p>
<h1 id="wei-java-script-bian-cheng-ren-yuan-er-she-ji">为 JavaScript 编程人员而设计</h1>
<h2 id="you-xie-liang-ya">有些惊讶？</h2>
<p>Ramda 是为编程人员设计的库。它不是一个学术试验品。它是为一线人员构建系统而准备的，它必须能运行，并且是良好、高效地运行。</p>
<p>我们尽量描述清楚函数的作用，以确保不会因误解而发生意外。不过，我们做的一些事情可能会让很多学术同仁感到惊讶。但只要日常的（工业界）编程人员理解我们，我们就愿意冒这个风险。例如，Ramda 的 <code>is</code> 函数可以用来代替 <code>isArray</code>、<code>isNumber</code>、<code>isFunction</code> 等函数。Ramda 版本的类型判断函数接受一个构造函数和一个对象：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">is(<span class="built_in">Number</span>, <span class="number">42</span>); <span class="comment">//=&gt; true</span></span><br><span class="line">is(<span class="built_in">Function</span>, <span class="number">42</span>); <span class="comment">//=&gt; false</span></span><br><span class="line">is(<span class="built_in">Object</span>, &#123;&#125;); <span class="comment">//=&gt; true</span></span><br></pre></td></tr></table></figure>
<p>这也适用于自定义的构造函数。如果 <code>Square</code> 的原型链上包含 <code>Rectangle</code>，则可以这样做：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">is(Rectangle, <span class="keyword">new</span> Square(<span class="number">4</span>)); <span class="comment">//=&gt; true</span></span><br></pre></td></tr></table></figure>
<p>但这也可能引起学术界同仁的疑惑：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">is(<span class="built_in">Object</span>, <span class="number">42</span>); <span class="comment">//=&gt; false</span></span><br></pre></td></tr></table></figure>
<p>现实世界的编程人员知道这是完全正确的。字符串、布尔值和数字是原生类型，但它们不是对象。然而学者们可能会坚持，认为包装过的 Number 类型继承自 Object，类比 Square/Rectangle ，也应该返回 true。当然，他们可以那么认为… 在他们自己的库里。这些函数对一线的编程人员才是最有用的。（译者注：Ramda 作者可能被学术界 Nerd 们的絮叨伤害过…）</p>
<h2 id="ming-ling-shi-shi-xian">命令式实现</h2>
<p>我们并没有非得以函数式的方式实现 Ramda 的函数。许多我们提出的构造，像 folds、maps、filters 只能通过递归进行函数式实现。但由于 JavaScript 并没有对递归进行优化；我们不能用优雅的递归算法来编写这些函数。相反，我们诉诸于丑陋的、命令式的 while 循环。我们来编写令人讨厌的代码，以便（Ramda）用户可以编写更优雅的代码。Ramda 的实现绝不应该被认为是如何编写函数式代码的指导。（译者注：为了效率和实用性的考虑，Ramda 底层实现其实是命令式的）</p>
<p>虽然我们从 Haskell、ML 和 LISP（及其变种的函数式部分）等函数式语言中获得很多灵感，但 Ramda 从不试图实现这些语言的任何部分。</p>
<p>Ramda 也没有试图简单地以函数式的方式重写原生 API。机械的生搬硬套没有任何意义。当我们实现 <code>map</code> 函数时，我们既不用非得遵循 Array.prototype.map 的 ECMAScript 规范，也没有囿于已有的实现。我们可以自由地为我们的库定义每个函数的功能，它是如何工作的，确切的参数顺序，它会不会更改输入参数等（永远不会！），返回什么，以及它会抛出什么类型的错误等。换句话说，API 是我们自己的。我们确实受到了函数式编程的传统的限制，但如果在 JavaScript 中使用某些东西需要做出妥协，我们可以做出任何被认为实用的选择。（译者注：总之，我们对 Ramda 有绝对的掌控权）</p>
<h1 id="zuo-wei-yi-ge-ku">作为一个库</h1>
<p>Ramda 是一个库，一个工具包，或者类比 Underscore ，是一个辅助开发工具。它不是一个决定如何构建应用程序结构的框架（如 React）。相反，它只是一组函数，旨在使之前描述的可组合函数风格的编程更容易一些。这些函数并没有决定你的工作流程。例如，你不必为了使用过滤器而传递 <code>where</code> 函数的结果。</p>
<h2 id="wei-shi-yao-bu-shi-yong">为什么不使用…</h2>
<p>Ramda 不可避免的会与 <a href="http://underscorejs.org/" target="_blank" rel="noopener">Underscore</a> 和 <a href="http://lodash.com/" target="_blank" rel="noopener">Lodash</a> 做对比；其所提供的函数在功能和函数名称会有重叠。但是，Ramda 不会成为这些库的替代品。即使有一个神奇的参数顺序调整机制，它仍然不是一个简单的替代品。Ramda 有自身的优势、专注于不同领域。请记住，如果这些库能够很容易地按我们想要的方式进行编程，那么就不需要 Ramda 了。</p>
<p>当我们开始编写该库时，主要的函数式编程库有：</p>
<ul>
<li>
<p>Oliver Steele 的 <a href="http://osteele.com/sources/javascript/functional/" target="_blank" rel="noopener">Functional Javascript</a>, 这是首次使用令人难以置信的方式，展示真的可以在 JavaScript 中用函数式的方式编程。但它也只是个玩具，用生产环境中不想要的技巧进行Hack。</p>
</li>
<li>
<p>Reg Braithwaite 的 <a href="https://github.com/raganwald/allong.es" target="_blank" rel="noopener">allong.es</a>，这本书已经出来了，并且这个鲜为人知的库已经可以用了。但这个库自称是 Underscore 或 Lodash 的伴侣，虽然做得很好，但它似乎只是一个支持这本书的最小代码集合，而不是一个完整的库。</p>
</li>
<li>
<p>Michael Fogus 的 <a href="https://github.com/fogus/lemonad" target="_blank" rel="noopener">Lemonad</a> 是一个具有前瞻性的实验品，也许是这里面最有趣的一个，它的一些函数在其他 JavaScript 库中是没有的。但它似乎只是一个 playground，基于此，该库基本上被废弃了。</p>
</li>
<li>
<p>当然还有一些大块头，比如 Jeremy Ashkenas 的 <a href="http://underscorejs.org/" target="_blank" rel="noopener">Underscore</a> 和 John-David Dalton 的 <a href="http://lodash.com/" target="_blank" rel="noopener">Lodash</a>。这些库的广泛使用，显示了大量的 JavaScript 开发人员不再害怕函数式构造。它们非常受欢迎，已经包含了许多我们想要的工具。</p>
</li>
</ul>
<p>那么为什么我们不使用 Underscore/Lodash 呢？答案很简单。对于我们想要的编程形式，它们犯了一些根本性的错误：它们传递参数的顺序是错误的。</p>
<p>这听起来很可笑，甚至无足轻重，但是对于这种编程风格来说确实 <strong>必不可少</strong>。为了构建简单可组合的函数，我们需要能正确协同工作的工具。其中最重要的是自动柯里化。为了能正确地进行柯里化，我们必须确保最经常变化的参数 – 通常是数据 – 放到最后。</p>
<p>差别很简单。假设我们有这样一个可用的函数：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> add = <span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>) </span>&#123;<span class="keyword">return</span> a + b;&#125;;</span><br></pre></td></tr></table></figure>
<p>并且我们想要一个函数，可以计算一篮子水果的总价格，例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> basket = [</span><br><span class="line">    &#123;<span class="attr">item</span>: <span class="string">'apples'</span>,  <span class="attr">per</span>: <span class="number">.95</span>, <span class="attr">count</span>: <span class="number">3</span>, <span class="attr">cost</span>: <span class="number">2.85</span>&#125;,</span><br><span class="line">    &#123;<span class="attr">item</span>: <span class="string">'peaches'</span>, <span class="attr">per</span>: <span class="number">.80</span>, <span class="attr">count</span>: <span class="number">2</span>, <span class="attr">cost</span>: <span class="number">1.60</span>&#125;,</span><br><span class="line">    &#123;<span class="attr">item</span>: <span class="string">'plums'</span>,   <span class="attr">per</span>: <span class="number">.55</span>, <span class="attr">count</span>: <span class="number">4</span>, <span class="attr">cost</span>: <span class="number">2.20</span>&#125;</span><br><span class="line">];</span><br></pre></td></tr></table></figure>
<p>我们想要这样写：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sum = reduce(add, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<p>并且这样使用：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> totalCost = compose(sum, pluck(<span class="string">'cost'</span>));</span><br></pre></td></tr></table></figure>
<p>这就是我们想要的效果。注意看 <code>sum</code> 和 <code>totalCost</code> 是如此的简洁。使用 Underscore 写一个计算总价的函数并不难，但不会如此简洁。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sum = <span class="function"><span class="keyword">function</span>(<span class="params">list</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> _.reduce(list, add, <span class="number">0</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> totalCost = <span class="function"><span class="keyword">function</span>(<span class="params">basket</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sum(_.pluck(basket, <span class="string">'cost'</span>));</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在 Lodash 中可能的实现如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sum = <span class="function"><span class="keyword">function</span>(<span class="params">list</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> _.reduce(list, add, <span class="number">0</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> getCosts = _.partialRight(_.pluck, <span class="string">'cost'</span>);</span><br><span class="line"><span class="keyword">var</span> totalCost = _.compose(sum, getCosts);</span><br></pre></td></tr></table></figure>
<p>或者跳过中间变量：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sum = <span class="function"><span class="keyword">function</span>(<span class="params">list</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> _.reduce(list, add, <span class="number">0</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> totalCost = _.compose(sum, .partialRight(_.pluck, <span class="string">'cost'</span>));</span><br></pre></td></tr></table></figure>
<p>虽然这已经非常接近我们想要的效果，但是跟 Ramda 版本的相比，还是有差距的：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sum = R.reduce(add, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">var</span> total = R.compose(sum, R.pluck(<span class="string">'cost'</span>));</span><br></pre></td></tr></table></figure>
<p>在 Ramda 中实现这种风格的秘诀非常简单：我们将函数参数放在第一位，数据参数放到最后，并且将每个函数都柯里化。</p>
<p>来看一下 <code>pluck</code>。Ramda 有一个 <code>pluck</code> 函数，它和 Underscore 及 Lodash 中的 <code>pluck</code> 函数的功能差不多。这些函数接受一个字符串属性名和一个列表；返回由列表元素的属性值组成的列表。但 Underscore 和 Lodash 要求先提供列表，Ramda 希望最后传入列表。当你加入柯里化时，区别非常明显：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">R.pluck(<span class="string">'cost'</span>); <span class="comment">//=&gt; function :: [Object] -&gt; [costs]</span></span><br></pre></td></tr></table></figure>
<p>通过简单地暂时不传列表参数给 <code>pluck</code>，我们得到一个新函数：接受一个列表，并从新提供的列表中提取 <code>cost</code> 属性值。</p>
<p>重申一下，就是这个简单的区别，将数据参数放到最后的自动柯里化函数让这两种风格变得不同：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sum = <span class="function"><span class="keyword">function</span>(<span class="params">list</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> _.reduce(list, add, <span class="number">0</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> total = <span class="function"><span class="keyword">function</span>(<span class="params">basket</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sum(_.pluck(basket, <span class="string">'cost'</span>));</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sum = R.reduce(add, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">var</span> total = R.compose(sum, R.pluck(<span class="string">'cost'</span>));</span><br></pre></td></tr></table></figure>
<p>这就是我们开始编写一个新库的原因。</p>
<h1 id="she-ji-xuan-ze">设计选择</h1>
<p>接下来的问题是我们想要一个什么类型的库。我们当然知道我们想要一个简洁而又不怪异的 API。但是，这里仍然有一个悬而未决的问题：需要怎样确定 API 的适用广度和深度。</p>
<p>API 的广度，仅仅指它想要覆盖多少不同类型的功能。有两百个函数的 API 比只有十个函数的 API 适用范围要广得多。与大多数其他库一样，我们对其广度（适用范围）没有特别的限制。我们添加有用的函数，而不用担心库的规模的增大会导致崩溃。</p>
<p>一个库的深度，可以衡量它的函数们在独立使用时，可以提供多少种的不同的方式。（关于它们如何组合，是另一个完全不同的问题）在这里，我们走向了与 Underscore 及 Lodash 完全不同的方向。因为 JavaScript 不会去检查参数的类型和数量，所以编写根据传入确切参数（参数的类型和数量）而具有多种不同行为的单个函数是相当容易的。Underscore 和 Lodash 使用这种方法让它们的函数更灵活。例如，在 Lodash 中，<code>pluck</code> 不仅可以作用在 list 上，还可以作用在 object 和 string 上。从这个意义上讲，Lodash 是一个相当有深度的 API。Ramda 试图保持相对较浅的深度，原因如下：</p>
<p>Lodash 提供的功能如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_.pluck(<span class="string">'abc'</span>, propertyName);</span><br></pre></td></tr></table></figure>
<p>其将字符串拆分成由单字母字符串组成的数组，然后返回从每个字符串中提取的指定属性形成的数组。想找个这样的合适的应用场景是非常困难的：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_.pluck(<span class="string">'abc'</span>, <span class="string">'length'</span>); <span class="comment">//=&gt; [1, 1, 1]</span></span><br></pre></td></tr></table></figure>
<p>如果你真的想要一个元素为 <code>1</code> ，且对应字符串中的每个字母的列表，下面这段代码比我的 Ramda 解法要短一些：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">map(always(<span class="number">1</span>), split(<span class="string">''</span>, <span class="string">'abc'</span>));</span><br></pre></td></tr></table></figure>
<p>但这貌似没什么用，因为唯一另外一个属性是有意义的：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_.pluck(<span class="string">'abc'</span>, <span class="string">'0'</span>); <span class="comment">//=&gt; ['a', 'b', 'c']</span></span><br></pre></td></tr></table></figure>
<p>如果 <code>pluck</code> 不存在，下面这样也是可以的：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'abc'</span>.split(<span class="string">''</span>); <span class="comment">//=&gt; ['a', 'b', 'c']</span></span><br></pre></td></tr></table></figure>
<p>所以在字符串上操作并没多大用处。之所以将其（字符串）包含进来，可能是因为所有属于 Lodash “集合” 类的函数都应该能同时适用于数组、对象和字符串；这只是一个一致性问题。（令人失望的是，Lodash 没有打算扩展到其他实际的集合中去，比如 Map 和 Set）我们已经理解了 <code>pluck</code> 是如何在数组上工作的。它涵盖的另一种类型是对象，如下所示：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> flintstones1 = &#123;</span><br><span class="line">    A: &#123;<span class="attr">name</span>: <span class="string">'fred'</span>, <span class="attr">age</span>: <span class="number">30</span>&#125;,</span><br><span class="line">    B: &#123;<span class="attr">name</span>: <span class="string">'wilma'</span>, <span class="attr">age</span>: <span class="number">28</span>&#125;,</span><br><span class="line">    C: &#123;<span class="attr">name</span>: <span class="string">'pebbles'</span>, <span class="attr">age</span>: <span class="number">2</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line">_.pluck(flintstones1, <span class="string">'age'</span>); <span class="comment">//=&gt; [30, 28, 2]</span></span><br></pre></td></tr></table></figure>
<p>可以创建一个对象，<code>flintstones2</code> ，且以下结果为 <code>true</code>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_.isEqual(flintstones1, flintstones2); <span class="comment">//=&gt; true</span></span><br></pre></td></tr></table></figure>
<p>但下面结果却为 <code>false</code>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_.pluck(flintstones1, <span class="string">'age'</span>); == _.pluck(flintstones2, <span class="string">'age'</span>); <span class="comment">//=&gt; false;</span></span><br></pre></td></tr></table></figure>
<p>下面是一种可能的情况：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> flintstones2 = &#123;</span><br><span class="line">    B: &#123;<span class="attr">name</span>: <span class="string">'wilma'</span>, <span class="attr">age</span>: <span class="number">28</span>&#125;,</span><br><span class="line">    A: &#123;<span class="attr">name</span>: <span class="string">'fred'</span>, <span class="attr">age</span>: <span class="number">30</span>&#125;,</span><br><span class="line">    C: &#123;<span class="attr">name</span>: <span class="string">'pebbles'</span>, <span class="attr">age</span>: <span class="number">2</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line">_.pluck(flintstones2, <span class="string">'age'</span>); <span class="comment">//=&gt; [28, 30, 2]</span></span><br></pre></td></tr></table></figure>
<p>问题在于，<a href="http://www.ecma-international.org/ecma-262/5.1/#sec-12.6.4" target="_blank" rel="noopener">根据规范</a>，对象 keys 的迭代顺序是依赖于实现的；通常它们按照添加到对象中的顺序进行迭代。。</p>
<p>在写本文时，我提交了一个关于这个问题的 issue。在最好的情况下，只有通过记录问题才能解决问题。但这个问题实在影响深远。如果你想统一列表和对象的行为，你将会不断遇到这个问题，除非你实现一个（非常慢的！）统一的顺序对 Object 属性进行迭代。</p>
<p>在 Ramda 中，<code>pluck</code> 只作用于列表。它接受一个属性名和一个列表，并返回一个相同长度的新列表。仅此而已。这个 API 深度很浅。（译者注：适用范围不太广）。</p>
<p>你可以将其看作特点，也可以看作是缺点。以 Lodash 的 <code>filter</code> 为例: 它接受一个数组、对象或字符串作为第一个集合（参数），然后接受一个函数、对象、字符串或者空作为它的回调，并且还需要一个对象或空作为它的 this 参数。你将一次获得 3 * 4 * 2 = 24 个函数！这要么是一个很大的问题，要么增加了从中找到一个你真正想要的方案的难度，增加了太多复杂性。决定权在于你。</p>
<p>在 Ramda 中，我们认为这种风格会增加不必要的复杂性。我们发现简单的函数签名对于维持简洁是至关重要的。如果我们需要函数既能作用于列表，又能作用于对象，我们会创建各自独立的函数（译者注：一般情况下会这样，但也有特例，比如 <code>map</code>）。如果有一个参数我们偶尔会用到，我们不会创建一个可选参数，而是创建两个函数。尽管这扩大了 API 的规模，但是它们保持了一至的浅度。</p>
<h2 id="api-de-zeng-chang">API 的增长</h2>
<p>有一个我们已经意识到的危险，一个可以用三个字母拼出来的危险：“PHP”。我们不希望我们的 API 变成一个不可持续的、功能不一致的怪物。这是真正的威胁，没有强制性的规范来确定我们应该或不应该包含什么。</p>
<p>我们一直在努力；我们不希望包含一个貌似有用的函数。</p>
<p>为了避免变成 “PHP” 风格的庞然大物，我们专注于几件事情。首先，API 为王。虽然我们想要函数实现尽可能优雅，但我们为了即使是轻微的 API 性能改进，而牺牲了大量优雅的实现。我们试图执行严格的一致性标准。例如：像 <code>somethingBy</code> 这样的 Ramda 函数，以标准的方式看，与 <code>somethingWith</code> 函数是不同的。如 <a href="https://github.com/ramda/ramda/issues/65" target="_blank" rel="noopener">issue 65</a> 所述，我们</p>
<blockquote>
<p>使用 xxBy 来表示单一属性的比较，无论是对象的自然属性还是合成属性；使用 xxWith 表示更具一般性的函数。</p>
</blockquote>
<p>一些使用这种方式的函数的例子包括max / min / sort / uniq / difference。</p>
<h1 id="han-shu-shi">函数式</h1>
<p>JavaScript 是一门多范式语言。你可以编写简单的命令式代码，面对对象的代码，或函数式代码。原始命令式的代码非常直白、简单。有很多库可以帮助你将 JavaScript 作为面向对象的语言使用。但是将 JavaScript 作为函数式语言使用的库非常少。Ramda 帮忙填补了这个空缺。</p>
<p>如前所述，我们当然不是第一个。其他库通过各种不同方式让人们可以在 JavaScript 中进行函数式编程（FP）。在我看来，将函数式世界与 JavaScript 结合最成功的可能是 <a href="https://github.com/raganwald/allong.es" target="_blank" rel="noopener">allong.es</a>。但它不是一个流行的库，与 <a href="http://underscorejs.org/" target="_blank" rel="noopener">Underscore</a> 、 <a href="http://lodash.com/" target="_blank" rel="noopener">Lodash</a> 这些库不在一个级别上（就流行程度而言）；并且它有一个与 Ramda 不同的目标：它被设计为一种教学工具，一本书的演示库。</p>
<p>Ramda 正在尝试一些不同的东西。它的目标是成为一个能进行日常实际工作的实用的函数式库。</p>
<p>我们从头开始构建这个函数式库，使用了许多其他函数式语言通用的技术，以对 JavaScript 有意义的方式对这些技术进行移植。我们并没有试图弥合与面向对象世界之间的鸿沟，或者复制每一种函数式语言的每一个特性。实际上，我们甚至没有试图复制单一函数式语言的每个特性。它仍然是 JavaScript，甚至还继承了 JavaScript 缺陷。</p>
<h2 id="han-shu-shi-te-xing">函数式特性</h2>
<p>那么，在广阔的函数式编程领域里，哪些部分是我们想要保留的，又有哪些不在我们的考虑范围呢？下面列出了函数式编程的一些主要（不完整）特性：</p>
<ul>
<li>一等函数</li>
<li>高阶函数</li>
<li>词法闭包</li>
<li>引用透明</li>
<li>数据不可变</li>
<li>模式匹配</li>
<li>惰性求值</li>
<li>高效递归（TCO）</li>
<li><a href="https://en.wikipedia.org/w/index.php?title=Homoiconicity&amp;redirect=no" target="_blank" rel="noopener">同像性（Homoiconic）</a></li>
</ul>
<p>前几个特性都已经内置在 JavaScript 中了。JavaScript 中的函数是一等公民，意味着我们可以像使用字符串、数字或对象等，对其引用或传递。我们还可以将函数作为参数传递给其他函数，并返回全新的函数，所以 JavaScript 中包含高阶函数。因为返回函数可以访问其在创建时的上下文中的所有变量，所以我们也在语言中构建出了词法闭包。</p>
<p>除此之外，上面列出其他的特性都没有自动包含在 JavaScript 中。有的可以轻易实现，有的只能部分或很难实现，有的则超出了语言的当前能力。</p>
<p>Ramda 可以确保在不会导致你的代码出问题的情况下，帮助实现（管理）上面的其他一些特性。例如，Ramda 不会改变你的输入数据。永远也不会！如果使用 <code>append</code> 将元素添加到列表的末尾，则会返回包含添加元素的新列表。你的原始列表保持不变。所以，由于 Ramda 不会尝试强行改变不可变的客户端数据，它可以很容易的与不可变数据一起工作。</p>
<p>另一方面，Ramda 强制要求引用透明。这个概念的意思是：可以在不改变整个程序行为的情况下，将表达式替换为其对应的计算值。对于 Ramda 来说，这意味着 Ramda 不会在应用程序中存储内部状态，也不会引用任何全局变量或者内部状态可以变的闭包。简言之，当你使用相同的值调用 Ramda 函数时，总会得到相同的结果。</p>
<p>在撰写本文时，正在讨论 Ramda 的惰性求值问题。一些库如 <a href="http://danieltao.com/lazy.js/" target="_blank" rel="noopener">Lazy.js</a> 和 <a href="https://github.com/goatslacker/lz" target="_blank" rel="noopener">Lz.js</a> ，表明在 JavaScript 中进行惰性求值是可行的。<a href="https://github.com/cognitect-labs/transducers-js" target="_blank" rel="noopener">Transducer</a> 提供了一种模拟惰性求值的方法。Ramda 正在努力增强自己这方面的能力。但这是一个巨大的改变，并不会很快实现。</p>
<p>Ramda 还会考虑加入一定程度的模式匹配，但不会像 Erlang 或 Haskell 这样的语言中的那么强大或方便。我们并没有看到会改变语言语法的宏，所以我们最多可以做一些类似于 <a href="http://raganwald.com/2014/06/23/multiple-dispatch.html#guarded-functions" target="_blank" rel="noopener">Reg Braithwaite 所描述的东西</a>。但是这至少在某种程度上讲是一种模式匹配的技术。</p>
<p>其他特性都超出了 Ramda 的能力。虽然有 <a href="https://en.wikipedia.org/wiki/Trampoline_(computing)" target="_blank" rel="noopener">trampolining</a> 技术可以让你在不使用尾递归优化工具的情况下获得递归的一些好处，但是它们由于侵入性太强而不能被普遍使用。所以 Ramda 内部没有使用太多递归，也没有提供任何帮助来实现有效的递归。好消息是它将会被提到下一版语言规范的计划中去。</p>
<p>然后是 <strong>同像性（homoiconicity）</strong> – 某些语言（LISP、Prolog）的特性：程序的语法可以用一种在自身语言中易于理解和修改的数据结构表示的。这远远超出了 JavaScript 当前的能力，甚至超出了 Ramda 的梦想。</p>
<h1 id="zu-he-xing">组合性</h1>
<p>Ramda 的目标之一是，允许用户使用小的可组合函数，这是函数式编程的关键。</p>
<p>函数式编程通常涉及一些少量常见的数据结构，以及搭配操作它们的大量函数。这就是 Ramda 的工作原理。</p>
<p>简言之，Ramda 主要进行列表操作。但 JavaScript 没有列表的实现；最接近的模拟是 Array（数组）。这是 Ramda 使用的最基本的数据结构。我们不关心 JavaScript 数组的一些深层次可能的性质。我们忽略稀疏数组。如果你传了一个这样的数组给 Ramda，有可能会得到意想不到的结果。你需要传给 Ramda 以 Array 实现的列表。（如果这对你没有意义，不用担心；这是人们使用 JavaScript 数组的标准方式，你必须非常努力，才能创建出不寻常的情况（译者注：错误的情况））。</p>
<p>许多 Ramda 函数接受列表并且返回列表。这些函数都很容易组合。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// :: [Comment] -&gt; [Number]  </span></span><br><span class="line"><span class="keyword">var</span> userRatingForComments = R.compose(</span><br><span class="line">    R.pluck(<span class="string">'rating'</span>),       <span class="comment">// [User] -&gt; [Number]</span></span><br><span class="line">    R.map(R.propOf(users)),  <span class="comment">// [String] -&gt; [User]</span></span><br><span class="line">    R.pluck(<span class="string">'username'</span>)      <span class="comment">// [Comment] -&gt; [String]</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>Ramda 还包含 <code>pipe</code> 函数，它跟 <code>compose</code> 功能相同，但顺序是反的；我个人觉得它更可读一些：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// :: [Comment] -&gt; [Number]  </span></span><br><span class="line"><span class="keyword">var</span> userRatingForComments = R.pipe(</span><br><span class="line">    R.pluck(<span class="string">'username'</span>),     <span class="comment">// [Comment] -&gt; [String]</span></span><br><span class="line">    R.map(R.propOf(users)),  <span class="comment">// [String] -&gt; [User]</span></span><br><span class="line">    R.pluck(<span class="string">'rating'</span>)        <span class="comment">// [User] -&gt; [Number]</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>当然，组合可以作用于任何类型。如果下一个函数接受当前函数返回的类型，那么一切都应该没问题。</p>
<p>为了让其工作，Ramda 的函数必须具有足够小的规模。这与 Unix 的哲学不谋而合：大型的工具应该由小工具构建而成，每个工具做且只做一件事情。Ramda 的函数也是如此。理想情况下，这意味着以这些函数为基础的系统的复杂性只是问题自身固有的复杂性，而不是由库增加的附带的复杂性。</p>
<h2 id="bu-bian-xing">不变性</h2>
<p>需要再次重申，Ramda 函数不会修改输入数据。这是函数式编程的核心原则，也是 Ramda 工作的核心。虽然这些函数可能会改变内部局部变量，但 Ramda 不会改变传递给它的任何数据。</p>
<p>这并不意味着你使用的所有东西都会被复制。Ramda 重用了它所能用到的。因此，在像 <code>assoc</code> 和 <code>assocPath</code> 这样的函数，返回具有特定更新属性的对象的克隆中，原始数据的所有非原生（non-primitive）属性在新对象中将以引用的方式使用。如果你想要一个对象的完全解耦的副本，Ramda 提供了 <code>cloneDeep</code>（译者注：现在 Ramda 只提供 <code>clone</code> 用作深拷贝） 函数。</p>
<p>这种不变性对 Ramda 来说是硬性规定。任何牵扯到变更用户数据的 pull request 都会被拒绝。我们认为这是 Ramda 的主要特征之一。</p>
<h1 id="shi-yong-xing">实用性</h1>
<p>最后，Ramda 的目标是成为一个实用的库。这更难表述，因为实用性就像 “美丽” 一样：总是在旁观者眼中才能反映出来。永远都会有对不符合 Ramda 哲学的功能的要求，在那些提议者心目中，这些功能都是非常实用的。通常这些函数（功能）本身是有用的，但是由于不符合 Ramda 的哲学而被拒绝。</p>
<p>对于 Ramda 而言，实用性意味着一些具体的事情。</p>
<h2 id="ming-ling-shi-shi-xian-1">命令式实现</h2>
<p>首先，Ramda 的实现并未遵循 LISP、ML 或者 Haskell 库中的优雅的编码技术。我们使用丑陋的命令式的循环，而不是优雅的递归代码块。一些 Ramda 的作者曾经在一个叫 <a href="https://github.com/CrossEye/eweda" target="_blank" rel="noopener">Eweda</a> 的早起的库中走过这条路，代码非常漂亮，但是在解决实际问题上它却失败了。许多列表函数只能处理一千个左右的条目，而且性能也很糟糕。 JavaScript 的设计没有很好的处理递归，大多数当前的引擎不执行任何尾部调用优化。</p>
<p>而 Ramda 的源代码却使用了乱七八糟的丑陋的 <code>while</code> 循环。</p>
<p>这意味着 Ramda 的实现不能作为如何编写功能良好的 JavaScript 的模型（模板）。这太糟糕了。但它是目前的 JavaScript 引擎最实用的一种选择（方案）。</p>
<h2 id="he-li-de-api">合理的 API</h2>
<p>Ramda 还试图就 API 中应该包含什么做出实用的选择。我们并没有试图移植 Clojure、Haskell 或任何其他函数式语言中的任何特定的函数子集，也没有试图模仿更成熟的 JavaScript 库或规范的 API。我们采纳函数的标准是，它们表现出合理的效用。当然，它们也必须与我们的函数式范式相契合才会被考虑，但这还不够；我们必须确信它们将会被用到，并且它们提供了通过当前函数不容易实现的价值。</p>
<p>后者是比较棘手的。有一个平衡的方案，以确定什么情况下语法糖是可以接受的。在之前，我们讨论了 <code>compose</code> 有一个执行顺序相反孪生同胞 <code>pipe</code>。有一种观点认为这是一种浪费，我们不应该把 API 因为这些多余的函数而搞乱。毕竟，</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">R.pipe(fn1, fn2, ..., fnN)</span><br></pre></td></tr></table></figure>
<p>可以重写为如下形式：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">R.apply(R.compose, R.reverse([fn1, fn2, ..., fnN]));</span><br></pre></td></tr></table></figure>
<p>但是，我们确实选择将 <code>pipe</code> 以及其他一些看似多余的函数包含到其中，当它们符合下面的条件时：</p>
<ul>
<li>很有可能会被用到</li>
<li>能更好的表达开发人员的意图</li>
<li>足够简单的实现</li>
</ul>
<h2 id="zheng-ji-qie-yi-zhi-de-api">整洁且一致的 API</h2>
<p>对于整体一致 API 的追求，听起来不像是一个现实的考虑，更像是一个纯粹主义者的目标。但事实上，提供简单而一致的 API 使得 Ramda 更易于使用。例如，一旦你习惯了 Ramda 对参数顺序的设定，你将很少需要查阅文档以确定如何构建你的调用。</p>
<p>另外，Ramda 坚决反对可选参数。这个决定有助于形成非常整洁的 API。一个函数应该做什么以及如何调用，通常是非常直观的。</p>
<h2 id="bing-mei-you-shi-yao-hui-bang-zhu-wo-de-jian-yi">并没有 “什么会帮助我” 的建议</h2>
<p>最后，向某个人解释这个问题通常是最困难的，那就是一个用户对什么才是实用的概念与整个库的实用性实际上可能只有一点点关系。即使提出的函数有助于解决某个难题，如果问题太过狭隘，或者解决方案偏离了我们的基础哲学，那么它也不会被纳入到 Ramda 中。虽然实用性是在旁观者眼中反映出来的，但那些能够纵观整个库的旁观者会有一个宏观的不同的视野，只有那些能够在整体上提升 Ramda 的改变才会被采纳。</p>
<h1 id="jie-lun-sheng-er-bu-tong">结论：生而不同</h1>
<p>Ramda 的诞生是因为，没有任何其他的库能以我们想要的方式工作。我们想要将可以作用于不可变数据的小型可组合函数，组合成简洁的函数式的 pipeline （管道）。当 Ramda 与类似的库相比较时，这涉及到一些似乎颇具争议的决定。我们并不担心这一点。Ramda 为我们工作的很好，似乎也满足了<a href="https://github.com/ramda/ramda/stargazers" target="_blank" rel="noopener">社区的需求</a>。</p>
<p>我们不再孤单。自从我们开始以来，<a href="https://github.com/nullobject/fkit" target="_blank" rel="noopener">FKit</a> 也萌发了相似的想法。这是一个不太成熟的库，它的工作方式和 <a href="https://github.com/CrossEye/eweda" target="_blank" rel="noopener">Eweda</a> 一样，试图在 API 及其实现上同时保持真正的优雅。在我看来，他们很可能会遇到性能瓶颈。但是，我们无能为力，只能祝福他们。</p>
<p>Ramda 正在努力坚持它作为 “JavaScript 开发人员的实用的函数式库” 的座右铭。我们认为我们正在管理和维护 Ramda。但我们也<a href="https://github.com/ramda/ramda/issues" target="_blank" rel="noopener">很乐意倾听</a> 您的想法。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://adispring.github.io/2017/12/04/Functions-in-Functional-Programming/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="wangzengdi">
      <meta itemprop="description" content="FE@Meituan.com">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="wangzengdi's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2017/12/04/Functions-in-Functional-Programming/" class="post-title-link" itemprop="url">函数式编程中的“函数们”</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2017-12-04 08:30:46" itemprop="dateCreated datePublished" datetime="2017-12-04T08:30:46+00:00">2017-12-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-07-25 10:51:10" itemprop="dateModified" datetime="2021-07-25T10:51:10+00:00">2021-07-25</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>函数式编程中的函数有三种不同的解读方式，分别为纯函数、高阶函数和一等函数。本文分别对这三者的概念、应用和联系进行详解。</p>
<h1 id="chun-han-shu">纯函数</h1>
<p>定义：</p>
<blockquote>
<ol>
<li>相同的输入必定产生相同的输出；</li>
<li>在计算的过程中，不会产生副作用。</li>
</ol>
</blockquote>
<p>满足上述两个条件，我们就说该函数是纯函数。</p>
<p>纯函数也即数学意义上的函数，表达的是数据之间的转换（映射）关系，而非计算步骤的详述。数学函数的定义：</p>
<blockquote>
<p>函数通常由定义域 <em>X</em> 、值域 <em>Y</em> 以及定义域到值域的映射 <em>f</em> （<em>f: X -&gt; Y</em>）组成。</p>
</blockquote>
<p><img src="./function.png" alt="function"></p>
<p>纯函数让我们对写出的函数具有完全的控制能力。纯函数的结果 <strong>必须</strong> 只依赖于输入参数，不受外部环境的影响；同时纯函数在计算结果的过程中，也不会影响（污染）外部环境，即不会产生副作用。</p>
<h2 id="han-shu-zu-he">函数组合</h2>
<p>纯函数定义中的两个条件保证了它（的计算过程）与外界是完全隔离，这也是函数组合的基础。</p>
<p>只有函数组合中的所有函数都是纯函数，我们组合起来的新函数才会是纯函数。我们可以对使用纯函数组合出来的新函数从数学上证明（推导）其正确性，而无需借助大量的单元测试。</p>
<p>只要在函数组合时引入一个非纯函数，整个组合出来的函数将沦为非纯函数。如果将函数组合比作管道的拼接，只要组成管道的任何一小节有泄露或者外部注入，我们便失去了对整条管道的完全控制。</p>
<p><img src="./pipeline-leaking.png" alt="pipeline-leaking"></p>
<p>要想实现函数组合，还需要满足连续性，描述如下：</p>
<p>因为纯函数可以看作定义域到值域映射，待组合的函数中的上一个函数的值域须等于下一个函数的定义域，也即上一个函数的输出（类型）等于下一个的输入（类型）。</p>
<p>假设有两个函数：<em>f: X -&gt; Y</em> 和 <em>g: Y -&gt; Z</em>，只有 <code>codomain(f) = domain(g)</code> 时，<em>f</em> 和 <em>g</em> 才可以组合。</p>
<p><img src="./functions_composition.png" alt="function_composition"></p>
<h2 id="yin-yong-tou-ming-ji-huan-cun">引用透明及缓存</h2>
<p>在不改变整个程序行为的情况下，如果能将其中的一段代码替换为其执行的结果，我们就说这段代码是引用透明的。</p>
<p>因此，执行一段引用透明的代码（函数），对于相同的参数，总是给出相同的结果。我们也称这样的函数（代码）为纯函数。</p>
<p>引用透明的一个典型应用即函数缓存。我们可以将已经执行过的函数输入值缓存起来，下次调用时，若输入值相同，直接跳过计算过程，用缓存结果代替计算结果返回即可。</p>
<p>函数缓存的实现依赖于闭包，而闭包的实现又依赖于高阶函数，高阶函数的实现又依赖于一等函数。我们按照这条依赖链，从里往外依次对它们进行讲解。</p>
<h1 id="yi-deng-han-shu-first-class-functions">一等函数（First Class Functions）</h1>
<p>程序语言会对基本元素的使用方式进行限制，带有最少限制的元素被称为一等公民，其拥有的 “权利” 如下：</p>
<blockquote>
<ul>
<li>可以使用变量命名；</li>
<li>可以提供给函数作为参数；</li>
<li>可以由函数作为结果返回；</li>
<li>可以包含在数据结构中；</li>
</ul>
</blockquote>
<p>乍一看，我们应该首先会想到程序中的基本数据结构（如 number、array、object 等）是一等公民。如果函数也被视为一等公民，我们便可以像使用普通数据一样对其使用变量命名，作为参数或返回值使用，或者将其包含在数据结构中。在这里函数和数据的边界开始变得不再那么分明了。函数被视为一等公民后，其能力和适用范围被大大扩展了。</p>
<p>下面使用 JavaScript 对上面第一条和第四条 “权利” 进行讲解。第二、三条与高阶函数密切相关，将放到下一节的高阶函数中讲解。</p>
<h2 id="shi-yong-bian-liang-ming-ming">使用变量命名</h2>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> square = <span class="function"><span class="params">x</span> =&gt;</span> x * x</span><br></pre></td></tr></table></figure>
<p>上面代码定义了一个求平方值的函数，并将其赋给了 square 变量。</p>
<h2 id="ke-yi-bao-han-zai-shu-ju-jie-gou-zhong">可以包含在数据结构中</h2>
<p><a href="http://ramda.cn/" target="_blank" rel="noopener">Ramda</a> 中有一个API：<a href="http://ramda.cn/docs/#evolve" target="_blank" rel="noopener">evolve</a>，其接受的首个参数便是一个属性值为函数的对象。<a href="http://ramda.cn/docs/#evolve" target="_blank" rel="noopener">evolve</a> 函数会递归地对 “待处理对象” 的属性进行变换，变换的方式由 transformation 内置函数属性值的对象定义。示例如下（示例中的 <code>R.xxx</code> 都是 <a href="http://ramda.cn/docs/" target="_blank" rel="noopener">Ramda</a> 中的API，相关API的功能可以参考<a href="http://ramda.cn/docs/" target="_blank" rel="noopener">Ramda</a>文档）：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> tomato  = &#123;<span class="attr">name</span>: <span class="string">'Tomato'</span>, <span class="attr">data</span>: &#123;<span class="attr">elapsed</span>: <span class="number">100</span>, <span class="attr">remaining</span>: <span class="number">1400</span>&#125;, <span class="attr">id</span>:<span class="number">123</span>&#125;;</span><br><span class="line"><span class="keyword">var</span> transformations = &#123;</span><br><span class="line">  name: R.toUpper,</span><br><span class="line">  data: &#123;<span class="attr">elapsed</span>: R.add(<span class="number">1</span>), <span class="attr">remaining</span>: R.add(<span class="number">-1</span>)&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">R.evolve(transformations)(tomato);</span><br><span class="line"><span class="comment">//=&gt; &#123;name: 'TOMATO', data: &#123;elapsed: 101, remaining: 1399&#125;, id:123&#125;</span></span><br></pre></td></tr></table></figure>
<h1 id="gao-jie-han-shu">高阶函数</h1>
<p>定义：</p>
<blockquote>
<p>使用函数作为输入参数，或者返回结果为函数的函数，被称为高阶函数。</p>
</blockquote>
<p>作为参数或返回值的函数，是一等函数的应用之一。高阶函数以一等函数作为基础，只有支持一等函数的语言才能进行高阶函数编程。</p>
<p>以熟悉的 <a href="http://ramda.cn/docs/#filter" target="_blank" rel="noopener">filter</a> 函数为例，我们可以用 <a href="http://ramda.cn/docs/#filter" target="_blank" rel="noopener">filter</a> 对列表中的元素进行过滤，筛选出符合条件的元素。<a href="http://ramda.cn/docs/#filter" target="_blank" rel="noopener">filter</a> 的类型签名和示例代码如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">filter :: (a → <span class="built_in">Boolean</span>) → [a] → [a]</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> isEven = <span class="function"><span class="params">n</span> =&gt;</span> n % <span class="number">2</span> === <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> filterEven = R.filter(isEven);</span><br><span class="line"></span><br><span class="line">filterEven([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]); <span class="comment">//=&gt; [2, 4]</span></span><br></pre></td></tr></table></figure>
<p><a href="http://ramda.cn/docs/#filter" target="_blank" rel="noopener">filter</a> 接受一个判断函数（判断输入值是否为偶数）<code>isEven</code>，返回一个过滤出偶数的函数 <code>filterEven</code>。</p>
<h1 id="bi-bao">闭包</h1>
<p>定义：</p>
<blockquote>
<p>闭包是由函数及该函数捕获的其上下文中的自由变量组成的记录</p>
</blockquote>
<p>举例讲：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> xIn = x;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">addInner</span>(<span class="params">y</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> xIn + y;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> inc = add(<span class="number">1</span>);</span><br><span class="line">inc(<span class="number">8</span>); <span class="comment">//=&gt; 9;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> plus2 = add(<span class="number">2</span>);</span><br><span class="line">plus2(<span class="number">8</span>); <span class="comment">//=&gt; 10;</span></span><br></pre></td></tr></table></figure>
<p>上述代码中返回的函数 <code>addInner</code> 及由其捕获的在其上下文中定义的自由变量 <code>xIn</code>，便组成了一个闭包。</p>
<p><img src="./closure.png" alt="closure"></p>
<p>上述代码中最外层的 <code>add</code> 函数是一个高阶函数，其返回值为一等函数 <code>addInner</code>。</p>
<p>其实 <code>add</code> 函数的参数 <code>x</code> 也是 <code>addInner</code> 上下文的一部分，所以 ‘xIn’ 也就没有存在的必要了，<code>add</code> 代码优化如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">addInner</span>(<span class="params">y</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>借助于箭头函数，我们可以进一步优化 <code>add</code> 的实现：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> add = <span class="function"><span class="params">x</span> =&gt;</span> <span class="function"><span class="params">y</span> =&gt;</span> x + y</span><br></pre></td></tr></table></figure>
<p>是不是非常简洁？由此我们可以一窥函数式编程强大的表达能力。</p>
<p>闭包主要用来做数据缓存，而数据缓存应用非常广泛：包括函数工厂模式、模拟拥有私有变量的对象、函数缓存、还有大名鼎鼎的柯里化。</p>
<p>其实上述代码中 <code>add</code> 函数便是柯里化形式的函数。</p>
<p>上述代码中的 <code>const inc = add(1);</code> 和 <code>const plus2 = add(2);</code> 是一种函数工厂模式，通过向 <code>add</code> 函数传入不同的参数，便会产生功能不同的函数。函数工厂可以提高函数的抽象和复用能力。</p>
<p>例如我们有一个如下形式的 Ajax 请求函数：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> ajax = <span class="function"><span class="params">method</span> =&gt;</span> <span class="function"><span class="params">type</span> =&gt;</span> <span class="function"><span class="params">query</span> =&gt;</span> &#123; ... &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">get</span> = ajax('GET');</span><br><span class="line">const post = ajax('POST');</span><br><span class="line"></span><br><span class="line">const getJson = <span class="keyword">get</span>('json');</span><br><span class="line">const getHtml = ajax('GET')('text/html') = <span class="keyword">get</span>('text/html');</span><br></pre></td></tr></table></figure>
<p>我们抽象出了最一般的 <code>ajax</code> 请求函数，在具体应用时，我们用能通过函数工厂生产出作用不同的函数。</p>
<p>通过上面几个小节，我们讲解了纯函数（数学意义上的函数）、一等函数、高阶函数，还有闭包。</p>
<p>下面通过一个集上述所有概念于一身的 <strong>函数缓存</strong> ，来结束函数式编程中的 “函数们” 的论述。</p>
<h1 id="han-shu-huan-cun-memoize">函数缓存 memoize</h1>
<p>函数实现：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> memoize = <span class="function"><span class="params">pureFunc</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> cache = &#123;&#125;;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> argStr = <span class="built_in">JSON</span>.stringify(<span class="built_in">arguments</span>);</span><br><span class="line">    cache[argStr] = cache[argStr] || pureFunc.apply(pureFunc, <span class="built_in">arguments</span>);</span><br><span class="line">    <span class="keyword">return</span> cache[argStr];</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>memoize</code> 的功能是对传入函数 <code>pureFunc</code> 进行缓存，返回缓存版本的 <code>pureFunc</code>。当我们使用参数调用缓存的函数时，缓存的函数会到 <code>cache</code> 中查找该参数是否被缓存过，如果有缓存，则不需要再次计算，直接返回已缓存值，否则对本次输入的参数进行计算，缓存计算的结果以备后用，然后将结果返回。</p>
<p><code>memoize</code> 只有对纯函数的缓存才有意义。因为纯函数是引用透明的，其输出只依赖于输入，并且计算过程不会影响外部环境。</p>
<p>举一个极端的例子，假如我们有一个随机数字生成函数 <code>random()</code>, 如果对其进行了缓存：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> memoizedRandom = memoize(random);</span><br></pre></td></tr></table></figure>
<p><code>memoizedRandom</code> 除了第一次生成一个随机值外，随后的调用都返回第一次缓存的值，这样就失去了 <code>random</code> 的意义。再假如，我们对终端字符输入函数 <code>getchar()</code> 进行了缓存，每次调用都会是第一次获取的字母。</p>
<p><code>memoize</code> 内部实现了一个闭包的创建。返回的缓存函数和自由变量 <code>cache</code> 共同构成了一个闭包。自由变量 <code>cached</code> 用于对已经计算过的数据（参数）的缓存。而闭包本身是由高阶函数和一等函数实现的。</p>
<p><img src="./functions-in-memoize.png" alt="functions-in-memoize"></p>
<h1 id="zong-jie">总结</h1>
<p>本文对函数式编程中的 “函数们” 做了详细解释：纯函数、一等函数、高阶函数，并展示了它们的应用。其中纯函数是函数组合的基础；一等函数是高阶函数的实现基础，一等函数和高阶函数又是闭包的实现基础。</p>
<p>最后通过函数缓存函数 <code>memoize</code> 将纯函数、一等函数、高阶函数和闭包联系了起来，用函数式编程中的 “函数们” （函数式三镖客）的一次 “联合行动” 结束本文。</p>
<h1 id="can-kao-wen-dang">参考文档</h1>
<p><a href="http://www.mathsisfun.com/sets/function.html" target="_blank" rel="noopener">What is a Function?</a>.</p>
<p><a href="https://en.wikipedia.org/wiki/Functional_programming" target="_blank" rel="noopener">Functional Programming</a>.</p>
<p><a href="https://en.wikipedia.org/wiki/Referential_transparency" target="_blank" rel="noopener">Referential Transparency</a>.</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://adispring.github.io/2017/11/11/Practical-Ramda-Recursion/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="wangzengdi">
      <meta itemprop="description" content="FE@Meituan.com">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="wangzengdi's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2017/11/11/Practical-Ramda-Recursion/" class="post-title-link" itemprop="url">Practical Ramda: Recursion</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2017-11-11 00:10:07" itemprop="dateCreated datePublished" datetime="2017-11-11T00:10:07+00:00">2017-11-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-07-25 10:51:10" itemprop="dateModified" datetime="2021-07-25T10:51:10+00:00">2021-07-25</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Practical-Ramda/" itemprop="url" rel="index"><span itemprop="name">Practical Ramda</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>本文首先介绍了递归的定义、实质、满足条件等，然后利用 Ramda API 和 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_operator" target="_blank" rel="noopener">Spread &amp; Rest</a> 操作符对递归进行实例讲解。</p>
<h1 id="di-gui-de-li-lun-ji-chu">递归的理论基础</h1>
<p>递归的定义：一种直接或者间接调用自身的过程。</p>
<p>递归的实质：将待求解问题分解成规模缩小的同类子问题，然后递归调用方法来表示问题的解。是一个不断将问题拆分然后组合的过程。</p>
<p>递归的过程：“能进则进，不进则退”。</p>
<p>递归问题需满足的条件：</p>
<ol>
<li>一个（或多个）基本情景 – 一个不使用递归而产生结果的终止情景；</li>
<li>一组可以将所有其他情景归约至基本情景的规则。</li>
</ol>
<p>递归的条件归结为：一个终止条件和一组归约的规则。</p>
<p>递归能让我们写出非常简洁、直观的代码，但简洁并不等于简单（容易）。递归是一种从总体到局部的思维过程，与传统的命令式的思维方式差异较大。命令式思维要求显示地提供详细的求解步骤，而递归（或者函数式）要求用概括性的语言对问题进行描述，问题的描述本身就是编程的整个过程，这要求我们具有很强的抽象思维和逻辑推理能力。</p>
<p>递归的编程模式：</p>
<ol>
<li>定义终止条件；</li>
<li>编写递归的归约规则。</li>
</ol>
<p>但如果语言中实现了惰性求值，也可以不定义终止条件，比如递归生成无限长的序列。</p>
<p>以上便是递归的理论解释，下面我们通过一些实例对递归进行实际演示。</p>
<h1 id="di-gui-de-shi-jian">递归的实践</h1>
<p>递归能够很好地处理列表和树形数据结构的很多问题。很多时候，我们解决问题的模式就是对不断缩小的列表或树反复做同一件事情。实际上，列表和树本身的构造也可以看做递归的过程。</p>
<p>列表可以看作有列表首元素（头部）和其余元素（尾部）的组合，如下所示：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> list = R.prepend(<span class="number">1</span>, R.prepend(<span class="number">2</span>, R.prepend(<span class="number">3</span>, []))); <span class="comment">// =&gt; [1, 2, 3]</span></span><br><span class="line"><span class="keyword">var</span> list = [<span class="number">1</span>, ...[<span class="number">2</span>, ...[<span class="number">3</span>, ...[]]]];</span><br></pre></td></tr></table></figure>
<p>本文中我们使用 ramda 和 expect npm库进行演示：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> R = <span class="built_in">require</span>(<span class="string">'ramda'</span>);</span><br><span class="line"><span class="keyword">const</span> expect = <span class="built_in">require</span>(<span class="string">'expect'</span>);</span><br></pre></td></tr></table></figure>
<h2 id="kuai-su-pai-xu">快速排序</h2>
<p>下面以经典的快速排序为例开始递归算法的演示。快排的定义为：所有小于头部的元素（它们也需要排序）在先，大于头部的元素（它们也需要排序）在后，终止条件为空数组。</p>
<p>首先我们用模式匹配 <a href="http://ramda.cn/docs/#cond" target="_blank" rel="noopener">R.cond</a> 的方式来进行递归排序。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> quickSort = R.cond(</span><br><span class="line">  [R.isEmpty, R.always([])],</span><br><span class="line">  [</span><br><span class="line">    R.T,</span><br><span class="line">    xs =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> head = R.head(xs);</span><br><span class="line">    <span class="keyword">const</span> tail = R.tail(xs);</span><br><span class="line">    <span class="keyword">return</span> R.compose(quickSort, R.filter(R.lte(R.__, head)))(tail)</span><br><span class="line">     .concat(head)</span><br><span class="line">     .concat(R.compose(quickSort, R.filter(R.gte(R.__, head)))(tail));</span><br><span class="line">  &#125;]</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">expect(quickSort([<span class="number">5</span>, <span class="number">1</span>, <span class="number">9</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">3</span>])).toEqual([<span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">9</span>]);</span><br></pre></td></tr></table></figure>
<p>快排的过程如下所示（借用 <a href="http://learnyouahaskell.com/recursion" target="_blank" rel="noopener">Learn You a Haskell for Great Good!</a> 的图)：</p>
<p><img src="./quicksort.png" alt="quicksort"></p>
<p>如果只有一个 <code>if-else</code> 对，我们也可以使用 <a href="http://ramda.cn/docs/#ifElse" target="_blank" rel="noopener">R.ifElse</a> 来代替 <a href="http://ramda.cn/docs/#cond" target="_blank" rel="noopener">R.cond</a>。另外，我们还可以用 <a href="http://ramda.cn/docs/#when" target="_blank" rel="noopener">R.when</a> 和 <a href="http://ramda.cn/docs/#unless" target="_blank" rel="noopener">R.unless</a> 来进一步简化 <a href="http://ramda.cn/docs/#ifElse" target="_blank" rel="noopener">R.ifElse</a>。</p>
<p>使用 Ramda API 的递归规则还是有些冗长，我们可以使用 ES6 中的 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_operator" target="_blank" rel="noopener">Spread &amp; Rest</a> 操作符和 <a href="http://ramda.cn/docs/#unless" target="_blank" rel="noopener">R.unless</a> 对列表的头部元素和其他尾部元素的提取和组合进行简化，如下所示：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> quickSort = R.unless(</span><br><span class="line">  R.isEmpty,</span><br><span class="line">  ([head, ...tail]) =&gt; [</span><br><span class="line">    ...R.compose(quickSort, R.filter(R.lte(R.__, head)))(tail),</span><br><span class="line">    head,</span><br><span class="line">    ...R.compose(quickSort, R.filter(R.gte(R.__, head)))(tail),</span><br><span class="line">  ]</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">expect(quickSort([<span class="number">5</span>, <span class="number">1</span>, <span class="number">9</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">3</span>])).toEqual([<span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">9</span>]);</span><br></pre></td></tr></table></figure>
<h2 id="fei-bo-na-qi-xu-lie">斐波那契序列</h2>
<p>下面展示的是斐波那契序列, 斐波那契序列的数学表达式如下所示：</p>
<ul>
<li>f(0) = 0</li>
<li>f(1) = 1</li>
<li>f(n) = f(n-1) + f(n-2)</li>
</ul>
<p>以序列元素值为半径的斐波那契螺旋线如下所示：</p>
<p><img src="./fibonacci.jpg" alt="fibonacci"></p>
<p>代码实现如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fib = <span class="function"><span class="params">n</span> =&gt;</span> R.unless(</span><br><span class="line">  R.contains(R.__, [<span class="number">0</span>, <span class="number">1</span>]),</span><br><span class="line">  () =&gt; fib(n - <span class="number">1</span>) + fib(n - <span class="number">2</span>)</span><br><span class="line">)(n);</span><br><span class="line"></span><br><span class="line">expect(fib(<span class="number">6</span>)).toEqual(<span class="number">8</span>);</span><br></pre></td></tr></table></figure>
<h2 id="map-filter-reduce">map、filter、reduce</h2>
<p><a href="http://ramda.cn/docs/#map" target="_blank" rel="noopener">map</a>、<a href="http://ramda.cn/docs/#filter" target="_blank" rel="noopener">filter</a>、<a href="http://ramda.cn/docs/#reduce" target="_blank" rel="noopener">reduce</a> 作为函数式编程中处理列表的三个基本函数，在底层实现或者演示时，一般会采用命令式的 for 循环迭代来实现，既然列表本身可以看作递归结构，我们就用递归来尝试实现函数式编程中处理列表的 “三镖客”。</p>
<p>首先以 <code>map</code> 为例，从命令式 for 循环实现开始，然后是递归实现，并在对递归实现的优化中展示函数式编程（或者说 Ramda 库）灵活、多变而又优雅的编程方式，体会什么才是真正的编程之美。</p>
<p>map 的 <a href="https://llh911001.gitbooks.io/mostly-adequate-guide-chinese/content/ch7.html" target="_blank" rel="noopener">Hindley-Milner</a> 类型签名如下所示：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">map :: Functor f =&gt; (a → b) → f a → f b</span><br></pre></td></tr></table></figure>
<p>其实 <code>map</code> 是 <a href="https://en.wikipedia.org/wiki/Functor" target="_blank" rel="noopener">Functor</a> 的一个函数，Functor 是具体范畴之间的映射（态射），关于范畴、Functor、态射等函数式的概念不在本次的讨论范围之内，感兴趣的同学可以自己查看相关资料。在这里，可以将 Functor 看做是列表（列表是 Functor 的一个实例），<code>map</code> 看作不同类型列表之间的映射，将源列表中的元素进行转换，生成一个包含映射后元素的新列表。</p>
<p><code>map</code> 列表形式的类型签名如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">map :: (a → b) → [a] → [b]</span><br></pre></td></tr></table></figure>
<p><code>map</code> 命令式实现：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> map = <span class="function">(<span class="params">fn, list</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">var</span> newList = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; list.length; i++) &#123;</span><br><span class="line">    newList[i] = fn(list[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> newList;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">expect(map(R.multiply(<span class="number">2</span>), R.range(<span class="number">1</span>, <span class="number">5</span>))).toEqual([<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>]);</span><br></pre></td></tr></table></figure>
<p><code>map</code> 递归实现1，三目运算符版：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> mapR = <span class="function">(<span class="params">fn, list</span>) =&gt;</span></span><br><span class="line">  (R.isEmpty(list) ? list : R.prepend(fn(R.head(list)), mapR(fn, R.tail(list))));</span><br></pre></td></tr></table></figure>
<p><code>map</code> 递归实现2，模式匹配（<a href="http://ramda.cn/docs/#cond" target="_blank" rel="noopener">R.cond</a>）版：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> mapR2 = <span class="function">(<span class="params">fn, list</span>) =&gt;</span> R.cond([</span><br><span class="line">  [R.isEmpty, R.identity],</span><br><span class="line">  [R.T, R.converge(R.prepend, [R.compose(fn, R.head), xs =&gt; mapR2(fn, R.tail(xs))])],</span><br><span class="line">])(list);</span><br></pre></td></tr></table></figure>
<p><code>map</code> 递归实现3，unless（<a href="http://ramda.cn/docs/#unless" target="_blank" rel="noopener">R.unless</a>）版：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> mapR3 = <span class="function">(<span class="params">fn, list</span>) =&gt;</span> R.unless(</span><br><span class="line">  R.isEmpty,</span><br><span class="line">  R.converge(R.prepend, [R.compose(fn, R.head), xs =&gt; mapR3(fn, R.tail(xs))])</span><br><span class="line">)(list);</span><br></pre></td></tr></table></figure>
<p><code>map</code> 递归实现4，<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_operator" target="_blank" rel="noopener">Spread Operator</a>  + unless 版：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> mapR5 = <span class="function">(<span class="params">fn, xs</span>) =&gt;</span> R.unless(</span><br><span class="line">  R.isEmpty,</span><br><span class="line">  ([head, ...tail]) =&gt; [fn(head), ...mapR5(fn, tail)]</span><br><span class="line">)(xs);</span><br></pre></td></tr></table></figure>
<p>总结一下上述命令式、递归实现以及递归的优化实现的特点。</p>
<p>命令式实现需要显式写出内部的每步实现步骤，包括如何获取、变换和组合元素等；还使用了 mutable 的数据，包括全局的结果列表 <code>newList</code> 和 迭代索引 <code>i</code>。命令式的好处是符合正常的思维方式，但缺点是引入了较多冗余的 “噪声”，比如 for 循环、全局变量 <code>newList</code> 和 <code>i</code> 都是辅助项，这些辅助项稍微增多，代码复杂度会显著上升，真正有用的信息便会淹没在了这些 “噪声” 里面。</p>
<p>反观递归式（函数式）的实现（如 <code>map</code> 的 <code>Spead Operator</code> + <code>unless</code> 版实现），我们只需要通过对问题的描述，便得到功能的实现。而描述的过程看似简单，实则内含了对问题本质的抽象和逻辑分析，对人们的思维能力要求更高。</p>
<p>再讲一下 <code>Spead Operator</code> 语法糖。很多人不屑于用语法糖，态度往往是：这不就是 xxx 的语法糖吗？没什么大不了的啊。但语法上的便利其实也是很重要的一方面，因为我们想要表达的思想是要由语法来承载的。</p>
<p>这里引用《函数式编程思维》中的一段话：</p>
<blockquote>
<p>我跟 Martin Fowler 在巴塞罗那的一辆出租车上有过一次记忆深刻的讨论，我们聊的是 Smalltalk 的衰落和 Java 的兴盛。Fowler 在这两种语言上都有很深厚的积累，他说，起初 他觉得从 Smalltalk 到 Java 的变化只是一些语法上的不便，结果却发现被阻碍的还有原先 语言所承载的思维方式。在语法处处掣肘下塑造出来的抽象，很难配合我们的思维过程而 不产生无谓的摩擦。</p>
</blockquote>
<p>下面对 <code>filter</code> 和 <code>reduce</code> 的递归实现做一个展示。</p>
<p><code>filter</code> 的递归实现如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> filterR = <span class="function">(<span class="params">pred, list</span>) =&gt;</span></span><br><span class="line">  R.isEmpty(list) ? list : pred(R.head(list)) ? R.prepend(R.head(list), filterR(pred, R.tail(list))) : filterR(pred, R.tail(list));</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> filterR2 = <span class="function">(<span class="params">pred, list</span>) =&gt;</span> R.cond([</span><br><span class="line">  [R.isEmpty, R.identity],</span><br><span class="line">  [R.compose(pred, R.head), R.converge(R.prepend, [R.head, xs =&gt; filterR2(pred, R.tail(xs))])],</span><br><span class="line">  [R.T, xs =&gt; filterR2(pred, R.tail(xs))],</span><br><span class="line">])(list);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> filterR3 = <span class="function">(<span class="params">pred, list</span>) =&gt;</span> R.unless(</span><br><span class="line">  R.isEmpty,</span><br><span class="line">  R.converge(R.concat, [R.compose(R.ifElse(pred, R.of, R.always([])), R.head), xs =&gt; filterR3(pred, R.tail(xs))])</span><br><span class="line">)(list);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> filterR3 = <span class="function">(<span class="params">pred, list</span>) =&gt;</span> R.unless(</span><br><span class="line">  R.isEmpty,</span><br><span class="line">  R.converge(R.concat, [R.compose(R.ifElse(pred, R.of, R.always([])), R.head), xs =&gt; filterR3(pred, R.tail(xs))])</span><br><span class="line">)(list);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> filterR4 = <span class="function">(<span class="params">pred, list</span>) =&gt;</span> R.unless(</span><br><span class="line">  R.isEmpty,</span><br><span class="line">  ([head, ...tail]) =&gt; [...(pred(head) ? [head] : []), ...filterR4(pred, tail)]</span><br><span class="line">)(list);</span><br><span class="line"></span><br><span class="line">expect(filterR(<span class="function"><span class="params">a</span> =&gt;</span> a % <span class="number">2</span>, R.range(<span class="number">1</span>, <span class="number">10</span>))).toEqual([<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>]);</span><br></pre></td></tr></table></figure>
<p>reduce 的递归实现如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> reduceR = <span class="function">(<span class="params">fn, acc, list</span>) =&gt;</span></span><br><span class="line">  (R.isEmpty(list) ? acc : reduceR(fn, fn(acc, R.head(list)), R.tail(list)));</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> reduceR2 = <span class="function">(<span class="params">fn, acc, list</span>) =&gt;</span> R.cond([</span><br><span class="line">  [R.isEmpty, () =&gt; acc],</span><br><span class="line">  [R.T, xs =&gt; reduceR2(fn, fn(acc, R.head(xs)), R.tail(xs))],</span><br><span class="line">])(list);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> reduceR3 = <span class="function">(<span class="params">fn, acc, list</span>) =&gt;</span> R.ifElse(</span><br><span class="line">  R.isEmpty,</span><br><span class="line">  () =&gt; acc,</span><br><span class="line">  xs =&gt; reduceR3(fn, fn(acc, R.head(xs)), R.tail(xs))</span><br><span class="line">)(list);</span><br><span class="line"></span><br><span class="line">expect(reduceR(R.add, <span class="number">0</span>, R.range(<span class="number">1</span>, <span class="number">5</span>))).toEqual(<span class="number">10</span>);</span><br></pre></td></tr></table></figure>
<h1 id="zong-jie">总结</h1>
<p>本文从递归的定义、实质等基本理论开始，然后是递归的一些实例，其中大量运用了 <a href="http://ramda.cn" target="_blank" rel="noopener">ramda</a> 函数式编程库中的 API，既是对递归的演示，也是对 ramda API 的实践展示。展示了递归和函数式在编程时的强悍的表达能力和对极致简约的追求。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://adispring.github.io/2017/10/21/What-Function-Should-I-Use/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="wangzengdi">
      <meta itemprop="description" content="FE@Meituan.com">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="wangzengdi's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2017/10/21/What-Function-Should-I-Use/" class="post-title-link" itemprop="url">Ramda 函数简介</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2017-10-21 07:25:36" itemprop="dateCreated datePublished" datetime="2017-10-21T07:25:36+00:00">2017-10-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-07-25 10:51:10" itemprop="dateModified" datetime="2021-07-25T10:51:10+00:00">2021-07-25</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Ramda/" itemprop="url" rel="index"><span itemprop="name">Ramda</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Ramda API 已经快到 300 个了，对每个 API 按类型分别进行简介，当作 Ramda 的一份 CheatSheet 。</p>
<h1 id="lie-biao">列表</h1>
<table>
<thead>
<tr>
<th style="text-align:left">Action</th>
<th style="text-align:left">Function</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">列表转换</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#map" target="_blank" rel="noopener">map</a></td>
</tr>
<tr>
<td style="text-align:left">列表过滤：过滤出符合条件的元素</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#filter" target="_blank" rel="noopener">filter</a></td>
</tr>
<tr>
<td style="text-align:left">列表过滤：过滤掉符合条件的元素</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#reject" target="_blank" rel="noopener">reject</a></td>
</tr>
<tr>
<td style="text-align:left">列表折叠：从左向右对所有元素依次归约（折叠）</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#reduce" target="_blank" rel="noopener">reduce</a></td>
</tr>
<tr>
<td style="text-align:left">列表折叠：从右向左对所有元素依次归约（折叠）</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#reduceRight" target="_blank" rel="noopener">reduceRight</a></td>
</tr>
<tr>
<td style="text-align:left">列表折叠(增强版)</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#transduce" target="_blank" rel="noopener">transduce</a></td>
</tr>
<tr>
<td style="text-align:left">列表去重</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#uniq" target="_blank" rel="noopener">uniq</a></td>
</tr>
<tr>
<td style="text-align:left">列表去重：对处理后的元素做相等性判断</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#uniqBy" target="_blank" rel="noopener">uniqBy</a></td>
</tr>
<tr>
<td style="text-align:left">列表去重：通过断言函数（predicate）判断</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#uniqWith" target="_blank" rel="noopener">uniqWith</a></td>
</tr>
<tr>
<td style="text-align:left">列表排序</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#sort" target="_blank" rel="noopener">sort</a></td>
</tr>
<tr>
<td style="text-align:left">列表翻转</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#reverse" target="_blank" rel="noopener">reverse</a></td>
</tr>
<tr>
<td style="text-align:left">列表拼接</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#concat" target="_blank" rel="noopener">concat</a></td>
</tr>
<tr>
<td style="text-align:left">列表长度</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#length" target="_blank" rel="noopener">length</a></td>
</tr>
<tr>
<td style="text-align:left">列表表头拼接元素</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#prepend" target="_blank" rel="noopener">prepend</a></td>
</tr>
<tr>
<td style="text-align:left">列表表尾拼接元素</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#append" target="_blank" rel="noopener">append</a></td>
</tr>
<tr>
<td style="text-align:left">更新指定索引处的值</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#adjust" target="_blank" rel="noopener">adjust</a></td>
</tr>
<tr>
<td style="text-align:left">替换指定索引处的值</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#update" target="_blank" rel="noopener">update</a></td>
</tr>
<tr>
<td style="text-align:left">将列表元素转换为其指定的属性值，等价于 R.map(R.prop)</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#pluck" target="_blank" rel="noopener">pluck</a></td>
</tr>
<tr>
<td style="text-align:left">为列表迭代函数添加两个参数：索引和整个列表</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#addIndex" target="_blank" rel="noopener">addIndex</a></td>
</tr>
<tr>
<td style="text-align:left">取出特定索引范围内的元素</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#slice" target="_blank" rel="noopener">slice</a></td>
</tr>
<tr>
<td style="text-align:left">将列表通过分隔符拼接成字符串</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#join" target="_blank" rel="noopener">join</a></td>
</tr>
<tr>
<td style="text-align:left">取出第 N 个元素</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#nth" target="_blank" rel="noopener">nth</a></td>
</tr>
<tr>
<td style="text-align:left">取出前 N 个元素</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#take" target="_blank" rel="noopener">take</a></td>
</tr>
<tr>
<td style="text-align:left">取出后 N 个元素</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#takeLast" target="_blank" rel="noopener">takeLast</a></td>
</tr>
<tr>
<td style="text-align:left">从前往后取出满足条件的元素，直至不满足条件的首个元素止</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#takeWhile" target="_blank" rel="noopener">takeWhile</a></td>
</tr>
<tr>
<td style="text-align:left">从后向前取出满足条件的元素，直至不满足条件的首个元素止</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#takeLastWhile" target="_blank" rel="noopener">takeLastWhile</a></td>
</tr>
<tr>
<td style="text-align:left">删除前 N 个元素</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#drop" target="_blank" rel="noopener">drop</a></td>
</tr>
<tr>
<td style="text-align:left">删除后 N 个元素</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#dropLast" target="_blank" rel="noopener">dropLast</a></td>
</tr>
<tr>
<td style="text-align:left">从前往后删除满足条件的元素，直至不满足条件的首个元素止</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#dropWhile" target="_blank" rel="noopener">dropWhile</a></td>
</tr>
<tr>
<td style="text-align:left">从后向前删除满足条件的元素，直至不满足条件的首个元素止</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#dropLastWhile" target="_blank" rel="noopener">dropLastWhile</a></td>
</tr>
<tr>
<td style="text-align:left">取出首个元素</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#head" target="_blank" rel="noopener">head</a></td>
</tr>
<tr>
<td style="text-align:left">取出末尾元素</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#taillast" target="_blank" rel="noopener">last</a></td>
</tr>
<tr>
<td style="text-align:left">取出前 length - 1 个元素（删除末尾元素）</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#init" target="_blank" rel="noopener">init</a></td>
</tr>
<tr>
<td style="text-align:left">取出后 length - 1 个元素（删除首个元素）</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#tail" target="_blank" rel="noopener">tail</a></td>
</tr>
<tr>
<td style="text-align:left">求差集：{a∣a∈xs ∩ a∉ys}</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#difference" target="_blank" rel="noopener">difference</a></td>
</tr>
<tr>
<td style="text-align:left">求差集：{a∣a∉xs ∩ a∈ys}</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#without" target="_blank" rel="noopener">without</a></td>
</tr>
<tr>
<td style="text-align:left">求差集：根据条件计算第一个列表与第二个列表的差集</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#differenceWith" target="_blank" rel="noopener">differenceWith</a></td>
</tr>
<tr>
<td style="text-align:left">求对称差集：{(xs ∪ ys) - (xs ∩ ys)}</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#symmetricDifference" target="_blank" rel="noopener">symmetricDifference</a></td>
</tr>
<tr>
<td style="text-align:left">求对称差集：根据条件计算所有不属于两个列表交集的元素</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#symmetricDifferenceWith" target="_blank" rel="noopener">symmetricDifferenceWith</a></td>
</tr>
<tr>
<td style="text-align:left">求交集：{xs ∩ ys}</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#intersection" target="_blank" rel="noopener">intersection</a></td>
</tr>
<tr>
<td style="text-align:left">求交集：从 xs 中挑选出在 ys 中符合条件的元素</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#innerJoin" target="_blank" rel="noopener">innerJoin</a></td>
</tr>
<tr>
<td style="text-align:left">求并集：{xs ∪ ys}</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#union" target="_blank" rel="noopener">union</a></td>
</tr>
<tr>
<td style="text-align:left">求并集：根据条件判断两元素是否重复</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#unionWith" target="_blank" rel="noopener">unionWith</a></td>
</tr>
<tr>
<td style="text-align:left">查找列表中首个满足条件的元素</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#find" target="_blank" rel="noopener">find</a></td>
</tr>
<tr>
<td style="text-align:left">查找列表中首个满足条件的元素的索引</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#findIndex" target="_blank" rel="noopener">findIndex</a></td>
</tr>
<tr>
<td style="text-align:left">查找列表中最后一个满足条件的元素</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#findLast" target="_blank" rel="noopener">findLast</a></td>
</tr>
<tr>
<td style="text-align:left">查找列表中最后一个满足条件的元素的索引</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#findLastIndex" target="_blank" rel="noopener">findLastIndex</a></td>
</tr>
<tr>
<td style="text-align:left">查找给定元素在列表中首次出现时的索引</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#indexOf" target="_blank" rel="noopener">indexOf</a></td>
</tr>
<tr>
<td style="text-align:left">查找给定元素在列表中末次出现时的索引</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#lastIndexOf" target="_blank" rel="noopener">lastIndexOf</a></td>
</tr>
<tr>
<td style="text-align:left">列表判断：判断元素是否包含在列表中</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#contains" target="_blank" rel="noopener">contains</a></td>
</tr>
<tr>
<td style="text-align:left">列表判断：判断是否列表中所有元素都满足条件</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#all" target="_blank" rel="noopener">all</a></td>
</tr>
<tr>
<td style="text-align:left">列表判断：判断是否列表中所有元素都不满足条件</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#none" target="_blank" rel="noopener">none</a></td>
</tr>
<tr>
<td style="text-align:left">列表判断：判断是否列表中存在满足条件的元素</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#any" target="_blank" rel="noopener">any</a></td>
</tr>
<tr>
<td style="text-align:left">列表判断：判断列表是否以给定的值开头</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#startsWith" target="_blank" rel="noopener">startsWith</a></td>
</tr>
<tr>
<td style="text-align:left">列表判断：判断列表是否以给定的值结尾</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#endsWith" target="_blank" rel="noopener">endsWith</a></td>
</tr>
<tr>
<td style="text-align:left">列表分组：按是否符合条件，将元素分为两组</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#partition" target="_blank" rel="noopener">partition</a></td>
</tr>
<tr>
<td style="text-align:left">列表分组：对列表中元素按指定规则分组</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#groupBy" target="_blank" rel="noopener">groupBy</a></td>
</tr>
<tr>
<td style="text-align:left">列表分段：对列表中元素按指定规则分段</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#groupWith" target="_blank" rel="noopener">groupWith</a></td>
</tr>
<tr>
<td style="text-align:left">列表分组：对列表中元素按指定规则分组折叠</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#reduceBy" target="_blank" rel="noopener">reduceBy</a></td>
</tr>
<tr>
<td style="text-align:left">列表分割：在指定索引处</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#splitAt" target="_blank" rel="noopener">splitAt</a></td>
</tr>
<tr>
<td style="text-align:left">列表分割：每隔 N 个元素</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#splitEvery" target="_blank" rel="noopener">splitEvery</a></td>
</tr>
<tr>
<td style="text-align:left">列表分割：按条件分割</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#splitWhen" target="_blank" rel="noopener">splitWhen</a></td>
</tr>
<tr>
<td style="text-align:left">对两个列表相同位置的元素进行组合</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#zip" target="_blank" rel="noopener">zip</a></td>
</tr>
<tr>
<td style="text-align:left">对两个列表相同位置的元素进行键值对组合，fromPairs ∘ zip</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#zipObj" target="_blank" rel="noopener">zipObj</a></td>
</tr>
<tr>
<td style="text-align:left">对两个列表相同位置的元素按规则进行组合</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#zipWith" target="_blank" rel="noopener">zipWith</a></td>
</tr>
<tr>
<td style="text-align:left">由一系列键值对列表创建对象</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#fromPairs" target="_blank" rel="noopener">fromPairs</a></td>
</tr>
<tr>
<td style="text-align:left">列表彻底扁平化</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#flatten" target="_blank" rel="noopener">flatten</a></td>
</tr>
<tr>
<td style="text-align:left">列表单层扁平化</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#unnest" target="_blank" rel="noopener">unnest</a></td>
</tr>
<tr>
<td style="text-align:left">先对列表内元素做 Kleisli 映射，再做扁平化，flatMap，&gt;&gt;=</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#chain" target="_blank" rel="noopener">chain</a></td>
</tr>
<tr>
<td style="text-align:left">函子间的自然变化？</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#sequence" target="_blank" rel="noopener">sequence</a></td>
</tr>
<tr>
<td style="text-align:left">列表插入</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#insert" target="_blank" rel="noopener">insert</a></td>
</tr>
<tr>
<td style="text-align:left">将子列表插入列表</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#insertAll" target="_blank" rel="noopener">insertAll</a></td>
</tr>
<tr>
<td style="text-align:left">在列表元素之间插入分割元素</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#intersperse" target="_blank" rel="noopener">intersperse</a></td>
</tr>
<tr>
<td style="text-align:left">列表转换 + 折叠？</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#into" target="_blank" rel="noopener">into</a></td>
</tr>
<tr>
<td style="text-align:left">将 reduce 的迭代过程记录下来</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#mapAccum" target="_blank" rel="noopener">mapAccum</a></td>
</tr>
<tr>
<td style="text-align:left">将 reduceRight 的迭代过程记录下来</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#mapAccumRight" target="_blank" rel="noopener">mapAccumRight</a></td>
</tr>
<tr>
<td style="text-align:left">合并多个对象</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#mergeAll" target="_blank" rel="noopener">mergeAll</a></td>
</tr>
<tr>
<td style="text-align:left">由两个参数组成列表</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#pair" target="_blank" rel="noopener">pair</a></td>
</tr>
<tr>
<td style="text-align:left">从 reduce 或 transduce 中提前退出迭代时的值</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#reduced" target="_blank" rel="noopener">reduced</a></td>
</tr>
<tr>
<td style="text-align:left">可以提前退出的 reduce 迭代</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#reduceWhile" target="_blank" rel="noopener">reduceWhile</a></td>
</tr>
<tr>
<td style="text-align:left">列表生成：生成左闭右开的升序数字列表</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#range" target="_blank" rel="noopener">range</a></td>
</tr>
<tr>
<td style="text-align:left">列表生成：生成含有 N 个同一元素的列表</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#repeat" target="_blank" rel="noopener">repeat</a></td>
</tr>
<tr>
<td style="text-align:left">列表生成：函数执行 N 次，生成 N 元列表</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#times" target="_blank" rel="noopener">times</a></td>
</tr>
<tr>
<td style="text-align:left">列表生成：通过迭代函数生成列表</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#unfold" target="_blank" rel="noopener">unfold</a></td>
</tr>
<tr>
<td style="text-align:left">二维列表行列式转换</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#transpose" target="_blank" rel="noopener">transpose</a></td>
</tr>
<tr>
<td style="text-align:left">二维列表生成</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#xprod" target="_blank" rel="noopener">xprod</a></td>
</tr>
</tbody>
</table>
<h1 id="han-shu">函数</h1>
<table>
<thead>
<tr>
<th style="text-align:left">Action</th>
<th style="text-align:left">Function</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">函数组合：纵向，从右往左</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#compose" target="_blank" rel="noopener">compose</a></td>
</tr>
<tr>
<td style="text-align:left">函数组合：纵向，从左往右</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#pipe" target="_blank" rel="noopener">pipe</a></td>
</tr>
<tr>
<td style="text-align:left">函数组合：纵向</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#o" target="_blank" rel="noopener">o</a></td>
</tr>
<tr>
<td style="text-align:left">函数组合：横向</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#converge" target="_blank" rel="noopener">converge</a></td>
</tr>
<tr>
<td style="text-align:left">函数组合：横向</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#useWith" target="_blank" rel="noopener">useWith</a></td>
</tr>
<tr>
<td style="text-align:left">Kleisili 函数组合</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#composeK" target="_blank" rel="noopener">composeK</a></td>
</tr>
<tr>
<td style="text-align:left">Kleisili 函数组合</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#pipeK" target="_blank" rel="noopener">pipeK</a></td>
</tr>
<tr>
<td style="text-align:left">Promise 函数组合</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#composeP" target="_blank" rel="noopener">composeP</a></td>
</tr>
<tr>
<td style="text-align:left">Promise 函数组合</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#pipeP" target="_blank" rel="noopener">pipeP</a></td>
</tr>
<tr>
<td style="text-align:left">单位函数：输出等于输入</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#identity" target="_blank" rel="noopener">identity</a></td>
</tr>
<tr>
<td style="text-align:left">函数柯里化</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#curry" target="_blank" rel="noopener">curry</a></td>
</tr>
<tr>
<td style="text-align:left">N 元函数柯里化</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#curryN" target="_blank" rel="noopener">curryN</a></td>
</tr>
<tr>
<td style="text-align:left">将柯里化函数 转为 N 元函数</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#uncurryN" target="_blank" rel="noopener">uncurryN</a></td>
</tr>
<tr>
<td style="text-align:left">柯里化函数的参数占位符</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#__" target="_blank" rel="noopener">__</a></td>
</tr>
<tr>
<td style="text-align:left">参数部分调用：从左往右</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#partial" target="_blank" rel="noopener">partial</a></td>
</tr>
<tr>
<td style="text-align:left">参数部分调用：从右往左</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#partialRight" target="_blank" rel="noopener">partialRight</a></td>
</tr>
<tr>
<td style="text-align:left">函数缓存</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#memoize" target="_blank" rel="noopener">memoize</a></td>
</tr>
<tr>
<td style="text-align:left">函数缓存：可以自定义缓存键值</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#memoizeWith" target="_blank" rel="noopener">memoizeWith</a></td>
</tr>
<tr>
<td style="text-align:left">只执行一次的函数</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#once" target="_blank" rel="noopener">once</a></td>
</tr>
<tr>
<td style="text-align:left">创建返回恒定值的函数</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#always" target="_blank" rel="noopener">always</a></td>
</tr>
<tr>
<td style="text-align:left">恒定返回 <code>true</code> 的函数</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#T" target="_blank" rel="noopener">T</a></td>
</tr>
<tr>
<td style="text-align:left">恒定返回 <code>false</code>  的函数</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#F" target="_blank" rel="noopener">F</a></td>
</tr>
<tr>
<td style="text-align:left">Applicative Functor 的 ap 方法，&lt;*&gt;</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#ap" target="_blank" rel="noopener">ap</a></td>
</tr>
<tr>
<td style="text-align:left">将函数作用于参数列表</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#apply" target="_blank" rel="noopener">apply</a></td>
</tr>
<tr>
<td style="text-align:left">将接受 <strong>单列表参数</strong> 的函数转为接受 <strong>普通参数列表</strong> 的函数</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#unapply" target="_blank" rel="noopener">unapply</a></td>
</tr>
<tr>
<td style="text-align:left">将首个参数（函数）作用于其余参数</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#call" target="_blank" rel="noopener">call</a></td>
</tr>
<tr>
<td style="text-align:left">绑定函数上下文</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#bind" target="_blank" rel="noopener">bind</a></td>
</tr>
<tr>
<td style="text-align:left">利用属性值为函数的对象生成同构对象</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#applySpec" target="_blank" rel="noopener">applySpec</a></td>
</tr>
<tr>
<td style="text-align:left">将函数列表作用于参数列表</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#juxt" target="_blank" rel="noopener">juxt</a></td>
</tr>
<tr>
<td style="text-align:left">将给定值传给给定函数，CPS: flip($)</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#applyTo" target="_blank" rel="noopener">applyTo</a></td>
</tr>
<tr>
<td style="text-align:left">比较函数，一般用于排序</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#comparator" target="_blank" rel="noopener">comparator</a></td>
</tr>
<tr>
<td style="text-align:left">升序比较函数</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#ascend" target="_blank" rel="noopener">ascend</a></td>
</tr>
<tr>
<td style="text-align:left">降序比较函数</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#descend" target="_blank" rel="noopener">descend</a></td>
</tr>
<tr>
<td style="text-align:left">将函数封装为 N 元函数</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#nArg" target="_blank" rel="noopener">nArg</a></td>
</tr>
<tr>
<td style="text-align:left">将函数封装为一元函数</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#unary" target="_blank" rel="noopener">unary</a></td>
</tr>
<tr>
<td style="text-align:left">将函数封装为二元函数</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#binary" target="_blank" rel="noopener">binary</a></td>
</tr>
<tr>
<td style="text-align:left">提取第 N 个参数</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#nthArg" target="_blank" rel="noopener">nthArg</a></td>
</tr>
<tr>
<td style="text-align:left">将构造函数封装为普通函数，创建实例时，不需要 new 操作符</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#construct" target="_blank" rel="noopener">construct</a></td>
</tr>
<tr>
<td style="text-align:left">将构造函数封装为 N 元普通函数，创建实例时，不需要 new 操作符</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#constructN" target="_blank" rel="noopener">constructN</a></td>
</tr>
<tr>
<td style="text-align:left">通过函数名调用函数</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#invoker" target="_blank" rel="noopener">invoker</a></td>
</tr>
<tr>
<td style="text-align:left">创建相应类型的空值</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#empty" target="_blank" rel="noopener">empty</a></td>
</tr>
<tr>
<td style="text-align:left">判断是否为空值</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#isEmpty" target="_blank" rel="noopener">isEmpty</a></td>
</tr>
<tr>
<td style="text-align:left">交换函数前两个参数的位置</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#flip" target="_blank" rel="noopener">flip</a></td>
</tr>
<tr>
<td style="text-align:left">函数提升</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#lift" target="_blank" rel="noopener">lift</a></td>
</tr>
<tr>
<td style="text-align:left">N 元函数提升</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#liftN" target="_blank" rel="noopener">liftN</a></td>
</tr>
<tr>
<td style="text-align:left">生成单元素列表</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#of" target="_blank" rel="noopener">of</a></td>
</tr>
<tr>
<td style="text-align:left">输出等于输入，但产生副作用的函数，一般用于调试</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#tap" target="_blank" rel="noopener">tap</a></td>
</tr>
<tr>
<td style="text-align:left">异常捕获</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#tryCatch" target="_blank" rel="noopener">tryCatch</a></td>
</tr>
</tbody>
</table>
<h1 id="dui-xiang">对象</h1>
<table>
<thead>
<tr>
<th style="text-align:left">Action</th>
<th style="text-align:left">Function</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">属性设置</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#assoc" target="_blank" rel="noopener">assoc</a></td>
</tr>
<tr>
<td style="text-align:left">属性按路径设置</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#assocPath" target="_blank" rel="noopener">assocPath</a></td>
</tr>
<tr>
<td style="text-align:left">属性删除</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#dissoc" target="_blank" rel="noopener">dissoc</a></td>
</tr>
<tr>
<td style="text-align:left">属性按路径删除</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#disscoPath" target="_blank" rel="noopener">disscoPath</a></td>
</tr>
<tr>
<td style="text-align:left">获取属性值</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#prop" target="_blank" rel="noopener">prop</a></td>
</tr>
<tr>
<td style="text-align:left">获取属性值，带有默认值</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#propOr" target="_blank" rel="noopener">propOr</a></td>
</tr>
<tr>
<td style="text-align:left">获取路径上的属性值</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#path" target="_blank" rel="noopener">path</a></td>
</tr>
<tr>
<td style="text-align:left">获取路径上的属性值，带有默认值</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#pathOr" target="_blank" rel="noopener">pathOr</a></td>
</tr>
<tr>
<td style="text-align:left">判断属性是否满足给定的条件</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#propSatisfies" target="_blank" rel="noopener">propSatisfies</a></td>
</tr>
<tr>
<td style="text-align:left">判断属性是否与给定值相等</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#propEq" target="_blank" rel="noopener">propEq</a></td>
</tr>
<tr>
<td style="text-align:left">判断两个对象指定的属性值是否相等</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#eqProps" target="_blank" rel="noopener">eqProps</a></td>
</tr>
<tr>
<td style="text-align:left">判断路径上的属性值是否满足给定的条件</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#pathSatisfies" target="_blank" rel="noopener">pathSatisfies</a></td>
</tr>
<tr>
<td style="text-align:left">判断路径上的属性值是否与给定值相等</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#pathEq" target="_blank" rel="noopener">pathEq</a></td>
</tr>
<tr>
<td style="text-align:left">获取属性值组成的列表</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#props" target="_blank" rel="noopener">props</a></td>
</tr>
<tr>
<td style="text-align:left">判断属性是否为给定类型</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#propIs" target="_blank" rel="noopener">propIs</a></td>
</tr>
<tr>
<td style="text-align:left">判断多个属性是否同时满足给定的条件</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#where" target="_blank" rel="noopener">where</a></td>
</tr>
<tr>
<td style="text-align:left">判断多个属性是否等于给定对应属性值</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#whereEq" target="_blank" rel="noopener">whereEq</a></td>
</tr>
<tr>
<td style="text-align:left">删除多个属性</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#omit" target="_blank" rel="noopener">omit</a></td>
</tr>
<tr>
<td style="text-align:left">提取多个属性</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#pick" target="_blank" rel="noopener">pick</a></td>
</tr>
<tr>
<td style="text-align:left">提取多个属性</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#pickAll" target="_blank" rel="noopener">pickAll</a></td>
</tr>
<tr>
<td style="text-align:left">对列表中元素提取多个属性，模拟 SQL 的 <code>select</code></td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#project" target="_blank" rel="noopener">project</a></td>
</tr>
<tr>
<td style="text-align:left">提取键值满足条件的属性</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#pickBy" target="_blank" rel="noopener">pickBy</a></td>
</tr>
<tr>
<td style="text-align:left">对特定属性进行特定变换</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#evolve" target="_blank" rel="noopener">evolve</a></td>
</tr>
<tr>
<td style="text-align:left">是否包含指定的键</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#has" target="_blank" rel="noopener">has</a></td>
</tr>
<tr>
<td style="text-align:left">是否包含指定的键：包括原型链上的键</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#hasIn" target="_blank" rel="noopener">hasIn</a></td>
</tr>
<tr>
<td style="text-align:left">键值对换位</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#invertObj" target="_blank" rel="noopener">invertObj</a></td>
</tr>
<tr>
<td style="text-align:left">键值对换位：将值放入数组中</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#invert" target="_blank" rel="noopener">invert</a></td>
</tr>
<tr>
<td style="text-align:left">取出所有的键</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#keys" target="_blank" rel="noopener">keys</a></td>
</tr>
<tr>
<td style="text-align:left">取出所有的键：包括原型链上的键</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#keysIn" target="_blank" rel="noopener">keysIn</a></td>
</tr>
<tr>
<td style="text-align:left">取出所有的值</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#values" target="_blank" rel="noopener">values</a></td>
</tr>
<tr>
<td style="text-align:left">取出所有的值：包括原型链上的值</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#valuesIn" target="_blank" rel="noopener">valuesIn</a></td>
</tr>
<tr>
<td style="text-align:left">透镜：包括属性的 getter 和 setter</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#lens" target="_blank" rel="noopener">lens</a></td>
</tr>
<tr>
<td style="text-align:left">透镜：指定索引的透镜</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#lensIndex" target="_blank" rel="noopener">lensIndex</a></td>
</tr>
<tr>
<td style="text-align:left">透镜：指定路径的透镜</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#lensPath" target="_blank" rel="noopener">lensPath</a></td>
</tr>
<tr>
<td style="text-align:left">透镜：指定属性的透镜</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#lensProp" target="_blank" rel="noopener">lensProp</a></td>
</tr>
<tr>
<td style="text-align:left">透镜：对被 <code>lens</code> 聚焦的属性做变换</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#over" target="_blank" rel="noopener">over</a></td>
</tr>
<tr>
<td style="text-align:left">透镜：对被 <code>lens</code> 聚焦的属性进行设置</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#set" target="_blank" rel="noopener">set</a></td>
</tr>
<tr>
<td style="text-align:left">透镜：读取被 <code>lens</code> 聚焦的属性值</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#view" target="_blank" rel="noopener">view</a></td>
</tr>
<tr>
<td style="text-align:left"><code>Object</code> 版 <code>map</code>，转换函数参数：(value, key, obj)</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#mapObjIndexed" target="_blank" rel="noopener">mapObjIndexed</a></td>
</tr>
<tr>
<td style="text-align:left">对象合并</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#merge" target="_blank" rel="noopener">merge</a></td>
</tr>
<tr>
<td style="text-align:left">对象合并：对重复的属性值按给定规则合并</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#mergeWith" target="_blank" rel="noopener">mergeWith</a></td>
</tr>
<tr>
<td style="text-align:left">对象合并：对重复的属性值按给定规则合并</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#mergeWithKey" target="_blank" rel="noopener">mergeWithKey</a></td>
</tr>
<tr>
<td style="text-align:left">对象深递归合并：以左侧对象属性为主</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#mergeDeepLeft" target="_blank" rel="noopener">mergeDeepLeft</a></td>
</tr>
<tr>
<td style="text-align:left">对象深递归合并：以右侧对象属性为主</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#mergeDeepRight" target="_blank" rel="noopener">mergeDeepRight</a></td>
</tr>
<tr>
<td style="text-align:left">对象深递归合并：对重复的非对象类型的值按给定规则合并</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#mergeDeepWith" target="_blank" rel="noopener">mergeDeepWith</a></td>
</tr>
<tr>
<td style="text-align:left">对象深递归合并：对重复的非对象类型的值按给定规则合并</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#mergeDeepWithKey" target="_blank" rel="noopener">mergeDeepWithKey</a></td>
</tr>
<tr>
<td style="text-align:left">创建包含单个键值对的对象</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#objOf" target="_blank" rel="noopener">objOf</a></td>
</tr>
<tr>
<td style="text-align:left">将对象键值对转换为元素为键值二元组的列表</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#toPairs" target="_blank" rel="noopener">toPairs</a></td>
</tr>
<tr>
<td style="text-align:left">将对象键值对转换为元素为键值二元组的列表:包括原型链上的键</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#toPairsIn" target="_blank" rel="noopener">toPairsIn</a></td>
</tr>
<tr>
<td style="text-align:left">将二元组的列表转换为对象</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#fromPairs" target="_blank" rel="noopener">fromPairs</a></td>
</tr>
</tbody>
</table>
<h1 id="luo-ji-yun-suan">逻辑运算</h1>
<table>
<thead>
<tr>
<th style="text-align:left">Action</th>
<th style="text-align:left">Function</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">判断是否满足所有条件</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#allPass" target="_blank" rel="noopener">allPass</a></td>
</tr>
<tr>
<td style="text-align:left">判断是否满足任一条件</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#anyPass" target="_blank" rel="noopener">anyPass</a></td>
</tr>
<tr>
<td style="text-align:left">判断是否同时满足两个条件</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#both" target="_blank" rel="noopener">both</a></td>
</tr>
<tr>
<td style="text-align:left">判断是否满足两个条件中的任意一个</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#either" target="_blank" rel="noopener">either</a></td>
</tr>
<tr>
<td style="text-align:left">逻辑与操作</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#and" target="_blank" rel="noopener">and</a></td>
</tr>
<tr>
<td style="text-align:left">逻辑或操作</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#or" target="_blank" rel="noopener">or</a></td>
</tr>
<tr>
<td style="text-align:left">模式匹配，相当于多个 <code>if/else</code></td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#cond" target="_blank" rel="noopener">cond</a></td>
</tr>
<tr>
<td style="text-align:left">单个 <code>if/else</code>，<code>cond</code> 的特例</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#ifElse" target="_blank" rel="noopener">ifElse</a></td>
</tr>
<tr>
<td style="text-align:left">满足条件，则执行处理函数，否则原样返回输入值，<code>ifElse</code> 的特例</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#when" target="_blank" rel="noopener">when</a></td>
</tr>
<tr>
<td style="text-align:left">不满足条件时，执行处理函数，否则原样返回输入值，<code>ifElse</code> 的特例</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#unless" target="_blank" rel="noopener">unless</a></td>
</tr>
<tr>
<td style="text-align:left">逻辑非操作，参数为布尔值</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#not" target="_blank" rel="noopener">not</a></td>
</tr>
<tr>
<td style="text-align:left">对函数返回值取反</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#complement" target="_blank" rel="noopener">complement</a></td>
</tr>
<tr>
<td style="text-align:left">添加默认值</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#defaultTo" target="_blank" rel="noopener">defaultTo</a></td>
</tr>
<tr>
<td style="text-align:left">一直计算，直到满足给定条件</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#until" target="_blank" rel="noopener">until</a></td>
</tr>
<tr>
<td style="text-align:left">判断给定值是否为该类型的空值</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#isEmpty" target="_blank" rel="noopener">isEmpty</a></td>
</tr>
<tr>
<td style="text-align:left">判断给定值是否为 <code>null</code> 或 <code>undefined</code></td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#isNil" target="_blank" rel="noopener">isNil</a></td>
</tr>
<tr>
<td style="text-align:left">返回给定值所属类型的空值</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#empty" target="_blank" rel="noopener">empty</a></td>
</tr>
</tbody>
</table>
<h1 id="guan-xi-yun-suan">关系运算</h1>
<table>
<thead>
<tr>
<th style="text-align:left">Action</th>
<th style="text-align:left">Function</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">等于</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#equals" target="_blank" rel="noopener">equals</a></td>
</tr>
<tr>
<td style="text-align:left">完全相等</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#identical" target="_blank" rel="noopener">identical</a></td>
</tr>
<tr>
<td style="text-align:left">通过规则判断是否相等</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#eqBy" target="_blank" rel="noopener">eqBy</a></td>
</tr>
<tr>
<td style="text-align:left">大于</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#gt" target="_blank" rel="noopener">gt</a></td>
</tr>
<tr>
<td style="text-align:left">大于等于</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#gte" target="_blank" rel="noopener">gte</a></td>
</tr>
<tr>
<td style="text-align:left">小于</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#lt" target="_blank" rel="noopener">lt</a></td>
</tr>
<tr>
<td style="text-align:left">小于等于</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#lte" target="_blank" rel="noopener">lte</a></td>
</tr>
<tr>
<td style="text-align:left">限定有序数据类型的范围</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#clamp" target="_blank" rel="noopener">clamp</a></td>
</tr>
<tr>
<td style="text-align:left">求两个数的较大值</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#max" target="_blank" rel="noopener">max</a></td>
</tr>
<tr>
<td style="text-align:left">按规则求两个数的较大值</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#maxBy" target="_blank" rel="noopener">maxBy</a></td>
</tr>
<tr>
<td style="text-align:left">求两个数的较小值</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#min" target="_blank" rel="noopener">min</a></td>
</tr>
<tr>
<td style="text-align:left">按规则求两个数的较小值</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#minBy" target="_blank" rel="noopener">minBy</a></td>
</tr>
<tr>
<td style="text-align:left">求差集：{a∣a∈xs ∩ a∉ys}</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#difference" target="_blank" rel="noopener">difference</a></td>
</tr>
<tr>
<td style="text-align:left">求差集：{a∣a∉xs ∩ a∈ys}</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#without" target="_blank" rel="noopener">without</a></td>
</tr>
<tr>
<td style="text-align:left">求差集：根据条件计算第一个列表与第二个列表的差集</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#differenceWith" target="_blank" rel="noopener">differenceWith</a></td>
</tr>
<tr>
<td style="text-align:left">求对称差集：{(xs ∪ ys) - (xs ∩ ys)}</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#symmetricDifference" target="_blank" rel="noopener">symmetricDifference</a></td>
</tr>
<tr>
<td style="text-align:left">求对称差集：根据条件计算所有不属于两个列表交集的元素</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#symmetricDifferenceWith" target="_blank" rel="noopener">symmetricDifferenceWith</a></td>
</tr>
<tr>
<td style="text-align:left">求交集：{xs ∩ ys}</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#intersection" target="_blank" rel="noopener">intersection</a></td>
</tr>
<tr>
<td style="text-align:left">求交集：从 xs 中挑选出在 ys 中符合条件的元素</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#innerJoin" target="_blank" rel="noopener">innerJoin</a></td>
</tr>
<tr>
<td style="text-align:left">求并集：{xs ∪ ys}</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#union" target="_blank" rel="noopener">union</a></td>
</tr>
<tr>
<td style="text-align:left">求并集：根据条件判断两元素是否重复</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#unionWith" target="_blank" rel="noopener">unionWith</a></td>
</tr>
</tbody>
</table>
<h1 id="shu-xue-yun-suan">数学运算</h1>
<table>
<thead>
<tr>
<th style="text-align:left">Action</th>
<th style="text-align:left">Function</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">加</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#add" target="_blank" rel="noopener">add</a></td>
</tr>
<tr>
<td style="text-align:left">减</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#subtract" target="_blank" rel="noopener">subtract</a></td>
</tr>
<tr>
<td style="text-align:left">乘</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#multiply" target="_blank" rel="noopener">multiply</a></td>
</tr>
<tr>
<td style="text-align:left">除</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#divide" target="_blank" rel="noopener">divide</a></td>
</tr>
<tr>
<td style="text-align:left">加1</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#inc" target="_blank" rel="noopener">inc</a></td>
</tr>
<tr>
<td style="text-align:left">减1</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#dec" target="_blank" rel="noopener">dec</a></td>
</tr>
<tr>
<td style="text-align:left">取反</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#negate" target="_blank" rel="noopener">negate</a></td>
</tr>
<tr>
<td style="text-align:left">列表累加和</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#sum" target="_blank" rel="noopener">sum</a></td>
</tr>
<tr>
<td style="text-align:left">列表累乘积</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#product" target="_blank" rel="noopener">product</a></td>
</tr>
<tr>
<td style="text-align:left">列表平均值</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#mean" target="_blank" rel="noopener">mean</a></td>
</tr>
<tr>
<td style="text-align:left">列表中位数</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#median" target="_blank" rel="noopener">median</a></td>
</tr>
<tr>
<td style="text-align:left">取模：算术</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#mathMod" target="_blank" rel="noopener">mathMod</a></td>
</tr>
<tr>
<td style="text-align:left">取模：JS</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#modulo" target="_blank" rel="noopener">modulo</a></td>
</tr>
</tbody>
</table>
<h1 id="lei-xing-cao-zuo">类型操作</h1>
<table>
<thead>
<tr>
<th style="text-align:left">Action</th>
<th style="text-align:left">Function</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">类型判断</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#is" target="_blank" rel="noopener">is</a></td>
</tr>
<tr>
<td style="text-align:left">类型描述</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#type" target="_blank" rel="noopener">type</a></td>
</tr>
<tr>
<td style="text-align:left">属性类型判断</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#propIs" target="_blank" rel="noopener">propIs</a></td>
</tr>
<tr>
<td style="text-align:left">判断是否为 <code>null</code> 或 <code>undefined</code></td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#isNil" target="_blank" rel="noopener">isNil</a></td>
</tr>
</tbody>
</table>
<h1 id="can-kao-zi-liao">参考资料</h1>
<p>关于 <code>Applicative Functor</code>，及其操作符 <a href="%5Bap%5D(http://ramda.cn/docs/#ap)">R.ap</a> (haskell 中的 <code>&lt;*&gt;</code>) 和 <a href="http://ramda.cn/docs/#lift" target="_blank" rel="noopener">lift</a> (haskell 中的 <code>&lt;$&gt;</code>) 的论述可参考下列资料：</p>
<ol>
<li>《Learn You A Haskell For Great Good》的 <a href="http://learnyouahaskell.com/functors-applicative-functors-and-monoids#applicative-functors" target="_blank" rel="noopener">Applicative 章节</a>，函数 <code>(-&gt;) r</code> 也是 Applicative，需要深入理解。</li>
</ol>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Function</span> :: ((-&gt;) r)</span><br><span class="line"><span class="type">Function</span> a = ((-&gt;) r) a </span><br><span class="line">           = r -&gt; a</span><br><span class="line"></span><br><span class="line">;; <span class="type">Functor</span>、<span class="type">Applicative</span>、<span class="type">Monad</span> 的类定义</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="type">Functor</span> f <span class="keyword">where</span></span>  </span><br><span class="line">    fmap :: (a -&gt; b) -&gt; f a -&gt; f b  </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> (<span class="type">Functor</span> <span class="title">f</span>) =&gt; <span class="type">Applicative</span> f <span class="keyword">where</span></span>  </span><br><span class="line">    pure :: a -&gt; f a  </span><br><span class="line">    (&lt;*&gt;) :: f (a -&gt; b) -&gt; f a -&gt; f b  </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="type">Monad</span> m <span class="keyword">where</span></span>  </span><br><span class="line">    return :: a -&gt; m a  </span><br><span class="line">  </span><br><span class="line">    (&gt;&gt;=) :: m a -&gt; (a -&gt; m b) -&gt; m b  </span><br><span class="line">  </span><br><span class="line">    (&gt;&gt;) :: m a -&gt; m b -&gt; m b  </span><br><span class="line">    x &gt;&gt; y = x &gt;&gt;= \_ -&gt; y  </span><br><span class="line">  </span><br><span class="line">    fail :: <span class="type">String</span> -&gt; m a  </span><br><span class="line">    fail msg = error msg  </span><br><span class="line"></span><br><span class="line">;; 作为<span class="type">Functor</span>、<span class="type">Applicative</span>、<span class="type">Monad</span> 的实例的 <span class="type">Function</span> 的定义，可以对比上面的类定义查看</span><br><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Functor</span> ((-&gt;) r) <span class="keyword">where</span></span></span><br><span class="line">    fmap = (.)</span><br><span class="line"></span><br><span class="line"><span class="title">fmap</span> :: (a -&gt; b) -&gt; (c -&gt; a) -&gt; (c -&gt; b)</span><br><span class="line"></span><br><span class="line"><span class="title">f</span> :: a -&gt; b</span><br><span class="line"></span><br><span class="line"><span class="title">g</span> :: c -&gt; a</span><br><span class="line"><span class="title">h</span> :: c -&gt; b</span><br><span class="line"></span><br><span class="line"><span class="title">const</span> h = fmap(f, g) = map(f, g) = compose(f, g)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Applicative</span> ((-&gt;) r) <span class="keyword">where</span></span></span><br><span class="line">    pure x = (\_ -&gt; x)</span><br><span class="line">    f &lt;*&gt; g = \x -&gt; f x (g x)</span><br><span class="line"></span><br><span class="line"><span class="title">f</span> &lt;*&gt; g = (r-&gt;(a-&gt;b)) -&gt; (r-&gt;a) -&gt; (r-&gt;b)</span><br><span class="line">        = (r-&gt;a-&gt;b) -&gt; (r-&gt;a) -&gt; r -&gt; b</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Monad</span> ((-&gt;) r) <span class="keyword">where</span></span></span><br><span class="line">    return x = \_ -&gt; x</span><br><span class="line">    h &gt;&gt;= f = \w -&gt; f (h w) w</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>
<p><a href="https://github.com/MostlyAdequate/mostly-adequate-guide" target="_blank" rel="noopener">《JS 函数式编程指南》</a>：</p>
<ol>
<li><a href="https://llh911001.gitbooks.io/mostly-adequate-guide-chinese/content/ch10.html" target="_blank" rel="noopener">第 10 章: Applicative Functor</a></li>
<li><a href="https://llh911001.gitbooks.io/mostly-adequate-guide-chinese/content/ch10.html#lift" target="_blank" rel="noopener">第 10 章: Applicative Functor lift</a></li>
</ol>
</li>
<li>
<p>stackoverflow: function as Functor/Applicative Functor/Monad：</p>
<ol>
<li><a href="https://stackoverflow.com/questions/10294272/confused-about-function-as-instance-of-functor-in-haskell" target="_blank" rel="noopener">confused about function as instance of Functor in haskell</a></li>
<li><a href="https://stackoverflow.com/questions/11810889/functions-as-applicative-functors-haskell-lyah" target="_blank" rel="noopener">functions as applicative functors (Haskell / LYAH)</a></li>
<li><a href="https://stackoverflow.com/questions/13080014/function-as-an-instance-of-monad" target="_blank" rel="noopener">Function as an Instance of Monad</a></li>
</ol>
</li>
<li>
<p><a href="http://www.tomharding.me/2017/04/15/functions-as-functors/" target="_blank" rel="noopener">Functions as Functors</a></p>
</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://adispring.github.io/2017/10/15/Haskell-Type-and-TypeClass/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="wangzengdi">
      <meta itemprop="description" content="FE@Meituan.com">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="wangzengdi's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2017/10/15/Haskell-Type-and-TypeClass/" class="post-title-link" itemprop="url">Haskell: Type and TypeClass</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2017-10-15 11:52:43" itemprop="dateCreated datePublished" datetime="2017-10-15T11:52:43+00:00">2017-10-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-07-25 10:51:10" itemprop="dateModified" datetime="2021-07-25T10:51:10+00:00">2021-07-25</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Haskell/" itemprop="url" rel="index"><span itemprop="name">Haskell</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>What are typeclasses?</p>
<p>Typeclasses define a set of functions that can have different implementations depending on the type of data they are given.</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">wangzengdi</p>
  <div class="site-description" itemprop="description">FE@Meituan.com</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">31</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">1</span>
        <span class="site-state-item-name">tags</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">wangzengdi</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script>
<script src="/js/schemes/muse.js"></script>
<script src="/js/next-boot.js"></script>



  















  

  

</body>
</html>
