<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 3.9.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.ico">
  <link rel="icon" type="image/png" sizes="32x32" href="/favicon.ico">
  <link rel="icon" type="image/png" sizes="16x16" href="/favicon.ico">
  <link rel="mask-icon" href="/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"adispring.github.io","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="FE@Meituan.com">
<meta property="og:type" content="website">
<meta property="og:title" content="wangzengdi&#39;s Blog">
<meta property="og:url" content="https://adispring.github.io/page/3/index.html">
<meta property="og:site_name" content="wangzengdi&#39;s Blog">
<meta property="og:description" content="FE@Meituan.com">
<meta property="og:locale" content="en">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="wangzengdi&#39;s Blog">
<meta name="twitter:description" content="FE@Meituan.com">

<link rel="canonical" href="https://adispring.github.io/page/3/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en'
  };
</script>

  <title>wangzengdi's Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">wangzengdi's Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">Functional Programming</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://adispring.github.io/2017/06/18/Thinking-in-Ramda-Lenses/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="wangzengdi">
      <meta itemprop="description" content="FE@Meituan.com">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="wangzengdi's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2017/06/18/Thinking-in-Ramda-Lenses/" class="post-title-link" itemprop="url">Thinking in Ramda: 透镜（Lenses）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2017-06-18 07:27:42" itemprop="dateCreated datePublished" datetime="2017-06-18T07:27:42+00:00">2017-06-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-11-18 08:07:49" itemprop="dateModified" datetime="2021-11-18T08:07:49+00:00">2021-11-18</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Thinking-in-Ramda/" itemprop="url" rel="index"><span itemprop="name">Thinking in Ramda</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>译者注：本文翻译自 Randy Coulman 的 《<a href="http://randycoulman.com/blog/2016/07/12/thinking-in-ramda-lenses/" target="_blank" rel="noopener">Thinking in Ramda: Lenses</a>》，转载请与<a href="https://github.com/randycoulman" target="_blank" rel="noopener">原作者</a>或<a href="https://github.com/adispring" target="_blank" rel="noopener">本人</a>联系。下面开始正文。</p>
<hr>
<p>本文是函数式编程系列文章：<a href="https://adispring.coding.me/categories/Thinking-in-Ramda/" target="_blank" rel="noopener">Thinking in Ramda</a> 的第八篇。</p>
<p>在 <a href="https://adispring.coding.me/2017/06/16/Thinking-in-Ramda-Immutability-and-Objects/" target="_blank" rel="noopener">第六节</a>  和 <a href="https://adispring.coding.me/2017/06/17/Thinking-in-Ramda-Immutability-and-Arrays/" target="_blank" rel="noopener">第七节</a> 中，我们学习了如何以声明式和不变式来读取、更新和转换对象的属性和数组的元素。</p>
<p>Ramda 提供了一个更通用的工具：透镜（lens），来进行这些操作。</p>
<h2 id="shi-yao-shi-tou-jing">什么是透镜？</h2>
<p>透镜将 “getter” 和 “setter” 函数组合为一个单一模块。Ramda 提供了一系列配合透镜一起工作的函数。</p>
<p>可以将透镜视为对某些较大数据结构的特定部分的聚焦、关注。</p>
<h2 id="ru-he-chuang-jian-tou-jing">如何创建透镜</h2>
<p>在 Ramda 中，最常见的创建透镜的方法是 <code>lens</code> 函数。<code>lens</code> 接受一个 “getter” 函数和一个 “setter” 函数，然后返回一个新透镜。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">  name: <span class="string">'Randy'</span>,</span><br><span class="line">  socialMedia: &#123;</span><br><span class="line">    github: <span class="string">'randycoulman'</span>,</span><br><span class="line">    twitter: <span class="string">'@randycoulman'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> nameLens = lens(prop(<span class="string">'name'</span>), assoc(<span class="string">'name'</span>))</span><br><span class="line"><span class="keyword">const</span> twitterLens = lens(</span><br><span class="line">  path([<span class="string">'socialMedia'</span>, <span class="string">'twitter'</span>]),</span><br><span class="line">  assocPath([<span class="string">'socialMedia'</span>, <span class="string">'twitter'</span>])</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>这里使用 <code>prop</code> 和 <code>path</code> 作为 “getter” 方法；<code>assoc</code> 和 <code>assocPath</code> 作为 “setter” 方法。</p>
<p>注意，上面实现不得不重复传递属性和路径参数给 “getter” 和 “setter” 方法。幸运的是，Ramda 为最常见类型的透镜提供了便捷方法：<code>lensProp</code>、<code>lensPath</code> 和 <code>lensIndex</code>。</p>
<ul>
<li><code>LensProp</code>：创建关注对象某一属性的透镜。</li>
<li><code>lensPath</code>: 创建关注对象某一嵌套属性的透镜。</li>
<li><code>lensIndex</code>: 创建关注数组某一索引的透镜。</li>
</ul>
<p>可以用 <code>lensProp</code> 和 <code>lensPath</code> 来重写上述示例：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> nameLens = lensProp(<span class="string">'name'</span>)</span><br><span class="line"><span class="keyword">const</span> twitterLens = lensPath([<span class="string">'socialMedia'</span>, <span class="string">'twitter'</span>])</span><br></pre></td></tr></table></figure>
<p>这样便摆脱了向 “getter” 和 “setter” 重复输入两次相同参数的烦扰，变得简洁多了。在实际工作中，我发现我几乎从来不需要使用通用的 <code>lens</code> 函数。</p>
<h2 id="wo-neng-yong-ta-zuo-shi-yao-ni">我能用它做什么呢？</h2>
<p>我们创建了一些透镜，可以用它们做些什么呢？</p>
<p>Ramda 提供了三个配合透镜一起使用的的函数：</p>
<ul>
<li><code>view</code>：读取透镜的值。</li>
<li><code>set</code>：更新透镜的值。</li>
<li><code>over</code>：将变换函数作用于透镜。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">view(nameLens, person) <span class="comment">// =&gt; 'Randy'</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">set</span>(twitterLens, '@randy', person)</span><br><span class="line">// =&gt; &#123;</span><br><span class="line"><span class="comment">//   name: 'Randy',</span></span><br><span class="line"><span class="comment">//   socialMedia: &#123;</span></span><br><span class="line"><span class="comment">//     github: 'randycoulman',</span></span><br><span class="line"><span class="comment">//     twitter: '@randy'</span></span><br><span class="line"><span class="comment">//   &#125;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"> </span><br><span class="line">over(nameLens, toUpper, person)</span><br><span class="line"><span class="comment">// =&gt; &#123;</span></span><br><span class="line"><span class="comment">//   name: 'RANDY',</span></span><br><span class="line"><span class="comment">//   socialMedia: &#123;</span></span><br><span class="line"><span class="comment">//     github: 'randycoulman',</span></span><br><span class="line"><span class="comment">//     twitter: '@randycoulman'</span></span><br><span class="line"><span class="comment">//   &#125;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure>
<p>注意，<code>set</code> 和 <code>over</code> 会按指定的方式对被透镜关注的属性进行修改，并返回整个新的对象。</p>
<h2 id="jie-lun">结论</h2>
<p>如果想从复杂数据结构的操作中抽象出简单、通用的方法，透镜可以提供很多帮助。我们只需暴露透镜；而不需要暴露整个数据结构、或者为每个可访问属性都提供 “setter”、“getter” 和 变换方法。</p>
<h2 id="xia-yi-jie">下一节</h2>
<p>我们现在已经了解了许多 Ramda 提供的方法，已经足以应对大部分编程需要。<a href="https://adispring.coding.me/2017/06/18/Thinking-in-Ramda-Wrap-Up/" target="_blank" rel="noopener">总结</a> 将回顾整个系列的内容，并会提到一些可能需要自己进一步探索的其他主题。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://adispring.github.io/2017/06/17/Thinking-in-Ramda-Immutability-and-Arrays/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="wangzengdi">
      <meta itemprop="description" content="FE@Meituan.com">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="wangzengdi's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2017/06/17/Thinking-in-Ramda-Immutability-and-Arrays/" class="post-title-link" itemprop="url">Thinking in Ramda: 数据不变性和数组</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2017-06-17 22:21:48" itemprop="dateCreated datePublished" datetime="2017-06-17T22:21:48+00:00">2017-06-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-11-18 08:07:49" itemprop="dateModified" datetime="2021-11-18T08:07:49+00:00">2021-11-18</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Thinking-in-Ramda/" itemprop="url" rel="index"><span itemprop="name">Thinking in Ramda</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>译者注：本文翻译自 Randy Coulman 的 《<a href="http://randycoulman.com/blog/2016/07/05/thinking-in-ramda-immutability-and-arrays/" target="_blank" rel="noopener">Thinking in Ramda: Immutability and Arrays</a>》，转载请与<a href="https://github.com/randycoulman" target="_blank" rel="noopener">原作者</a>或<a href="https://github.com/adispring" target="_blank" rel="noopener">本人</a>联系。下面开始正文。</p>
<hr>
<p>本文是函数式编程系列文章：<a href="https://adispring.coding.me/categories/Thinking-in-Ramda/" target="_blank" rel="noopener">Thinking in Ramda</a> 的第七篇。</p>
<p>在 <a href="https://adispring.coding.me/2017/06/16/Thinking-in-Ramda-Immutability-and-Objects/" target="_blank" rel="noopener">第六节</a> 中，讨论了以函数式和数据不变性（immutable）的方式来处理 JavaScript 对象。</p>
<p>本节将继续用相同的方式讨论数组。</p>
<h2 id="du-qu-shu-zu-yuan-su">读取数组元素</h2>
<p>在 <a href="https://adispring.coding.me/2017/06/16/Thinking-in-Ramda-Immutability-and-Objects/" target="_blank" rel="noopener">第六节</a> 中，展示了许多读取对象属性的 Ramda 函数，包括 <code>prop</code>、<code>pick</code> 和 <code>has</code>。Ramda 有更多的方法来读取数组的元素。</p>
<p>数组中与 <code>prop</code> 类似的是 <code>nth</code>；与 <code>pick</code> 类似的是 <code>slice</code>，跟 <code>has</code> 类似的是 <code>contains</code>。来看一些例子。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> numbers = [<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>, <span class="number">60</span>]</span><br><span class="line"> </span><br><span class="line">nth(<span class="number">3</span>, numbers) <span class="comment">// =&gt; 40  (0-based indexing)</span></span><br><span class="line"> </span><br><span class="line">nth(<span class="number">-2</span>, numbers) <span class="comment">// =&gt; 50 (negative numbers start from the right)</span></span><br><span class="line"> </span><br><span class="line">slice(<span class="number">2</span>, <span class="number">5</span>, numbers) <span class="comment">// =&gt; [30, 40, 50] (see below)</span></span><br><span class="line"> </span><br><span class="line">contains(<span class="number">20</span>, numbers) <span class="comment">// =&gt; true</span></span><br></pre></td></tr></table></figure>
<p><code>slice</code> 接受两个索引，返回从第 1 个索引开始（以 0 为起始）到第 2 个索引结束（不包含）的所有元素组成的子数组。</p>
<p>经常会访问首个（<code>nth(0)</code>）和最后一个（<code>nth(-1)</code>）元素，所以 Ramda 为这两种特殊情形提供的便捷方法：<code>head</code> 和 <code>last</code>。还提供了访问除首个元素之外的所有元素的函数：<code>tail</code>，除最后一个元素之外的所有元素的方法：<code>init</code>，前 <code>N</code> 个元素：<code>take(N)</code>，后 <code>N</code> 个元素：<code>takeLast(N)</code>。来看看这些函数的实例。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> numbers = [<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>, <span class="number">60</span>]</span><br><span class="line"> </span><br><span class="line">head(numbers) <span class="comment">// =&gt; 10</span></span><br><span class="line">tail(numbers) <span class="comment">// =&gt; [20, 30, 40, 50, 60]</span></span><br><span class="line"> </span><br><span class="line">last(numbers) <span class="comment">// =&gt; 60</span></span><br><span class="line">init(numbers) <span class="comment">// =&gt; [10, 20, 30, 40, 50]</span></span><br><span class="line"> </span><br><span class="line">take(<span class="number">3</span>, numbers) <span class="comment">// =&gt; [10, 20, 30]</span></span><br><span class="line">takeLast(<span class="number">3</span>, numbers) <span class="comment">// =&gt; [40, 50, 60]</span></span><br></pre></td></tr></table></figure>
<h2 id="zeng-shan-gai-shu-zu-yuan-su">增、删、改数组元素</h2>
<p>对于对象，我们已经学了对其属性进行增、删、改的函数：<code>assoc</code>、<code>dissoc</code>、<code>evolve</code> 等。</p>
<p>但数组是有序数据结构，有好多函数与 <code>assoc</code> 类似。最常用的是 <code>insert</code> 和 <code>update</code>，Ramda 还提供了 <code>append</code> 和 <code>prepend</code> 来在数组头部或尾部添加元素。<code>insert</code>、<code>append</code> 和 <code>prepend</code> 会给数组添加新元素；<code>update</code> 使用新值替换已有元素。</p>
<p>正如一般函数式库应该具备的，所有这些函数都返回修改后的新数组，原有数组保持不变。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> numbers = [<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>, <span class="number">60</span>]</span><br><span class="line"> </span><br><span class="line">insert(<span class="number">3</span>, <span class="number">35</span>, numbers) <span class="comment">// =&gt; [10, 20, 30, 35, 40, 50, 60]</span></span><br><span class="line"> </span><br><span class="line">append(<span class="number">70</span>, numbers) <span class="comment">// =&gt; [10, 20, 30, 40, 50, 60, 70]</span></span><br><span class="line"> </span><br><span class="line">prepend(<span class="number">0</span>, numbers) <span class="comment">// =&gt; [0, 10, 20, 30, 40, 50, 60]</span></span><br><span class="line"> </span><br><span class="line">update(<span class="number">1</span>, <span class="number">15</span>, numbers) <span class="comment">// =&gt; [10, 15, 30, 40, 50, 60]</span></span><br></pre></td></tr></table></figure>
<p>为了将两个对象合并为一个，我们学习了 <code>merge</code>；Ramda 为数组合并提供了 <code>concat</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> numbers = [<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>, <span class="number">60</span>]</span><br><span class="line"> </span><br><span class="line">concat(numbers, [<span class="number">70</span>, <span class="number">80</span>, <span class="number">90</span>]) <span class="comment">// =&gt; [10, 20, 30, 40, 50, 60, 70, 80, 90]</span></span><br></pre></td></tr></table></figure>
<p>注意，第二个数组添加到第一个数组之后。当单独使用 <code>concat</code> 时，可以很好的工作；但类似于 <code>merge</code>，在 pipeline 中可能并不像预期的那样工作。可以为在 pipeline 中使用定义一个辅助函数 <code>concatAfter</code>：<code>const concatAfter = flip(concat)</code>。</p>
<p>Ramda 还提供了几个删除元素的函数。<code>remove</code> 删除指定索引处的元素，<code>without</code> 通过值删除元素。还有常用到的删除前 <code>N</code> 或 后 <code>N</code> 个元素的函数：<code>drop</code> 和 <code>dropLast</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> numbers = [<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>, <span class="number">60</span>]</span><br><span class="line"> </span><br><span class="line">remove(<span class="number">2</span>, <span class="number">3</span>, numbers) <span class="comment">// =&gt; [10, 20, 60]</span></span><br><span class="line"> </span><br><span class="line">without([<span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>], numbers) <span class="comment">// =&gt; [10, 20, 60]</span></span><br><span class="line"> </span><br><span class="line">drop(<span class="number">3</span>, numbers) <span class="comment">// =&gt; [40, 50, 60]</span></span><br><span class="line"> </span><br><span class="line">dropLast(<span class="number">3</span>, numbers) <span class="comment">// =&gt; [10, 20, 30]</span></span><br></pre></td></tr></table></figure>
<p>注意，<code>remove</code> 接受一个索引和一个删除元素的数量，而 <code>slice</code> 接受两个索引。如果你不知道这种不一致，可能会造成使用上的困扰。</p>
<h2 id="bian-huan-yuan-su">变换元素</h2>
<p>与对象一样，我们可能希望通过将函数应用于元素的原始值来更新数组元素。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> numbers = [<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>, <span class="number">60</span>]</span><br><span class="line"> </span><br><span class="line">update(<span class="number">2</span>, multiply(<span class="number">10</span>, nth(<span class="number">2</span>, numbers)), numbers) <span class="comment">// =&gt; [10, 20, 300, 40, 50, 60]</span></span><br></pre></td></tr></table></figure>
<p>为了简化这个常见的用例， Ramda 提供了 <code>adjust</code>，其工作方式类似于操作对象的 <code>evolve</code>。与 <code>evolve</code> 不同的是， <code>adjust</code> 只能作用于数组的单个元素。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> numbers = [<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>, <span class="number">60</span>]</span><br><span class="line"> </span><br><span class="line">adjust(multiply(<span class="number">10</span>), <span class="number">2</span>, numbers)</span><br></pre></td></tr></table></figure>
<p>注意，与 <code>update</code> 相比，<code>adjust</code> 将前两个参数的位置交换了一下。这可能会引起困扰，但当进行部分应用时，这样做还是很有道理的。你可能会先提供一个调整函数，比如 <code>adjust(multiply(10))</code> ，然后再决定要调整的索引和数组。</p>
<h2 id="jie-lun">结论</h2>
<p>我们现在有了以声明式和不变式操作对象和数组的一系列方法。这允许我们在不改变已有数据的情况下，从较小的、函数式的构建模块来构建程序，通过对函数进行组合来实现我们想要的功能。</p>
<h2 id="xia-yi-jie">下一节</h2>
<p>我们学习了读取、更新和转换对象属性和数组元素的方法。Ramda 提供了更通用的进行这些操作的工具：lens（透镜）。<a href="https://adispring.coding.me/2017/06/18/Thinking-in-Ramda-Lenses/" target="_blank" rel="noopener">Lenses</a> 向我们演示了它们的工作原理和方式。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://adispring.github.io/2017/06/16/Thinking-in-Ramda-Immutability-and-Objects/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="wangzengdi">
      <meta itemprop="description" content="FE@Meituan.com">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="wangzengdi's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2017/06/16/Thinking-in-Ramda-Immutability-and-Objects/" class="post-title-link" itemprop="url">Thinking in Ramda: 数据不变性和对象</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2017-06-16 23:00:08" itemprop="dateCreated datePublished" datetime="2017-06-16T23:00:08+00:00">2017-06-16</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-11-18 08:07:49" itemprop="dateModified" datetime="2021-11-18T08:07:49+00:00">2021-11-18</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Thinking-in-Ramda/" itemprop="url" rel="index"><span itemprop="name">Thinking in Ramda</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>译者注：本文翻译自 Randy Coulman 的 《<a href="http://randycoulman.com/blog/2016/06/28/thinking-in-ramda-immutability-and-objects/" target="_blank" rel="noopener">Thinking in Ramda: Immutability and Objects</a>》，转载请与<a href="https://github.com/randycoulman" target="_blank" rel="noopener">原作者</a>或<a href="https://github.com/adispring" target="_blank" rel="noopener">本人</a>联系。下面开始正文。</p>
<hr>
<p>本文是函数式编程系列文章：<a href="https://adispring.coding.me/categories/Thinking-in-Ramda/" target="_blank" rel="noopener">Thinking in Ramda</a> 的第六篇。</p>
<p>在 <a href="https://adispring.coding.me/2017/06/13/Thinking-in-Ramda-Pointfree-Style/" target="_blank" rel="noopener">第五节</a> 中，我们讨论了如何以 “pointfree” 或 “tacit” 风格来编写函数：函数的参数不会显式的出现。</p>
<p>那时候，因为缺少一些工具，我们还无法将所有的函数转换为 “pointfree” 的风格。现在我们就来学习这些工具。</p>
<h2 id="du-qu-dui-xiang-shu-xing">读取对象属性</h2>
<p>再来回顾一下 <a href="https://adispring.coding.me/2017/06/13/Thinking-in-Ramda-Pointfree-Style/" target="_blank" rel="noopener">第五节</a> 已经重构过的 “合格选民” 的例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> wasBornInCountry = <span class="function"><span class="params">person</span> =&gt;</span> person.birthCountry === OUR_COUNTRY</span><br><span class="line"><span class="keyword">const</span> wasNaturalized = <span class="function"><span class="params">person</span> =&gt;</span> <span class="built_in">Boolean</span>(person.naturalizationDate)</span><br><span class="line"><span class="keyword">const</span> isOver18 = <span class="function"><span class="params">person</span> =&gt;</span> person.age &gt;= <span class="number">18</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> isCitizen = either(wasBornInCountry, wasNaturalized)</span><br><span class="line"><span class="keyword">const</span> isEligibleToVote = both(isOver18, isCitizen)</span><br></pre></td></tr></table></figure>
<p>如上所示，我们已经将 <code>isCitizen</code> 和 <code>isEligibleToVote</code> 变为 “pointfree” 风格的了，但前三个函数还没有 “pointfree” 化。</p>
<p>正如 <a href="https://adispring.coding.me/2017/06/11/Thinking-in-Ramda-Declarative-Programming/" target="_blank" rel="noopener">第四节</a> 所学，可以使用 <code>equals</code> 和 <code>gte</code> 来让函数更 “声明式” 一些。我们就此开始：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> wasBornInCountry = <span class="function"><span class="params">person</span> =&gt;</span> equals(person.birthCountry, OUR_COUNTRY)</span><br><span class="line"><span class="keyword">const</span> wasNaturalized = <span class="function"><span class="params">person</span> =&gt;</span> <span class="built_in">Boolean</span>(person.naturalizationDate)</span><br><span class="line"><span class="keyword">const</span> isOver18 = <span class="function"><span class="params">person</span> =&gt;</span> gte(person.age, <span class="number">18</span>)</span><br></pre></td></tr></table></figure>
<p>为了让这些函数变为 “pointfree” 的，需要一种方法来使构建出来的函数的 <code>person</code> 参数排在参数列表的最后。问题是，我们需要访问 <code>person</code> 的属性，现有唯一的方法却是命令式的。</p>
<h2 id="prop">prop</h2>
<p>幸运的是， Ramda 为我们提供了访问对象属性的辅助函数：<code>prop</code>。</p>
<p>使用 <code>prop</code>，可以将 <code>person.birthCountry</code> 转换为 <code>prop('birthCountry', person)</code>。现在来试试。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> wasBornInCountry = <span class="function"><span class="params">person</span> =&gt;</span> equals(prop(<span class="string">'birthCountry'</span>, person), OUR_COUNTRY)</span><br><span class="line"><span class="keyword">const</span> wasNaturalized = <span class="function"><span class="params">person</span> =&gt;</span> <span class="built_in">Boolean</span>(prop(<span class="string">'naturalizationDate'</span>, person))</span><br><span class="line"><span class="keyword">const</span> isOver18 = <span class="function"><span class="params">person</span> =&gt;</span> gte(prop(<span class="string">'age'</span>, person), <span class="number">18</span>)</span><br></pre></td></tr></table></figure>
<p>哇！现在看起来更糟了，还需要继续重构。首先，需要交换传递给 <code>equals</code> 的参数的顺序，这样可以将 <code>prop</code> 放到最后。<code>equals</code> 在任意顺序下都能正常工作。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> wasBornInCountry = <span class="function"><span class="params">person</span> =&gt;</span> equals(OUR_COUNTRY, prop(<span class="string">'birthCountry'</span>, person))</span><br><span class="line"><span class="keyword">const</span> wasNaturalized = <span class="function"><span class="params">person</span> =&gt;</span> <span class="built_in">Boolean</span>(prop(<span class="string">'naturalizationDate'</span>, person))</span><br><span class="line"><span class="keyword">const</span> isOver18 = <span class="function"><span class="params">person</span> =&gt;</span> gte(prop(<span class="string">'age'</span>, person), <span class="number">18</span>)</span><br></pre></td></tr></table></figure>
<p>接下来，使用 <code>equals</code> 和 <code>gte</code> 的柯里化特性来创建新函数，新函数可以作用于 <code>prop</code> 输出的结果上。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> wasBornInCountry = <span class="function"><span class="params">person</span> =&gt;</span> equals(OUR_COUNTRY)(prop(<span class="string">'birthCountry'</span>, person))</span><br><span class="line"><span class="keyword">const</span> wasNaturalized = <span class="function"><span class="params">person</span> =&gt;</span> <span class="built_in">Boolean</span>(prop(<span class="string">'naturalizationDate'</span>, person))</span><br><span class="line"><span class="keyword">const</span> isOver18 = <span class="function"><span class="params">person</span> =&gt;</span> gte(__, <span class="number">18</span>)(prop(<span class="string">'age'</span>, person))</span><br></pre></td></tr></table></figure>
<p>还是不太好，还需要继续优化。我们继续利用柯里化的特性来优化 <code>prop</code> 的调用。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> wasBornInCountry = <span class="function"><span class="params">person</span> =&gt;</span> equals(OUR_COUNTRY)(prop(<span class="string">'birthCountry'</span>)(person))</span><br><span class="line"><span class="keyword">const</span> wasNaturalized = <span class="function"><span class="params">person</span> =&gt;</span> <span class="built_in">Boolean</span>(prop(<span class="string">'naturalizationDate'</span>)(person))</span><br><span class="line"><span class="keyword">const</span> isOver18 = <span class="function"><span class="params">person</span> =&gt;</span> gte(__, <span class="number">18</span>)(prop(<span class="string">'age'</span>)(person))</span><br></pre></td></tr></table></figure>
<p>又变糟了。但现在我们看到了一种熟悉的模式，所有的三个函数都具有相同的形式：<code>g(f(person))</code>。由 <a href="https://adispring.coding.me/2017/06/10/Thinking-in-Ramda-Combining-Functions" target="_blank" rel="noopener">第二节</a> 可知，这等价于 <code>compose(g, f)(person)</code>。</p>
<p>我们来利用这一点。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> wasBornInCountry = <span class="function"><span class="params">person</span> =&gt;</span> compose(equals(OUR_COUNTRY), prop(<span class="string">'birthCountry'</span>))(person)</span><br><span class="line"><span class="keyword">const</span> wasNaturalized = <span class="function"><span class="params">person</span> =&gt;</span> compose(<span class="built_in">Boolean</span>, prop(<span class="string">'naturalizationDate'</span>))(person)</span><br><span class="line"><span class="keyword">const</span> isOver18 = <span class="function"><span class="params">person</span> =&gt;</span> compose(gte(__, <span class="number">18</span>), prop(<span class="string">'age'</span>))(person)</span><br></pre></td></tr></table></figure>
<p>现在好一些了，三个函数的形式变成了 <code>person =&gt; f(person)</code>。由 <a href="https://adispring.coding.me/2017/06/13/Thinking-in-Ramda-Pointfree-Style" target="_blank" rel="noopener">第五节</a> 可知，现在可以将这三个函数写成 “pointfree” 的了。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> wasBornInCountry = compose(equals(OUR_COUNTRY), prop(<span class="string">'birthCountry'</span>))</span><br><span class="line"><span class="keyword">const</span> wasNaturalized = compose(<span class="built_in">Boolean</span>, prop(<span class="string">'naturalizationDate'</span>))</span><br><span class="line"><span class="keyword">const</span> isOver18 = compose(gte(__, <span class="number">18</span>), prop(<span class="string">'age'</span>))</span><br></pre></td></tr></table></figure>
<p>未重构前，并不能明显看出我们的方法是在做两件事情。它们都先访问对象的属性，然后对该属性的值进行一些操作。重构为 “pointfree” 风格后，程序的表意变得清晰了许多。</p>
<p>我们来展示更多 Ramda 处理对象的函数。</p>
<h2 id="pick">pick</h2>
<p><code>prop</code> 用来读取并返回对象的单个属性，而 <code>pick</code> 读取对象的多个属性，然后返回有这些属性组成的新对象。</p>
<p>例如，如果想同时获取一个人的名字和年龄，可以使用：<code>pick(['name', 'age'], person)</code>。</p>
<h2 id="has">has</h2>
<p>在不读取属性值的情况下，想知道对象中是否包含该属性，可以使用 <code>has</code> 来检测对象是否拥有该属性，如 <code>has('name' ,person)</code>；还可以使用 <code>hasIn</code> 来检测原型链上的属性。</p>
<h2 id="path">path</h2>
<p><code>prop</code> 用来读取对象的属性，<code>path</code> 可以读取对象的嵌套属性。例如，我们可以从更深层的结构中访问邮编：<code>path(['address', 'zipCode'], person)</code>。</p>
<p>注意，<code>path</code> 容错性更强。如果路径上的任意属性为 <code>null</code> 或 <code>undefined</code>，则 <code>path</code> 返回 <code>undefined</code>，而 <code>prop</code> 会引发错误。</p>
<h2 id="prop-or-path-or">propOr / pathOr</h2>
<p><code>propOr</code> 和 <code>pathOr</code> 像是 <code>prop</code>/<code>path</code> 与 <code>defaultTo</code> 的组合。如果在目标对象中找不到属性或路径的值，它们允许你提供默认值。</p>
<p>例如，当我们不知道某人的姓名时，可以提供一个占位符：<code>propOr('&lt;Unnamed&gt;', 'name', person)</code>。注意，与 <code>prop</code> 不同，如果 <code>person</code> 为 <code>null</code> 或 <code>undefined</code> 时，<code>propOr</code> 不会引发错误，而是会返回一个默认值。</p>
<h2 id="keys-values">keys / values</h2>
<p><code>keys</code> 返回一个包含对象中所有属性名称的数组。<code>values</code> 返回这些属性的值组成的数组。当与 <a href="https://adispring.coding.me/2017/06/09/Thinking-in-Ramda-%E5%85%A5%E9%97%A8" target="_blank" rel="noopener">第一节</a> 中提到集合迭代函数结合使用时，这两个函数会非常有用。</p>
<h2 id="dui-shu-xing-zeng-shan-gai-cha">对属性增、删、改、查</h2>
<p>现在已经有很多对对象进行声明式读取的函数，但如果想要进行更改操作呢？</p>
<p>由于数据不变性很重要，我们不想直接更改对象。相反，我们想要更改后形成的新对象。</p>
<p>Ramda 再次为我们提供了很多辅助函数。</p>
<h2 id="assoc-assoc-path">assoc / assocPath</h2>
<p>在命令式编程时，可以使用赋值操作符设置或更改一个人的名字：<code>person.name = 'New name'</code>。</p>
<p>在函数式、数据不变的世界里，可以使用 <code>assoc</code> 来代替：<code>const updatedPerson = assoc('name', 'New name', person)</code>。</p>
<p><code>assoc</code> 返回一个添加或修改属性的新对象，原对象保持不变。</p>
<p>还有用于更新嵌套属性的方法：<code>assocPath</code>：<code>const updatedPerson = assocPath(['address', 'zipcode'], '97504', person)</code>。</p>
<h2 id="dissoc-dissoc-path-omit">dissoc / dissocPath / omit</h2>
<p>如何删除属性呢？我们可能想删除 <code>person.age</code> 。在 Ramda 中，可以使用 <code>dissoc</code>：<code>const updatedPerson = dissoc('age', person)</code>。</p>
<p><code>dissocPath</code> 类似于 <code>dissoc</code>，但可以作用于对象的嵌套属性：<code>dissocPath(['address', 'zipCode'], person)</code>。</p>
<p>还有一个 <code>omit</code>，用于一次删除多个属性。<code>const updatedPerson = omit(['age', 'birthCountry'], person)</code>。</p>
<p>注意，<code>pick</code> 与 <code>omit</code> 的操作很像，两者是互补的关系。它们能辅助实现白名单（使用 <code>pick</code> 保留想要的属性集）和黑名单（使用 <code>omit</code> 删除不想要的属性集）的功能。</p>
<h2 id="shu-xing-zhuan-huan">属性转换</h2>
<p>我们现在已经知道如何利用声明式和数据不变性的方式来处理对象。我们来写一个函数：<code>celebrateBirthday</code>，在生日当前更新他的年龄。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> nextAge = compose(inc, prop(<span class="string">'age'</span>))</span><br><span class="line"><span class="keyword">const</span> celebrateBirthday = <span class="function"><span class="params">person</span> =&gt;</span> assoc(<span class="string">'age'</span>, nextAge(person), person)</span><br></pre></td></tr></table></figure>
<p>这是一种很常见的模式。如上所示，我们并不想用给定的新值覆盖已有属性值，而是想通过函数作用于属性的旧值来对其进行转换。</p>
<p>就目前已知的方法，我尚未找到一种以更少重复代码和 pointfree 的形式来优化该段代码的方式。</p>
<p>Ramda 使用 <code>evolve</code> 方法再次拯救了我们。我在 <a href="http://randycoulman.com/blog/2016/02/16/using-ramda-with-redux/" target="_blank" rel="noopener">之前的文章</a> 中也提到过 <code>evolve</code>。</p>
<p><code>evolve</code> 接受一个对象，其中包含对每个需要转换属性的转换函数。我们来使用 <code>evolve</code> 来重构 <code>celebrateBirthday</code>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> celebrateBirthday = evolve(&#123; <span class="attr">age</span>: inc &#125;)</span><br></pre></td></tr></table></figure>
<p>这段代码通过将 <code>evolve</code> 参数对象属性对应的函数作用于被变换对象相同属性值上，来转换已有对象的属性。本例中使用 <code>inc</code> 对 <code>person</code> 的 <code>age</code> 属性进行加 1 操作，并返回 <code>age</code> 更新后的新 <code>person</code> 对象。</p>
<p><code>evolve</code> 可以一次转换多个属性，还可以进行嵌套转换。“转换函数对象”（包含转换函数的对象）与被转换对象具有基本相同的结构，<code>evolve</code> 会递归地遍历这两个对象，然后将转换函数作用于对应的属性值上。</p>
<p>注意，<code>evolve</code> 不会添加新属性，如果为目标对象不存在的属性指定转换函数，<code>evolve</code> 会将其忽略。</p>
<p><code>evolve</code> 已经很快成为我编程时的主力。</p>
<h2 id="he-bing-dui-xiang">合并对象</h2>
<p>有时，需要合并两个对象。一种常见的情形是当使用含有 “options” 配置项的函数时，常常需要将这些配置项与一组默认配置项进行组合。Ramda 为此提供了 <code>merge</code> 方法。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">a, b, options = &#123;&#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> defaultOptions = &#123; <span class="attr">value</span>: <span class="number">42</span>, <span class="attr">local</span>: <span class="literal">true</span> &#125;</span><br><span class="line">  <span class="keyword">const</span> finalOptions = merge(defaultOptions, options)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>merge</code> 返回一个包含两个对象的所有属性和值的新对象。如果两个对象具有相同的属性，则采用第二个对象参数的属性值。</p>
<p>在单独使用 <code>merge</code> 时，采用第二个参数的属性值作为最终值是非常有用的；但在 pipeline 中可能没什么用。在 pipeline 中，通常会对一个对象进行一系列转换，其中一个转换是合并一些新的属性值到对象中。这种情况，可能需要第一个参数中的属性值作为最终值。</p>
<p>如果只是在 pipeline 中简单地使用 <code>merge(newValues)</code>，可能不会得到你想要的结果。</p>
<p>对于这种情况，我通常会定义一个辅助函数 <code>reverseMerge</code>：<code>const reverseMerge = flip(merge)</code>。回想一下，<code>flip</code> 会翻转函数前两个参数的位置。</p>
<p><code>merge</code> 执行的是浅合并。如果被合并的对象存在属性值为对象的属性，子对象并不会继续嵌套合并。如果想递归地进行 “深合并”，可以使用 Ramda 的 <code>mergeDeep</code> 系列函数。（译者注：作者在写这篇文章时，Ramda 还没有 <code>mergeDeep</code> 系列函数，<code>mergeDeep</code> 系列函数是在 v0.24.0 中加入的）</p>
<p>注意，<code>merge</code> 只接受两个参数。如果想要将多个对象合并为一个对象，可以使用 <code>mergeAll</code>，它接受一个需要被合并对象的数组作为参数。</p>
<h2 id="jie-lun">结论</h2>
<p>本文展示了 Ramda 中一系列很好的以声明式和数据不变方式处理对象的方法。我们现在可以对对象进行增、删、改、查，而不会改变原有的对象。并且也可以在组合函数时使用这些方法来做这些事情。</p>
<h2 id="xia-yi-jie">下一节</h2>
<p>现在可以以 Immutable 的方式处理对象，那么数组呢？<a href="https://adispring.coding.me/2017/06/17/Thinking-in-Ramda-Immutability-and-Arrays/" target="_blank" rel="noopener">数据不变性和数组</a> 将演示对数组的处理。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://adispring.github.io/2017/06/13/Thinking-in-Ramda-Pointfree-Style/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="wangzengdi">
      <meta itemprop="description" content="FE@Meituan.com">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="wangzengdi's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2017/06/13/Thinking-in-Ramda-Pointfree-Style/" class="post-title-link" itemprop="url">Thinking in Ramda: 无参数风格编程 (Pointfree Style)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2017-06-13 21:27:05" itemprop="dateCreated datePublished" datetime="2017-06-13T21:27:05+00:00">2017-06-13</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-11-18 08:07:49" itemprop="dateModified" datetime="2021-11-18T08:07:49+00:00">2021-11-18</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Thinking-in-Ramda/" itemprop="url" rel="index"><span itemprop="name">Thinking in Ramda</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>译者注：本文翻译自 Randy Coulman 的 《<a href="http://randycoulman.com/blog/2016/06/21/thinking-in-ramda-pointfree-style/" target="_blank" rel="noopener">Thinking in Ramda: Pointfree Style</a>》，转载请与<a href="https://github.com/randycoulman" target="_blank" rel="noopener">原作者</a>或<a href="https://github.com/adispring" target="_blank" rel="noopener">本人</a>联系。下面开始正文。</p>
<hr>
<p>本文是函数式编程系列文章：<a href="https://adispring.coding.me/categories/Thinking-in-Ramda/" target="_blank" rel="noopener">Thinking in Ramda</a> 的第五篇。</p>
<p>在<a href="https://adispring.coding.me/2017/06/11/Thinking-in-Ramda-Declarative-Programming/" target="_blank" rel="noopener">第四节</a>中，我们讨论了如何用声明式编程（告诉计算机做什么，我们想要什么）代替命令式编程（告诉计算机该怎么做，详细的执行步骤）来编写代码。</p>
<p>你可能已经注意到了，我们编写的几个函数（如 <code>forever21</code>、<code>alwaysDrivingAge</code>、<code>water</code>）都接受一个参数，构建一个新函数，然后将该函数作用于该参数。</p>
<p>这是函数式编程里非常常见的一种模式，Ramda 同样提供了优化这种模式的方法。</p>
<h2 id="pointfree-feng-ge-wu-can-shu-feng-ge">Pointfree 风格（无参数风格）</h2>
<p>我们在 <a href="https://adispring.coding.me/2017/06/11/Thinking-in-Ramda-Partial-Application/" target="_blank" rel="noopener">第三节</a> 中讨论了 Ramda 的两个指导原则：</p>
<ul>
<li>将数据放到参数列表的最后面。</li>
<li>柯里化所有的东西。</li>
</ul>
<p>这两个原则衍生出了一种被函数式程序员称为 “pointfree” 的风格。我喜欢将 pointfree 的代码看作：“数据？什么数据？这里没有数据！”</p>
<p>有一篇很好的博客：<a href="http://fr.umio.us/why-ramda/" target="_blank" rel="noopener">Why Ramda?</a>，展示了 pointfree 风格 真得不错。具体来说，它有一些有趣的标题，例如：“数据在哪里？”，“好了，已经有了！”，“那么我可以看看数据吗？” 和 “拜托，我只是想要我的数据”。</p>
<p>我们还没有使用需要的工具来让所有的例子都变成完全 “pointfree” 的，现在就开始吧。</p>
<p>再看一下 <code>forever21</code>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> forever21 = <span class="function"><span class="params">age</span> =&gt;</span> ifElse(gte(__, <span class="number">21</span>), always(<span class="number">21</span>), inc)(age)</span><br></pre></td></tr></table></figure>
<p>注意，参数 <code>age</code> 出现了两次：一次在参数列表中；一次在函数的最后面：我们将由 <code>ifElse</code> 返回的新函数作用于 <code>age</code>。</p>
<p>在使用 Ramda 编程时稍加留意，就会发现很多这种模式的代码。这也意味着，总应该有一种方法将这些函数转成 “pointfree” 风格。</p>
<p>我们来看看这会是什么样子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> forever21 = ifElse(gte(__, <span class="number">21</span>), always(<span class="number">21</span>), inc)</span><br></pre></td></tr></table></figure>
<p>嘭~~！我们刚刚让 <code>age</code> 消失了。这就是 Pointfree 风格。注意，这两个版本所做的事情完全一样。我们仍然返回一个接受年龄的函数，但并未显示的指定 <code>age</code> 参数。</p>
<p>可以对 <code>alwaysDrivingAge</code> 和 <code>water</code> 进行相同的处理。</p>
<p>原来的 <code>alwaysDrivingAge</code> 如下所示：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> alwaysDrivingAge = <span class="function"><span class="params">age</span> =&gt;</span> ifElse(lt(__, <span class="number">16</span>), always(<span class="number">16</span>), identity)(age)</span><br></pre></td></tr></table></figure>
<p>可以使用相同的方法使其变为 pointfree 的。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> alwaysDrivingAge = when(lt(__, <span class="number">16</span>), always(<span class="number">16</span>))</span><br></pre></td></tr></table></figure>
<p>下面是 <code>water</code> 原来的形式：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> water = <span class="function"><span class="params">temperature</span> =&gt;</span> cond([</span><br><span class="line">  [equals(<span class="number">0</span>),   always(<span class="string">'water freezes at 0°C'</span>)],</span><br><span class="line">  [equals(<span class="number">100</span>), always(<span class="string">'water boils at 100°C'</span>)],</span><br><span class="line">  [T,           temp =&gt; <span class="string">`nothing special happens at <span class="subst">$&#123;temp&#125;</span>°C`</span>]</span><br><span class="line">])(temperature)</span><br></pre></td></tr></table></figure>
<p>现在将其变为 pointfree 风格的：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> water = cond([</span><br><span class="line">  [equals(<span class="number">0</span>),   always(<span class="string">'water freezes at 0°C'</span>)],</span><br><span class="line">  [equals(<span class="number">100</span>), always(<span class="string">'water boils at 100°C'</span>)],</span><br><span class="line">  [T,           temp =&gt; <span class="string">`nothing special happens at <span class="subst">$&#123;temp&#125;</span>°C`</span>]</span><br><span class="line">])</span><br></pre></td></tr></table></figure>
<h2 id="duo-yuan-han-shu-duo-can-shu-han-shu">多元函数（多参数函数）</h2>
<p>如果函数接受多个参数会怎样呢？回顾一下 <a href="https://adispring.coding.me/2017/06/11/Thinking-in-Ramda-Partial-Application/" target="_blank" rel="noopener">第三节</a> 中的例子：<code>titlesForYear</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> titlesForYear = curry(<span class="function">(<span class="params">year, books</span>) =&gt;</span></span><br><span class="line">  pipe(</span><br><span class="line">    filter(publishedInYear(year)),</span><br><span class="line">    map(<span class="function"><span class="params">book</span> =&gt;</span> book.title)</span><br><span class="line">  )(books)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>注意，<code>books</code> 出现了两次：一次作为参数列表的最后一个参数（最后一个数据！）；一次出现在函数最后，当我们将其传入 pipeline 的时候。这跟我们之前看到参数为 <code>age</code> 的模式类似，所以可以对它进行相同的转换：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> titlesForYear = <span class="function"><span class="params">year</span> =&gt;</span></span><br><span class="line">  pipe(</span><br><span class="line">    filter(publishedInYear(year)),</span><br><span class="line">    map(<span class="function"><span class="params">book</span> =&gt;</span> book.title)</span><br><span class="line">  )</span><br></pre></td></tr></table></figure>
<p>可以了！我们现在有了一个 pointfree 版本的 <code>titlesFroYear</code>。</p>
<p>其实，这种情况下，我可能不会刻意追求 pointfree 风格，因为就像之前文章讨论过的：JavaScript 在调用一系列单参数函数方面并不方便。</p>
<p>在 pipeline 中使用 <code>titleForYear</code> 是很方便，如我们可以很轻松的调用 <code>titlesForYear(2012)</code>，但当想要单独使用它时，我们就不得不回到之前文章里看到的形式 <code>)(</code>，对我而言，并不值得做出这种妥协（没必要为了 pointfree 而 pointfree）。</p>
<p>但只要有如上形式的单参数函数（或者可能以后会被重构），我几乎总是写成 pointfree 风格的。</p>
<h2 id="zhong-gou-wei-pointfree-feng-ge-de-dai-ma">重构为 pointfree 风格的代码</h2>
<p>有时我们的代码不会遵循这种模式。我们可能会在同一函数内多次对数据进行操作。</p>
<p>在 <a href="https://adispring.coding.me/2017/06/10/Thinking-in-Ramda-Combining-Functions/" target="_blank" rel="noopener">第二节</a> 的几个例子中便是这种情形。我们使用诸如 <code>both</code>、<code>either</code>、<code>pipe</code>、<code>compose</code> 来重构代码。一旦我们这样做了，便会很容易让函数转换为 pointfree 风格的。</p>
<p>我们来回顾一下 <code>isEligibleToVote</code> 这个例子，代码如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> wasBornInCountry = <span class="function"><span class="params">person</span> =&gt;</span> person.birthCountry === OUR_COUNTRY</span><br><span class="line"><span class="keyword">const</span> wasNaturalized = <span class="function"><span class="params">person</span> =&gt;</span> <span class="built_in">Boolean</span>(person.naturalizationDate)</span><br><span class="line"><span class="keyword">const</span> isOver18 = <span class="function"><span class="params">person</span> =&gt;</span> person.age &gt;= <span class="number">18</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> isCitizen = <span class="function"><span class="params">person</span> =&gt;</span> wasBornInCountry(person) || wasNaturalized(person)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> isEligibleToVote = <span class="function"><span class="params">person</span> =&gt;</span> isOver18(person) &amp;&amp; isCitizen(person)</span><br></pre></td></tr></table></figure>
<p>先从 <code>isCitizen</code> 开始。它接受一个 <code>person</code>, 然后将两个函数作用于该 <code>person</code>，将结果使用 <code>||</code> 组合起来。正如在 <a href="https://adispring.coding.me/2017/06/10/Thinking-in-Ramda-Combining-Functions/" target="_blank" rel="noopener">第二节</a> 中学到的，可以使用 <code>either</code> 将两个函数组合成一个新函数，然后将该组合函数作用于该 <code>person</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> isCitizen = <span class="function"><span class="params">person</span> =&gt;</span> either(wasBornInCountry, wasNaturalized)(person)</span><br></pre></td></tr></table></figure>
<p>可以使用 <code>both</code> 对 <code>isEligibleToVote</code> 做类似的处理。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> isEligibleToVote = <span class="function"><span class="params">person</span> =&gt;</span> both(isOver18, isCitizen)(person)</span><br></pre></td></tr></table></figure>
<p>现在我们已经完成了这些重构，可以看到，这两个函数都遵循上面提到的模式：<code>person</code> 出现了两次，一次作为函数参数；一次放到最后，将组合函数作用其上。现在可以将它们重构为 pointfree 风格的代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> isCitizen = either(wasBornInCountry, wasNaturalized)</span><br><span class="line"><span class="keyword">const</span> isEligibleToVote = both(isOver18, isCitizen)</span><br></pre></td></tr></table></figure>
<h2 id="wei-shi-yao-yao-zhe-yao-zuo">为什么要这么做？</h2>
<p>Pointfree 风格需要一定的时间才能习惯。可能并不需要所有的地方都没有参数。有时候知道某些 Ramda 函数需要多少参数，也是很重要的。</p>
<p>但是，一旦习惯了这种方式，它将变得非常强大：可以以非常有趣的方式将很多小的 pointfree 函数组合起来。</p>
<p>Pointfree 风格的优点是什么呢？人们可能会认为，这只不过是为了让函数式编程赢得 “优点徽章” 的学术活动而已（实际上并没有什么用处）。然而，我认为还是有一些优点的，即使需要花一些时间来习惯这种方式也是值得的：</p>
<ul>
<li>它让编程更简单、精练。这并不总是一件好事，但大部分情况下是这样的。</li>
<li>它让算法更清晰。通过只关注正在组合的函数，我们可以在没有参数的干扰下，更好地了解发生了什么。</li>
<li>它促使我们更专注于正在做的转换的本身，而不是正被转换的数据。</li>
<li>它可以帮助我们将函数视为可以作用于不同数据的通用构建模块，而非对特定类型数据的操作。如果给数据一个名字，我们的思想便会被<a href="https://en.wikipedia.org/wiki/Anchoring" target="_blank" rel="noopener">禁锢</a>在：“需要在哪里使用我们的函数”；如果去掉参数，便会使我们更有创造力。</li>
</ul>
<h2 id="jie-lun">结论</h2>
<p>Pointfree 风格也被成为 <a href="https://en.wikipedia.org/wiki/Tacit_programming" target="_blank" rel="noopener">tacit 式编程</a>(隐含式编程)，可以使代码更清晰、更易于理解。通过代码重构将所有的转换组合成单一函数，我们最终会得到可以在更多地方使用的更小的构建块（函数）。</p>
<h2 id="xia-yi-jie">下一节</h2>
<p>在当前示例中，我们尚未将所有代码都重构为 pointfree 的风格。还有一些代码是命令式的。大部分这种代码是处理对象和数组的。</p>
<p>我们需要找到声明式的方式来处理对象和数组。Immutability (不变性) 怎么样？我们如何以 “不变” (immutable) 的方式来操作对象和数组呢？</p>
<p>本系列的下一节，<a href="https://adispring.coding.me/2017/06/16/Thinking-in-Ramda-Immutability-and-Objects/" target="_blank" rel="noopener">数据不变性和对象</a> 将讨论如何以函数式和 immutable 的方式来处理对象。紧随其后的章节：<a href="https://adispring.coding.me/2017/06/17/Thinking-in-Ramda-Immutability-and-Arrays/" target="_blank" rel="noopener">数据不变性和数组</a> 对数组也是相同的处理方式。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://adispring.github.io/2017/06/11/Thinking-in-Ramda-Declarative-Programming/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="wangzengdi">
      <meta itemprop="description" content="FE@Meituan.com">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="wangzengdi's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2017/06/11/Thinking-in-Ramda-Declarative-Programming/" class="post-title-link" itemprop="url">Thinking in Ramda: 声明式编程</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2017-06-11 20:27:38" itemprop="dateCreated datePublished" datetime="2017-06-11T20:27:38+00:00">2017-06-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-11-18 08:07:49" itemprop="dateModified" datetime="2021-11-18T08:07:49+00:00">2021-11-18</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Thinking-in-Ramda/" itemprop="url" rel="index"><span itemprop="name">Thinking in Ramda</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>译者注：本文翻译自 Randy Coulman 的 《<a href="http://randycoulman.com/blog/2016/06/14/thinking-in-ramda-declarative-programming/" target="_blank" rel="noopener">Thinking in Ramda: Declarative Programming</a>》，转载请与<a href="https://github.com/randycoulman" target="_blank" rel="noopener">原作者</a>或<a href="https://github.com/adispring" target="_blank" rel="noopener">本人</a>联系。下面开始正文。</p>
<hr>
<p>本文是函数式编程系列文章：<a href="https://adispring.coding.me/categories/Thinking-in-Ramda/" target="_blank" rel="noopener">Thinking in Ramda</a> 的第四篇。</p>
<p>在<a href="https://adispring.coding.me/2017/06/11/Thinking-in-Ramda-Partial-Application/" target="_blank" rel="noopener">第三节</a>中，讨论了使用 “部分应用” 和 “柯里化” 技术来组合多元（多参数）函数。</p>
<p>当我们开始编写小的函数式构建块并组合它们时，发现必须写好多函数来包裹 JavaScript 操作符，比如算术、比较、逻辑操作符和控制流。这可能比较乏味，但 Ramda 将我们拉了回来，让事情变得有趣起来。</p>
<p>开始之前，先介绍一些背景知识。</p>
<h2 id="ming-ling-shi-vs-sheng-ming-shi">命令式 vs 声明式</h2>
<p>存在很多编程语言分类的方式，如静态语言和动态语言，解释型语言和编译型语言，底层和高层语言等等。</p>
<p>另一种划分的方式是命令式编程和声明式编程。</p>
<p>简单地说，命令式编程中，程序员需要告诉计算机怎么做来完成任务。命令式编程带给我们每天会用到的大量的基本结构：控制流（<code>if</code>-<code>then</code>-<code>else</code> 语句和循环），算术运算符（<code>+</code>、<code>-</code>、<code>*</code>、<code>/</code>），比较运算符（<code>===</code>、<code>&gt;</code>、<code>&lt;</code> 等），和逻辑运算符（<code>&amp;&amp;</code>、<code>||</code>、<code>!</code>）。</p>
<p>而声明式编程，程序员只需告诉计算机我想要什么，然后计算机自己理清如何产生结果。</p>
<p>其中一种经典的声明式编程语言是 Prolog。在 Prolog 中，程序是由一组 “facts” (谓词) 和 一组 “rules” (规则) 组成。可以通过提问来启动程序。Prolog 的推理机使用 facts 和 rules 来回答问题。</p>
<p>函数式编程被认为是声明式编程的一个子集。在一段函数式程序中，我们定义函数，然后通过组合这些函数告诉计算机做什么。</p>
<p>即使在声明式程序中，也需要做一些命令式程序中的工作。控制流，算术、比较和逻辑操作仍然是必须使用的基本构建块。但我们需要找到一种声明式的方式来描述这些基本构建块。</p>
<h2 id="sheng-ming-shi-ti-huan">声明式替换</h2>
<p>由于我们使用 JavaScript （一种命令式语言）编程，所以在编写 “普通” JavaScript 代码时，使用标准的命令式结构也是正常的。</p>
<p>但当使用 “pipeline” 或类似的结构编写函数式变换时，命令式的结构并不能很好的工作。</p>
<h2 id="suan-zhu">算术</h2>
<p>在 <a href="https://adispring.coding.me/2017/06/10/Thinking-in-Ramda-Combining-Functions/" target="_blank" rel="noopener">第二节</a> ，我们实现了一系列算术变换来演示 “pipeline”：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> multiply = <span class="function">(<span class="params">a, b</span>) =&gt;</span> a * b</span><br><span class="line"><span class="keyword">const</span> addOne = <span class="function"><span class="params">x</span> =&gt;</span> x + <span class="number">1</span></span><br><span class="line"><span class="keyword">const</span> square = <span class="function"><span class="params">x</span> =&gt;</span> x * x</span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> operate = pipe(</span><br><span class="line">  multiply,</span><br><span class="line">  addOne,</span><br><span class="line">  square</span><br><span class="line">)</span><br><span class="line"> </span><br><span class="line">operate(<span class="number">3</span>, <span class="number">4</span>) <span class="comment">// =&gt; ((3 * 4) + 1)^2 =&gt; (12 + 1)^2 =&gt; 13^2 =&gt; 169</span></span><br></pre></td></tr></table></figure>
<p>注意我们是如何编写函数来实现我们想要的基本构建块的。</p>
<p>Ramda 提供了 <code>add</code>、<code>subtract</code>、<code>multiply</code> 和 <code>divide</code> 函数来替代标准的算术运算符。所以我们可以使用 Ramda 的 <code>multiply</code> 来代替我们自己实现的乘法，可以利用 Ramda 的柯里化 <code>add</code> 函数的优势来取代我们的 <code>addOne</code>，也可以利用 <code>multiply</code> 来编写 <code>square</code>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> square = <span class="function"><span class="params">x</span> =&gt;</span> multiply(x, x)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> operate = pipe(</span><br><span class="line">  multiply,</span><br><span class="line">  add(<span class="number">1</span>),</span><br><span class="line">  square</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p><code>add(1)</code> 与增量运算符（<code>++</code>）非常相似，但 <code>++</code> 修改了被操作的值，因此它是 “mutation” 的。正如在 <a href="https://adispring.coding.me/2017/06/09/Thinking-in-Ramda-%E5%85%A5%E9%97%A8/" target="_blank" rel="noopener">第一节</a> 中所讲，Immutability 是函数式编程的核心原则，所以我们不想使用 <code>++</code> 或 <code>--</code>。</p>
<p>可以使用 <code>add(1)</code> 和 <code>subtract(1)</code> 来做递增和递减操作，但由于这两个操作非常常用，所以 Ramda 专门提供了 <code>inc</code> 和 <code>dec</code>。</p>
<p>所以可以进一步简化我们的 “pipeline”：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> square = <span class="function"><span class="params">x</span> =&gt;</span> multiply(x, x)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> operate = pipe(</span><br><span class="line">  multiply,</span><br><span class="line">  inc,</span><br><span class="line">  square</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p><code>subtract</code> 是二元操作符 <code>-</code> 的替代，但还有一个表示取反的一元操作符 <code>-</code>。我们可以使用 <code>multiply(-1)</code>，但 Ramda 也提供了 <code>negate</code> 来实现相同的功能。</p>
<h2 id="comparison-bi-jiao">Comparison (比较)</h2>
<p>还是在 <a href="https://adispring.coding.me/2017/06/10/Thinking-in-Ramda-Combining-Functions/" target="_blank" rel="noopener">第二节</a>，我们写了一些函数来确定一个人是否有资格投票。该代码的最终版本如下所示：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> wasBornInCountry = <span class="function"><span class="params">person</span> =&gt;</span> person.birthCountry === OUR_COUNTRY</span><br><span class="line"><span class="keyword">const</span> wasNaturalized = <span class="function"><span class="params">person</span> =&gt;</span> <span class="built_in">Boolean</span>(person.naturalizationDate)</span><br><span class="line"><span class="keyword">const</span> isOver18 = <span class="function"><span class="params">person</span> =&gt;</span> person.age &gt;= <span class="number">18</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> isCitizen = either(wasBornInCountry, wasNaturalized)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> isEligibleToVote = both(isOver18, isCitizen)</span><br></pre></td></tr></table></figure>
<p>注意，上面的一些函数使用了标准比较运算符（<code>===</code> 和 <code>&gt;=</code>）。正如你现在所怀疑的，Ramda 也提供了这些运算符的替代。</p>
<p>我们来修改一下代码：使用 <code>equals</code> 代替 <code>===</code>，使用 <code>gte</code> 替代 <code>&gt;=</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> wasBornInCountry = <span class="function"><span class="params">person</span> =&gt;</span> equals(person.birthCountry, OUR_COUNTRY)</span><br><span class="line"><span class="keyword">const</span> wasNaturalized = <span class="function"><span class="params">person</span> =&gt;</span> <span class="built_in">Boolean</span>(person.naturalizationDate)</span><br><span class="line"><span class="keyword">const</span> isOver18 = <span class="function"><span class="params">person</span> =&gt;</span> gte(person.age, <span class="number">18</span>)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> isCitizen = either(wasBornInCountry, wasNaturalized)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> isEligibleToVote = both(isOver18, isCitizen)</span><br></pre></td></tr></table></figure>
<p>Ramda 还提供了其他比较运算符的替代：<code>gt</code> 对应 <code>&gt;</code>，<code>lt</code> 对应 <code>&lt;</code>，<code>lte</code> 对应 <code>&lt;=</code>。</p>
<p>注意，这些函数保持正常的参数顺序（<code>gt</code> 表示第一个参数是否大于第二个参数）。这在单独使用时没有问题，但在组合函数时，可能会让人产生困惑。这些函数似乎违反了 Ramda 的 “待处理数据放在最后” 的原则，所以我们在 pipeline 或类似的情况下使用它们时，要格外小心。这时，<code>flip</code> 和 占位符 (<code>__</code>) 就派上了用场。</p>
<p>除了 <code>equals</code>，还有一个 <code>identical</code>，可以用来判断两个值是否引用了同一块内存。</p>
<p><code>===</code> 还有一些其他的用途：可以检测字符串或数组是否为空（<code>str === ''</code> 或 <code>arr.length === 0</code>），也可以检查变量是否为 <code>null</code> 或 <code>undefined</code>。Ramda 为这两种情况提供了方便的判断函数：<code>isEmpty</code> 和 <code>isNil</code>。</p>
<h2 id="logic-luo-ji">Logic (逻辑)</h2>
<p>在 <a href="https://adispring.coding.me/2017/06/10/Thinking-in-Ramda-Combining-Functions/" target="_blank" rel="noopener">第二节</a> 中（参见上面的相关代码）。我们使用 <code>both</code> 和 <code>either</code> 来代替 <code>&amp;&amp;</code> 和 <code>||</code> 运算符。我们还提到使用 <code>complement</code> 代替 <code>!</code>。</p>
<p>当组合的函数作用于同一份输入值时，这些组合函数帮助很大。上述示例中，<code>wasBornInCountry</code>、<code>wasNaturalized</code> 和 <code>isOver18</code> 都作用于同一个人上。</p>
<p>但有时我们需要将 <code>&amp;&amp;</code>、<code>||</code> 和 <code>!</code> 作用于不同的数值。对于这些情况， Ramda 提供了 <code>and</code>、<code>or</code> 和 <code>not</code> 函数。我以下列方式进行分类：<code>and</code>、<code>or</code> 和 <code>not</code> 用于处理数值；<code>both</code>、<code>either</code> 和 <code>complement</code> 用于处理函数。</p>
<p>经常用 <code>||</code> 来提供默认值。例如，我们可能会编写如下代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> lineWidth = settings.lineWidth || <span class="number">80</span></span><br></pre></td></tr></table></figure>
<p>这是一个常见的用法，大部分情况下都能正常工作，但依赖于 JavaScript 对 “falsy” 值的定义。假设 <code>0</code> 是一个合法的设置选项呢？由于 <code>0</code> 是 “falsy” 值，所以我们最终会得到的行宽为 80 。</p>
<p>我们可以使用上面刚学到的 <code>isNil</code> 函数，但 Ramda 提供了一个更好的选择：<code>defaultTo</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> lineWidth = defaultTo(<span class="number">80</span>, settings.lineWidth)</span><br></pre></td></tr></table></figure>
<p><code>defaultTo</code> 检查第二个参数是否为空（<code>isNil</code>）。如果非空，则返回该值；否则返回第一个值。</p>
<h2 id="conditionals-tiao-jian">Conditionals (条件)</h2>
<p>控制流在函数式编程中不是必要的，但偶尔也会有些用处。在 <a href="https://adispring.coding.me/2017/06/09/Thinking-in-Ramda-%E5%85%A5%E9%97%A8/" target="_blank" rel="noopener">第一节</a> 中讨论的集合迭代函数在大部分情况下都可以很好的取代循环，但 “条件” 仍然非常重要。</p>
<h2 id="if-else">ifElse</h2>
<p>我们来写一个函数，<code>forever21</code>，接受一个年龄，并返回下一个年龄。但正如名字所示，一旦成长到 21 岁，就一直保持这样。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> forever21 = <span class="function"><span class="params">age</span> =&gt;</span> age &gt;= <span class="number">21</span> ? <span class="number">21</span> : age + <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>注意，条件（<code>age &gt;= 21</code>）和第二个分支（<code>age + 1</code>）都可以写作 <code>age</code> 的函数。第一个分支（<code>21</code>）也可以重写成一个常量函数（<code>() =&gt; 21</code>）。现在我们有三个接受（或忽略）<code>age</code> 为参数的函数。</p>
<p>现在可以使用 Ramda 的 <code>ifElse</code> 函数了，这是一个相当于 <code>if...then...else</code> 或 <code>?:</code> 的函数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> forever21 = <span class="function"><span class="params">age</span> =&gt;</span> ifElse(gte(__, <span class="number">21</span>), () =&gt; <span class="number">21</span>, inc)(age)</span><br></pre></td></tr></table></figure>
<p>如上所示，比较函数在进行组合时，可能并不是以我们想要的形式进行工作。所以在这里被迫引入了占位符（<code>__</code>）。我们也可以使用 <code>lte</code>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> forever21 = <span class="function"><span class="params">age</span> =&gt;</span> ifElse(lte(<span class="number">21</span>), () =&gt; <span class="number">21</span>, inc)(age)</span><br></pre></td></tr></table></figure>
<p>在这种情况下，我们不得不读作：“21岁小于或等于给定年龄”。但这样可读性很低、比较乱，所以我坚持使用占位符版本的函数。</p>
<h2 id="constants-chang-liang">constants (常量)</h2>
<p>常量函数在这种情形下非常有用。你可能已经想到了，Ramda 为我们提供了一些便捷的方法。本例中，这个方法是 <code>always</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> forever21 = <span class="function"><span class="params">age</span> =&gt;</span> ifElse(gte(__, <span class="number">21</span>), always(<span class="number">21</span>), inc)(age)</span><br></pre></td></tr></table></figure>
<p>Ramda 还提供了 <code>T</code> 和 <code>F</code>，作为 <code>always(true) 和 always(false)</code> 的缩写。</p>
<h2 id="identity-heng-deng">identity (恒等)</h2>
<p>再来写一个函数：<code>alwaysDrivingAge</code>。该函数接受一个年龄，如果 <code>gte</code> 16，则将该年龄返回；但如果小于 16，则返回 16。这样任何人都可以伪造他们的驾驶年龄了，即使他们还没有达到。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> alwaysDrivingAge = <span class="function"><span class="params">age</span> =&gt;</span> ifElse(lt(__, <span class="number">16</span>), always(<span class="number">16</span>), a =&gt; a)(age)</span><br></pre></td></tr></table></figure>
<p>条件中的第二个分支（<code>a =&gt; a</code>）是函数式编程中的另一种常见的模式。它被称为恒等函数。也即，输出永远等于输入的函数。</p>
<p>正如你所想的，Ramda 为我们提供了 <code>identity</code> 函数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> alwaysDrivingAge = <span class="function"><span class="params">age</span> =&gt;</span> ifElse(lt(__, <span class="number">16</span>), always(<span class="number">16</span>), identity)(age)</span><br></pre></td></tr></table></figure>
<p><code>identity</code> 可以接受多个参数，但总是返回首个参数。如果想要返回除首个参数之外的参数，可以使用更通用的 <code>nthArg</code> 函数。但 <code>nthArg</code> 不如 <code>identity</code> 用的频繁。</p>
<h2 id="when-he-unless">when 和 unless</h2>
<p>在 <code>ifElse</code> 代码中，其中一个条件分支为 <code>identity</code> 也很常见。所以 Ramda 也提供了便捷的方法。</p>
<p>如果像上例所示，第二个分支是 <code>identity</code>，可以用 <code>when</code> 代替 <code>ifElse</code>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> alwaysDrivingAge = <span class="function"><span class="params">age</span> =&gt;</span> when(lt(__, <span class="number">16</span>), always(<span class="number">16</span>))(age)</span><br></pre></td></tr></table></figure>
<p>如果第一个条件分支是 <code>identity</code>，可以用 <code>unless</code>。借助 <code>gte(__, 16)</code> 来翻转一下我们的条件，便可以使用 <code>unless</code> 了。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> alwaysDrivingAge = <span class="function"><span class="params">age</span> =&gt;</span> unless(gte(__, <span class="number">16</span>), always(<span class="number">16</span>))(age)</span><br></pre></td></tr></table></figure>
<h2 id="cond">cond</h2>
<p>Ramda 还提供了 <code>cond</code> 函数，来代替 <code>switch</code> 语句或链式的 <code>if...then...else</code> 语句。</p>
<p>这里采用 Ramda 文档中的例子来展示 <code>cond</code> 的用法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> water = <span class="function"><span class="params">temperature</span> =&gt;</span> cond([</span><br><span class="line">  [equals(<span class="number">0</span>),   always(<span class="string">'water freezes at 0°C'</span>)],</span><br><span class="line">  [equals(<span class="number">100</span>), always(<span class="string">'water boils at 100°C'</span>)],</span><br><span class="line">  [T,           temp =&gt; <span class="string">`nothing special happens at <span class="subst">$&#123;temp&#125;</span>°C`</span>]</span><br><span class="line">])(temperature)</span><br></pre></td></tr></table></figure>
<p>我目前还不需要在 Ramda 代码中使用 <code>cond</code>。但我很多年前编写过 Common Lisp 代码，所以 <code>cond</code> 函数感觉就像是位老朋友。</p>
<h2 id="jie-lun">结论</h2>
<p>本节中展示了很多将命令式代码转为函数声明式代码的 Ramda 函数。</p>
<h2 id="xia-yi-jie">下一节</h2>
<p>你可能已经注意到了，最后我们编写的几个函数（<code>forever21</code>、<code>alwaysDrivingAge</code> 和 <code>water</code>）都接受一个参数，构建一个新函数，然后将该函数作用于参数。</p>
<p>这也是一种常见的模式，并且 Ramda 照例提供了一些简化这些代码的便捷方法。下一节中，<a href="https://adispring.coding.me/2017/06/13/Thinking-in-Ramda-Pointfree-Style/" target="_blank" rel="noopener">Pointfree Style</a> 将演示如何简化符合这种模式的代码。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://adispring.github.io/2017/06/11/Thinking-in-Ramda-Partial-Application/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="wangzengdi">
      <meta itemprop="description" content="FE@Meituan.com">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="wangzengdi's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2017/06/11/Thinking-in-Ramda-Partial-Application/" class="post-title-link" itemprop="url">Thinking in Ramda: 部分应用</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2017-06-11 06:01:57" itemprop="dateCreated datePublished" datetime="2017-06-11T06:01:57+00:00">2017-06-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-11-18 08:07:49" itemprop="dateModified" datetime="2021-11-18T08:07:49+00:00">2021-11-18</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Thinking-in-Ramda/" itemprop="url" rel="index"><span itemprop="name">Thinking in Ramda</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>译者注：本文翻译自 Randy Coulman 的 《<a href="http://randycoulman.com/blog/2016/06/07/thinking-in-ramda-partial-application/" target="_blank" rel="noopener">Thinking in Ramda: Partial Application</a>》，转载请与<a href="https://github.com/randycoulman" target="_blank" rel="noopener">原作者</a>或<a href="https://github.com/adispring" target="_blank" rel="noopener">本人</a>联系。下面开始正文。</p>
<hr>
<p>本文是函数式编程系列文章：<a href="https://adispring.coding.me/categories/Thinking-in-Ramda/" target="_blank" rel="noopener">Thinking in Ramda</a> 的第三篇。</p>
<p>在<a href="https://adispring.coding.me/2017/06/10/Thinking-in-Ramda-Combining-Functions/" target="_blank" rel="noopener">第二节</a>中，讨论了各种函数组合的方式。最后，演示了 <code>compose</code> 和 <code>pipe</code>， 可以以 “pipeline” （管道）的形式对一系列函数进行调用。</p>
<p>在上篇文章中，简单的函数链式调用（“pipeline”）时，其中的被调用函数都是一元的（除了首个函数）。但如果要使用多元函数呢？</p>
<p>例如，假设有一个书籍对象的集合，我们想要找到特定年份出版的所有图书的标题。可以使用 Ramda 的集合迭代函数完成该需求：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> publishedInYear = <span class="function">(<span class="params">book, year</span>) =&gt;</span> book.year === year</span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> titlesForYear = <span class="function">(<span class="params">books, year</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> selected = filter(<span class="function"><span class="params">book</span> =&gt;</span> publishedInYear(book, year), books)</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">return</span> map(<span class="function"><span class="params">book</span> =&gt;</span> book.title, selected)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果能将 <code>filter</code> 和 <code>map</code> 组合成 “pipeline” 就好了，但我们并不知道该如何处理，因为 <code>filter</code> 和 <code>map</code> 都是二元函数。</p>
<p>如果不需要在 <code>filter</code> 中使用箭头函数会更好些。先来解决这个问题，并借此展示一些制作 “pipeline” 的知识。</p>
<h2 id="gao-jie-han-shu">高阶函数</h2>
<p>在本系列文章的<a href="https://adispring.coding.me/2017/06/09/Thinking-in-Ramda-%E5%85%A5%E9%97%A8/" target="_blank" rel="noopener">第一篇</a>中，我们将函数视为 “一等结构”。一等函数可以作为参数传递给其他函数，也可以作为其他函数的返回值。我们一直在使用前者，但还没有见过后者（函数作为其他函数的返回值）。</p>
<p>获取或返回其他函数的函数称为 “高阶函数”。</p>
<p>在上面的示例中，我们传递了一个箭头函数给 <code>filter</code>：<code>book =&gt; publishedInYear(book, year)</code>，但我们想去掉箭头函数。为了做到这点，需要一个函数：输入一本书，若该书是在指定年份出版的则返回 <code>true</code>。但还需要一个指定的年份，让该操作更加灵活。</p>
<p>为了解决这个问题，可以将 <code>publishedInYear</code> 变为返回另一个函数的函数。我将使用普通的语法来实现该函数，以便能够清晰地展示其内部具体实现，然后使用箭头函数实现一个更短版本的函数：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Full function version:</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">publishedInYear</span>(<span class="params">year</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">book</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> book.year === year</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Arrow function version:</span></span><br><span class="line"><span class="keyword">const</span> publishedInYear = <span class="function"><span class="params">year</span> =&gt;</span> <span class="function"><span class="params">book</span> =&gt;</span> book.year === year</span><br></pre></td></tr></table></figure>
<p>利用新实现的 <code>publishedInYear</code>，可以重写 <code>filter</code> 调用，从而消除箭头函数：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> publishedInYear = <span class="function"><span class="params">year</span> =&gt;</span> <span class="function"><span class="params">book</span> =&gt;</span> book.year === year</span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> titlesForYear = <span class="function">(<span class="params">books, year</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> selected = filter(publishedInYear(year), books)</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">return</span> map(<span class="function"><span class="params">book</span> =&gt;</span> book.title, selected)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在，当调用 <code>filter</code> 时，<code>publishedInYear(year)</code> 会立即调用，并返回一个接受 <code>book</code> 为参数的函数，这正是 <code>filter</code> 需要的。</p>
<h2 id="bu-fen-ying-yong-han-shu">部分应用函数</h2>
<p>可以按上面的方式重写任何多参数函数。但我们不可能拥有所有我们想要的函数的源码；另外，很多情况下，我们可能还是希望以普通的方式调用多参数函数。</p>
<p>例如，在其他一些代码中，只是想检查一本书是否是在指定年份出版的，我们可能想要 <code>publishedInYear(book, 2012)</code>，但现在不能再那么做了。相反，我们必须要用这种方式：<code>publishedInYear(book)(2012)</code>。这样做降低了代码的可读性，也很烦人。</p>
<p>幸运的是，Ramda 提供了两个函数：<code>partial</code> 和 <code>partialRight</code>，来帮我们解决这个问题。</p>
<p>这两个函数可以让我们不必一次传递所有需要的参数，也可以调用函数。它们都返回一个接受剩余参数的新函数，当所有参数都传入后，才会真正调用被包裹的原函数。</p>
<p><code>partial</code> 和 <code>partialRight</code> 的区别在于参数传递的顺序：<code>partial</code> 先传递原函数左侧的参数，而 <code>partialRight</code> 先传递右侧的参数。</p>
<p>回到刚开始的例子，使用上面的一个函数来代替原来对 <code>publishedInYear</code> 的重写。由于刚开始我们只需要最右侧的参数：<code>year</code>，所以需要使用 <code>partialRight</code>.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> publishedInYear = <span class="function">(<span class="params">book, year</span>) =&gt;</span> book.year === year</span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> titlesForYear = <span class="function">(<span class="params">books, year</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> selected = filter(partialRight(publishedInYear, [year]), books)</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">return</span> map(<span class="function"><span class="params">book</span> =&gt;</span> book.title, selected)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果 <code>pubilshedInYear</code> 原本参数的顺序为 <code>(year, book)</code> ，而非 <code>(book, year)</code> ，则需要用 <code>partial</code> 代替 <code>partialRight</code>。</p>
<p>注意，为被 <code>partial</code> 和 <code>partialRight</code> 包裹的函数提供的参数必须包裹在数组中，即使只有一个参数。我不会告诉你我已经忘记了多少次，导致出现令人困惑的错误信息：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">First argument to _arity must be a non-negative <span class="built_in">integer</span> no greater than ten</span><br></pre></td></tr></table></figure>
<h2 id="ke-li-hua-curry">柯里化(Curry)</h2>
<p>如果到处使用 <code>partial</code> 和 <code>partialRight</code> 的话，会让代码变得冗长乏味；但是，将多元函数以一系列一元函数的形式调用同样不好。</p>
<p>幸运的是，Ramda 给我们提供了一个解决方案：<code>curry</code>。</p>
<p><a href="https://en.wikipedia.org/wiki/Currying" target="_blank" rel="noopener">Currying（柯里化）</a> 是函数式编程的另一个核心概念。从技术角度讲，一个柯里化了的函数是一系列高阶一元函数，这也是我刚刚抱怨过的。在纯函数式语言中，柯里化函数在调用时，语法上看起来和调用多个参数没有什么区别。</p>
<p>但由于 Ramda 是一个 JavaScript 库，而 JavaScript 并没有很好的语法来支持一系列一元函数的调用，所以作者对传统柯里化的定义放宽了一些。</p>
<p>在 Ramda 中，一个柯里化的函数只能用其参数的子集来调用，它会返回一个接受其余参数的新函数。当使用它的所有参数调用，真正的原函数将被调用。</p>
<p>柯里化的函数在下列两种情况下工作的都很好：</p>
<ol>
<li>可以按正常情况下使用所有参数调用它，它可以像普通函数一样正常工作；</li>
<li>也可以使用部分参数来调用它，这时它会像使用 <code>partial</code> 一样工作。</li>
</ol>
<p>注意，这种灵活性带来了一些性能上的损失，因为 <code>curry</code> 需要搞清楚函数的调用方式，然后确定该做什么。一般来说，我只有需要在多个地方对同一个函数使用 <code>partial</code> 的时候，才会对函数进行柯里化。</p>
<p>接下来写一个柯里化版本的 <code>publishedInYear</code> 函数。注意，<code>curry</code> 会像 <code>partial</code> 一样工作；并且没有 <code>partialRight</code> 版本的 <code>curry</code> 函数。对这方面后续会有更多讨论，但现在我们需要将 <code>publishedInYear</code> 的参数翻转一下，以便让参数 <code>year</code> 在最前面。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> publishedInYear = curry(<span class="function">(<span class="params">year, book</span>) =&gt;</span> book.year === year)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> titlesForYear = <span class="function">(<span class="params">books, year</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> selected = filter(publishedInYear(year), books)</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">return</span> map(<span class="function"><span class="params">book</span> =&gt;</span> book.title, selected)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在可以只使用参数 <code>year</code> 来调用 <code>publishedInYear</code>，并返回一个新函数，该函数接受参数 <code>book</code> 并执行原函数。但是，仍然可以按普通方式对它调用：<code>publishedInYear(2012, book)</code>，不需要写烦人的语法 <code>)(</code>。所以，柯里化的函数在两种情况下都能很好地工作。</p>
<h2 id="can-shu-de-shun-xu">参数的顺序</h2>
<p>注意，为了让 <code>curry</code> 工作，我们不得不对参数的顺序进行翻转。这在函数式编程中非常常见，所以几乎所有的 Ramda 函数都将待处理的数据放到参数列表的最后面。</p>
<p>你可以将先期传入的参数看作对操作的配置。所以，对于 <code>publishedInYear</code>，参数 <code>year</code> 作为配置（需要查找的年份），而参数 <code>book</code> 作为被处理的数据（被查找的对象）。</p>
<p>我们已经在集合迭代函数中见过这样的例子。它们都将集合作为最后一个参数，这样可以使这种风格的编程更容易些。</p>
<h2 id="shun-xu-cuo-wu-de-can-shu">顺序错误的参数</h2>
<p>如果不改变 <code>publishedInYear</code> 的顺序，还可以继续使用柯里化特性的优势吗？</p>
<p>当然可以了，Ramda 提供了几个选择。</p>
<h2 id="flip">flip</h2>
<p>第一个选择是 <code>flip</code>。<code>flip</code> 接受一个多元函数（元数 &gt;= 2），返回一个元数相同的新函数，但前 2 个参数的顺序调换了。它主要用于二元函数，但也可以用于一般函数。</p>
<p>使用 <code>flip</code>，我们可以恢复 <code>publishedInYear</code> 参数的初始的顺序：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> publishedInYear = curry(<span class="function">(<span class="params">book, year</span>) =&gt;</span> book.year === year)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> titlesForYear = <span class="function">(<span class="params">books, year</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> selected = filter(flip(publishedInYear)(year), books)</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">return</span> map(<span class="function"><span class="params">book</span> =&gt;</span> book.title, selected)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>多数情况下，我更喜欢使用方便的参数顺序，但如果用到不能自己掌控的函数，<code>flip</code> 是一个好的选择。</p>
<h2 id="placeholder-zhan-wei-fu">placeholder (占位符)</h2>
<p>更通用的选择是使用 “placeholder” 参数（<code>__</code>）</p>
<p>假设有一个三元柯里化的函数，并且我们想传入第一个和最后一个参数，中间参数后续再传，应该怎么办呢？我们可以使用 “占位符” 作为中间参数：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> threeArgs = curry(<span class="function">(<span class="params">a, b, c</span>) =&gt;</span> &#123; <span class="comment">/* ... */</span> &#125;)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> middleArgumentLater = threeArgs(<span class="string">'value for a'</span>, __, <span class="string">'value for c'</span>)</span><br></pre></td></tr></table></figure>
<p>可以在函数调用中多次使用 “占位符”。例如，如果只想传递中间参数呢？</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> threeArgs = curry(<span class="function">(<span class="params">a, b, c</span>) =&gt;</span> &#123; <span class="comment">/* ... */</span> &#125;)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> middleArgumentOnly = threeArgs(__, <span class="string">'value for b'</span>, __)</span><br></pre></td></tr></table></figure>
<p>也可以使用 “占位符” 代替 <code>flip</code>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> publishedInYear = curry(<span class="function">(<span class="params">book, year</span>) =&gt;</span> book.year === year)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> titlesForYear = <span class="function">(<span class="params">books, year</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> selected = filter(publishedInYear(__, year), books)</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">return</span> map(<span class="function"><span class="params">book</span> =&gt;</span> book.title, selected)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我觉得这个版本的可读性更好，但如果需要频繁使用参数顺序翻转的 <code>publishedInYear</code>，我可能会使用 <code>flip</code> 定义一个辅助函数，然后在任何用到它的地方使用辅助函数。在后续文章中会看到一些示例。</p>
<p>注意， <code>__</code> 仅适用于柯里化的函数，而 <code>partial</code>、<code>partialRight</code> 和 <code>flip</code> 适用于任何函数。如果需要对某个普通函数使用 <code>__</code>，可以先用 <code>curry</code> 将其包裹起来。</p>
<h2 id="lai-zuo-yi-tiao-guan-dao-pipeline">来做一条管道（pipeline）</h2>
<p>现在看看能否将我们的 <code>filter</code> 和 <code>map</code> 调用放入 “pipeline” (管道)中？下面是代码当前的状态，使用了方便的参数顺序的 <code>publishedInYear</code>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> publishedInYear = curry(<span class="function">(<span class="params">year, book</span>) =&gt;</span> book.year === year)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> titlesForYear = <span class="function">(<span class="params">books, year</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> selected = filter(publishedInYear(year), books)</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">return</span> map(<span class="function"><span class="params">book</span> =&gt;</span> book.title, selected)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上一节中，我们了解了 <code>pipe</code> 和 <code>compose</code>，但我们还需要另一部分信息，以便能够使用上面所学的知识。</p>
<p>缺少的信息是：几乎所有的 Ramda 函数都是默认柯里化的，包括 <code>filter</code> 和 <code>map</code>。所以 <code>filter(publishedInYear(year))</code> 是完全合法的，它会返回一个新函数，该函数等待我们传递 <code>books</code> 给它，<code>map(book =&gt; book.title)</code> 也是如此。</p>
<p>现在可以编写 “pipeline” 了：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> publishedInYear = curry(<span class="function">(<span class="params">year, book</span>) =&gt;</span> book.year === year)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> titlesForYear = <span class="function">(<span class="params">books, year</span>) =&gt;</span></span><br><span class="line">  pipe(</span><br><span class="line">    filter(publishedInYear(year)),</span><br><span class="line">    map(<span class="function"><span class="params">book</span> =&gt;</span> book.title)</span><br><span class="line">  )(books)</span><br></pre></td></tr></table></figure>
<p>我们来更进一步，将 <code>titlesForYear</code> 的参数顺序也调换一下，这样更符合 Ramda 中待处理数据放在最后的约定。也可以将该函数进行柯里化，以便其在后续的 “pipeline” 中使用。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> publishedInYear = curry(<span class="function">(<span class="params">year, book</span>) =&gt;</span> book.year === year)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> titlesForYear = curry(<span class="function">(<span class="params">year, books</span>) =&gt;</span></span><br><span class="line">  pipe(</span><br><span class="line">    filter(publishedInYear(year)),</span><br><span class="line">    map(<span class="function"><span class="params">book</span> =&gt;</span> book.title)</span><br><span class="line">  )(books)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<h2 id="jie-lun">结论</h2>
<p>本文可能是这个系列中讲解最深的一篇。部分应用和柯里化可能需要花一些时间和精力来熟悉和掌握。但一旦学会，他们会以一种强大的方式将数据处理变得更加函数式。</p>
<p>它们引导你通过创建包含许多小而简单代码块的 “pipeline” 的方式，来构建数据处理程序。</p>
<h2 id="xia-yi-jie">下一节</h2>
<p>为了以函数式的方式编写代码，我们需要用 “声明式” 的思维代替 “命令式” 思维。要做到这点，需要找到一种函数式的方式来表示命令式的结构。<a href="https://adispring.coding.me/2017/06/11/Thinking-in-Ramda-Declarative-Programming/" target="_blank" rel="noopener">声明式编程</a> 将会讨论这些想法。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://adispring.github.io/2017/06/10/Thinking-in-Ramda-Combining-Functions/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="wangzengdi">
      <meta itemprop="description" content="FE@Meituan.com">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="wangzengdi's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2017/06/10/Thinking-in-Ramda-Combining-Functions/" class="post-title-link" itemprop="url">Thinking in Ramda: 函数组合</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2017-06-10 15:38:05" itemprop="dateCreated datePublished" datetime="2017-06-10T15:38:05+00:00">2017-06-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-11-18 08:07:49" itemprop="dateModified" datetime="2021-11-18T08:07:49+00:00">2021-11-18</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Thinking-in-Ramda/" itemprop="url" rel="index"><span itemprop="name">Thinking in Ramda</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>译者注：本文翻译自 Randy Coulman 的 《<a href="http://randycoulman.com/blog/2016/05/31/thinking-in-ramda-combining-functions/" target="_blank" rel="noopener">Thinking in Ramda: Combining Functions</a>》，转载请与<a href="https://github.com/randycoulman" target="_blank" rel="noopener">原作者</a>或<a href="https://github.com/adispring" target="_blank" rel="noopener">本人</a>联系。下面开始正文。</p>
<hr>
<p>本文是函数式编程系列文章：<a href="https://adispring.coding.me/categories/Thinking-in-Ramda/" target="_blank" rel="noopener">Thinking in Ramda</a> 的第二篇。</p>
<p>在<a href="https://adispring.coding.me/2017/06/09/Thinking-in-Ramda-%E5%85%A5%E9%97%A8/" target="_blank" rel="noopener">第一节</a>中，介绍了 Ramda 和函数式编程的一些基本思想，如函数、纯函数和数据不变性。并介绍了如何入门：可以从集合迭代函数（如 <code>forEach</code>、<code>map</code>、<code>reduce</code>）开始。</p>
<h2 id="jian-dan-zu-he">简单组合</h2>
<p>一旦熟悉了可以将函数传递给其他函数，你可能会开始找将多个函数组合在一起的场景。</p>
<p>Ramda 为简单的函数组合提供了一些函数。我们来看看。</p>
<h2 id="complement">Complement</h2>
<p>在上一节，我们使用 <code>find</code> 来查找列表中的首个偶数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> isEven = <span class="function"><span class="params">x</span> =&gt;</span> x % <span class="number">2</span> === <span class="number">0</span></span><br><span class="line">find(isEven, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]) <span class="comment">//=&gt; 2</span></span><br></pre></td></tr></table></figure>
<p>如果想找首个奇数呢？我们可以随手写一个 <code>isOdd</code> 函数并使用它。但我们知道任何非偶整数都是奇数，所以可以重用 <code>isEven</code> 函数。</p>
<p>Ramda 提供了一个更高阶的函数：<code>complement</code>，给它传入一个函数，返回一个新的函数：当原函数返回 “假值” 时，新函数返回 <code>true</code>；原函数返回 “真值” 时，新函数返回 <code>false</code>，即新函数是原函数的补函数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> isEven = <span class="function"><span class="params">x</span> =&gt;</span> x % <span class="number">2</span> === <span class="number">0</span></span><br><span class="line"> </span><br><span class="line">find(complement(isEven), [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]) <span class="comment">// --&gt; 1</span></span><br></pre></td></tr></table></figure>
<p>更进一步，可以给 <code>complement</code> 过的函数起个名字，这样新函数便可以复用：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> isEven = <span class="function"><span class="params">x</span> =&gt;</span> x % <span class="number">2</span> === <span class="number">0</span></span><br><span class="line"><span class="keyword">const</span> isOdd = complement(isEven)</span><br><span class="line"> </span><br><span class="line">find(isOdd, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]) <span class="comment">// --&gt; 1</span></span><br></pre></td></tr></table></figure>
<p>注意，<code>complement</code> 以函数的方式实现了逻辑非操作（<code>!</code>， not）的功能。</p>
<p><code>Both/Either</code></p>
<p>假设我们正在开发一个投票系统，给定一个人，我们希望能够确定其是否有资格投票。根据现有知识，一个人必须年满 18 岁并且是本国公民，才有资格投票。成为公民的条件：在本国出生，或者后来加入该国国籍。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> wasBornInCountry = <span class="function"><span class="params">person</span> =&gt;</span> person.birthCountry === OUR_COUNTRY</span><br><span class="line"><span class="keyword">const</span> wasNaturalized = <span class="function"><span class="params">person</span> =&gt;</span> <span class="built_in">Boolean</span>(person.naturalizationDate)</span><br><span class="line"><span class="keyword">const</span> isOver18 = <span class="function"><span class="params">person</span> =&gt;</span> person.age &gt;= <span class="number">18</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> isCitizen = <span class="function"><span class="params">person</span> =&gt;</span> wasBornInCountry(person) || wasNaturalized(person)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> isEligibleToVote = <span class="function"><span class="params">person</span> =&gt;</span> isOver18(person) &amp;&amp; isCitizen(person)</span><br></pre></td></tr></table></figure>
<p>上面代码实现了我们的需求，但 Ramda 提供了一些方便的函数，以帮助我们精简代码。</p>
<p><code>both</code> 接受两个函数，返回一个新函数：当两个传入函数都返回 <code>truthy</code> 值时，新函数返回 <code>true</code>，否则返回 <code>false</code></p>
<p><code>either</code> 接受两个函数，返回一个新函数：当两个传入函数任意一个返回 <code>truthy</code> 值时，新函数返回 <code>true</code>，否则返回 <code>false</code></p>
<p>我们可以使用这两个函数来简化 <code>isCitizen</code> 和 <code>isEligibleToVote</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> isCitizen = either(wasBornInCountry, wasNaturalized)</span><br><span class="line"><span class="keyword">const</span> isEligibleToVote = both(isOver18, isCitizen)</span><br></pre></td></tr></table></figure>
<p>注意，<code>both</code> 以函数的方式实现了逻辑与（<code>&amp;&amp;</code>）的功能，<code>either</code> 实现了逻辑或（<code>||</code>）的功能。</p>
<p>Ramda 还提供了 <code>allPass</code> 和 <code>anyPass</code>，接受由任意多个函数组成的数组作为参数。如名称所示，<code>allPass</code> 类似于 <code>both</code>，而 <code>anyPass</code> 类似于 <code>either</code>。</p>
<h2 id="pipelines-guan-dao">Pipelines(管道)</h2>
<p>有时我们需要以 pipeline 的方式将多个函数依次作用于某些数据。例如，接受两个数字，将它们相乘，加 1 ，然后平方。我们可以这样写：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> multiply = <span class="function">(<span class="params">a, b</span>) =&gt;</span> a * b</span><br><span class="line"><span class="keyword">const</span> addOne = <span class="function"><span class="params">x</span> =&gt;</span> x + <span class="number">1</span></span><br><span class="line"><span class="keyword">const</span> square = <span class="function"><span class="params">x</span> =&gt;</span> x * x</span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> operate = <span class="function">(<span class="params">x, y</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> product = multiply(x, y)</span><br><span class="line">  <span class="keyword">const</span> incremented = addOne(product)</span><br><span class="line">  <span class="keyword">const</span> squared = square(incremented)</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">return</span> squared</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">operate(<span class="number">3</span>, <span class="number">4</span>) <span class="comment">// =&gt; ((3 * 4) + 1)^2 =&gt; (12 + 1)^2 =&gt; 13^2 =&gt; 169</span></span><br></pre></td></tr></table></figure>
<p>注意，每次操作是对上次操作的结果进行处理。</p>
<h2 id="pipe">pipe</h2>
<p>Ramda 提供了 <code>pipe</code> 函数：接受一系列函数，并返回一个新函数。</p>
<p>新函数的元数与第一个传入函数的元数相同（元数：接受参数的个数），然后顺次通过 “管道” 中的函数对输入参数进行处理。它将第一个函数作用于参数，返回结果作为下一个函数的入参，依次进行下去。“管道” 中最后一个函数的结果作为 <code>pipe</code> 调用的最终结果。</p>
<p>注意，除首个函数外，其余的函数都是一元函数。</p>
<p>了解这些后，我们可以使用 <code>pipe</code> 来简化我们的 <code>operate</code> 函数：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> operate = pipe(</span><br><span class="line">  multiply,</span><br><span class="line">  addOne,</span><br><span class="line">  square</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>当调用 <code>operate(3, 4)</code> 时，<code>pipe</code> 将 <code>3</code> 和 <code>4</code> 传给 <code>multiply</code> 函数，输出 <code>12</code>，然后将 <code>12</code> 传给 <code>addOne</code>，返回 <code>13</code>，然后将 <code>13</code> 传给 <code>square</code>，返回 <code>169</code>，并将 <code>169</code> 作为最终 <code>operate</code> 的最终结果返回。</p>
<h2 id="compose">compose</h2>
<p>另一种编写原始 <code>operate</code> 函数的方式是内联所有暂时变量：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> operate = <span class="function">(<span class="params">x, y</span>) =&gt;</span> square(addOne(multiply(x, y)))</span><br></pre></td></tr></table></figure>
<p>这样更紧凑，但也更不便于阅读。然而这种形式可以使用 Ramda 的 <code>compose</code> 函数进行重写。</p>
<p><code>compose</code> 的工作方式跟 <code>pipe</code> 基本相同，除了其调用函数的顺序是从右到左，而不是从左到右。下面使用 <code>compose</code> 来重写 <code>operate</code>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> operate = compose(</span><br><span class="line">  square,</span><br><span class="line">  addOne,</span><br><span class="line">  multiply</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>这与上面的 <code>pipe</code> 几乎一样，除了函数的顺序是相反的。实际上，Ramda 中的 <code>compose</code> 函数的内部是用 <code>pipe</code> 实现的。</p>
<p>我一直这样思考 <code>compose</code> 的工作方式：<code>compose(f, g)(value)</code> 等价于 <code>f(g(value))</code>。</p>
<p>注意，与 <code>pipe</code> 类似，<code>compose</code> 中的函数除最后一个外，其余都是一元函数。</p>
<h2 id="compose-huan-shi-pipe">compose 还是 pipe？</h2>
<p>具有命令式编程背景的人可能觉得 <code>pipe</code> 更容易理解，因为可以按照从左往右的顺序进行阅读。但 <code>compose</code> 更容易对如上所示的嵌套函数进行转换。</p>
<p>我也不太清楚什么时候该用 <code>compose</code>，什么时候该用 <code>pipe</code>。由于它们在 Ramda 中基本等价，所以选择用哪个可能并不重要。只要根据自己的情况选择合适的即可。</p>
<h2 id="jie-lun">结论</h2>
<p>通过特定的方式进行函数组合，我们已经可以开始编写更强的函数了。</p>
<h2 id="xia-yi-jie">下一节</h2>
<p>你可能已经注意到了，在进行函数组合时，我们多数情况下都可以省略函数参数。只有在最终调用组合好的函数时，才传入参数。</p>
<p>这在函数式编程中非常常见，我们将在下一节 <a href="https://adispring.coding.me/2017/06/11/Thinking-in-Ramda-Partial-Application/" target="_blank" rel="noopener"><code>Partial Application</code> (部分应用)</a>进行更多详细介绍。我们还会讨论如何组合多元（多参数）函数。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://adispring.github.io/2017/06/09/Thinking-in-Ramda-入门/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="wangzengdi">
      <meta itemprop="description" content="FE@Meituan.com">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="wangzengdi's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2017/06/09/Thinking-in-Ramda-入门/" class="post-title-link" itemprop="url">Thinking in Ramda: 入门</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2017-06-09 21:45:47" itemprop="dateCreated datePublished" datetime="2017-06-09T21:45:47+00:00">2017-06-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-11-18 08:07:49" itemprop="dateModified" datetime="2021-11-18T08:07:49+00:00">2021-11-18</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Thinking-in-Ramda/" itemprop="url" rel="index"><span itemprop="name">Thinking in Ramda</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>译者注：本文翻译自 Randy Coulman 的 《<a href="http://randycoulman.com/blog/2016/05/24/thinking-in-ramda-getting-started/" target="_blank" rel="noopener">Thinking in Ramda: Getting Started</a>》，转载请与<a href="https://github.com/randycoulman" target="_blank" rel="noopener">原作者</a>或<a href="https://github.com/adispring" target="_blank" rel="noopener">本人</a>联系。下面开始正文。</p>
<hr>
<p>本文是函数式编程系列文章：<a href="https://adispring.coding.me/categories/Thinking-in-Ramda/" target="_blank" rel="noopener">Thinking in Ramda</a> 的第一篇。</p>
<p>本系列文章使用 <a href="http://ramda.cn" target="_blank" rel="noopener">Ramda</a> JavaScript 库进行演示。许多理论、方法同样适用于其他函数式 JavaScript 库，如 <a href="http://underscorejs.org/" target="_blank" rel="noopener">Underscore</a> 和 <a href="https://lodash.com/" target="_blank" rel="noopener">Lodash</a>。</p>
<p>我将尽量用通俗、非学术性的语言演示函数式编程。一方面想让更多的人理解该系列文章；另一方面本人在函数式编程方面造诣尚浅。</p>
<h2 id="ramda">Ramda</h2>
<p>我已经在博客中多次提到过 <a href="http://ramda.cn" target="_blank" rel="noopener">Ramda</a> JavaScript 库：</p>
<ul>
<li>在 <a href="http://randycoulman.com/blog/2016/02/16/using-ramda-with-redux/" target="_blank" rel="noopener">Using Ramda With Redux</a> 中，展示了在编写 <a href="http://redux.js.org/" target="_blank" rel="noopener">Redux</a> 应用程序时如何运用 Ramda 的例子。</li>
<li>在 <a href="http://randycoulman.com/blog/2016/04/19/using-redux-api-middleware-with-rails/" target="_blank" rel="noopener">Using Redux-api-middleware With Rails</a> 中，我使用 Ramda 来转换请求和响应的数据。</li>
</ul>
<p>我发现 Ramda 是一个精心设计的库：包含许多 API ，来简洁、优雅进行 JavaScript 函数式编程。</p>
<p>如果你想在阅读本系列文章时进行 Ramda 实验，Ramda 网站有一个 <a href="http://ramda.cn/repl/" target="_blank" rel="noopener">repl 运行环境</a> 。</p>
<h2 id="han-shu">函数</h2>
<p>正如名字所示，函数式编程与函数有很大的关系。为了演示，我们定义一个函数为一段可重用的代码：接受 0 到多个参数，返回单个值。</p>
<p>下面是一个简单的 JavaScript 函数：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">double</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x * <span class="number">2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用 ES6 箭头函数，可以以更简洁的方式实现相同的函数。现在就提一下，是因为在接下来会大量用到箭头函数：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> double = <span class="function"><span class="params">x</span> =&gt;</span> x * <span class="number">2</span></span><br></pre></td></tr></table></figure>
<p>几乎每种语言都会支持函数调用。</p>
<p>有些语言更进一步，将函数视为一等公民：可以像使用普通类型的值的方式使用函数。例如：</p>
<ul>
<li>使用变量或常量引用函数</li>
<li>将函数作为参数传递给其他函数</li>
<li>将函数作为其他函数的返回值</li>
</ul>
<p>JavaScript 就是一种这样的语言，我们将利用它的这一优势进行编程。</p>
<h2 id="chun-han-shu">纯函数</h2>
<p>在进行函数式编程时，使用所谓的 “纯” 函数进行工作将变得非常重要。</p>
<p><a href="https://llh911001.gitbooks.io/mostly-adequate-guide-chinese/content/ch3.html" target="_blank" rel="noopener">纯函数</a>是没有副作用的函数。它不会给任何外部变量赋值，不会获取输入，不会产生 “输出”，不会对数据库进行读写，不会修改输入参数等。</p>
<p>纯函数的基本思想是：相同的输入，永远会得到相同的输出。</p>
<p>当然可以用非纯函数编程（而且这也是必须的，如果想让程序做任何有趣的事情），但在大多数情况下，需要保持大部分函数是纯函数。（译者注：并不是说，要禁止使用一切副作用，而是说，要让它们在可控的范围内发生）</p>
<h2 id="immutability">IMMUTABILITY</h2>
<p>函数式编程的另一个重要概念是 “Immutability”。什么意思呢？“Immutability” 是指 “数据不变性”。</p>
<p>当以 immutable 方式工作时，一旦定义了某个值或对象，以后就再也不会改变它了。这意味着不能更改已有数组中的元素或对象中的属性。</p>
<p>如果想改变数组或对象中的元素时，需要返回一份带有更改值的新拷贝。后面文章将会对此做详细介绍。</p>
<p>Immutability 和 纯函数息息相关。由于纯函数不允许有副作用，所以不允许更改函数体外部的数据结构。纯函数强制以 immutable 的方式处理数据。</p>
<h2 id="cong-na-li-kai-shi-ni">从哪里开始呢？</h2>
<p>开始以函数式思维思考最简单的方式是，使用集合迭代函数代替循环。</p>
<p>如果用过具备这些特性的其他语言（如 Ruby、Smalltalk），你可能已经熟悉了这些特性。</p>
<p>Martin Fowler 有几篇关于 “Collection PipeLines” 非常好的文章，展示了<a href="https://martinfowler.com/articles/collection-pipeline/" target="_blank" rel="noopener">如何使用这些函数</a> 以及<a href="https://martinfowler.com/articles/refactoring-pipelines.html" target="_blank" rel="noopener">如何将现有代码重构为 collection pipelines</a>。</p>
<p>注意，所有这些函数 <code>Array.prototype</code> 都有（除了 <code>reject</code>）。因此不需要 Ramda 也可以使用它们。但是，为了保持和本系列其他文章一致，本文将使用 Ramda 版本的函数。</p>
<h2 id="foreach">foreach</h2>
<p>不必写显式的循环，而是用 <code>forEach</code> 函数代替循环。示例如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Replace this:</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> value <span class="keyword">of</span> myArray) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(value)</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// with:</span></span><br><span class="line">forEach(<span class="function"><span class="params">value</span> =&gt;</span> <span class="built_in">console</span>.log(value), myArray)</span><br></pre></td></tr></table></figure>
<p><code>forEach</code> 接受一个函数和一个数组，然后将函数作用于数组的每个元素。</p>
<p>虽然 <code>forEach</code> 是这些函数中最简单的，但在函数式编程中它可能是最少用到的一个。<code>forEach</code> 没有返回值，所以只能用在有副作用的函数调用中。</p>
<h2 id="map">map</h2>
<p>下一个要学习的最重要的函数是 <code>map</code>。类似于 <code>forEach</code>，<code>map</code> 也是将函数作用于数组的每个元素。但与 <code>forEach</code> 不同的是，<code>map</code> 将函数的每个返回值组成一个新数组，并将其返回。示例如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">map(<span class="function"><span class="params">x</span> =&gt;</span> x * <span class="number">2</span>, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]) <span class="comment">//=&gt; [2, 4, 6]</span></span><br></pre></td></tr></table></figure>
<p>这里使用了匿名函数，但我们也可以在这里使用具名函数：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> double = <span class="function"><span class="params">x</span> =&gt;</span> x * <span class="number">2</span></span><br><span class="line">map(double, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br></pre></td></tr></table></figure>
<h2 id="filter-reject">filter/reject</h2>
<p>接下来，我们来看看 <code>filter</code> 和 <code>reject</code>。就像名字所示，<code>filter</code> 会根据断言函数的返回值从数组中选择元素，例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> isEven = <span class="function"><span class="params">x</span> =&gt;</span> x % <span class="number">2</span> === <span class="number">0</span></span><br><span class="line">filter(isEven, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]) <span class="comment">//=&gt; [2, 4]</span></span><br></pre></td></tr></table></figure>
<p><code>filter</code> 将断言函数（本例中为 <code>isEven</code>）作用于数组中的每个元素。每当断言函数返回 “真值” 时，相应的元素将包含到结果中；反之当断言函数返回为 “falsy” 值时，相应的元素将从结果数组中排除掉（过滤掉）。</p>
<p><code>reject</code> 是 <code>filter</code> 的补操作。它保留使断言函数返回 “falsy” 的元素，排除使断言函数返回 “truthy” 的元素。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reject(isEven, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]) <span class="comment">//=&gt; [1, 3]</span></span><br></pre></td></tr></table></figure>
<h2 id="find">find</h2>
<p><code>find</code> 将断言函数作用于数组中的每个元素，并返回第一个使断言函数返回真值的元素。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find(isEven, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]) <span class="comment">//=&gt; 2</span></span><br></pre></td></tr></table></figure>
<h2 id="reduce">reduce</h2>
<p><code>reduce</code> 比之前遇到的其他函数要复杂一些。了解它是值得的，但如果刚开始不太好理解，不要被它挡住。你可以在理解它之前继续学习其他知识。</p>
<p><code>reduce</code> 接受一个二元函数(<code>reducing function</code>)、一个初始值和待处理的数组。</p>
<p>归约函数的第一个参数称为 “accumulator” (累加值)，第二个参数取自数组中的元素；返回值为一个新的 “accumulator”。</p>
<p>先来看一个示例，然后看看会发生什么。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> add = <span class="function">(<span class="params">accum, value</span>) =&gt;</span> accum + value</span><br><span class="line"></span><br><span class="line">reduce(add, <span class="number">5</span>, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]) <span class="comment">//=&gt; 15</span></span><br></pre></td></tr></table></figure>
<ol>
<li><code>reduce</code> 首先将初始值 <code>5</code> 和 数组中的首个元素 <code>1</code> 传入归约函数 <code>add</code>，<code>add</code> 返回一个新的累加值：<code>5 + 1 = 6</code>。</li>
<li><code>reduce</code> 再次调用 <code>add</code>，这次使用新的累加值 <code>6</code> 和 数组中的下一个元素 <code>2</code> 作为参数，<code>add</code> 返回 <code>8</code>。</li>
<li><code>reduce</code> 再次使用 <code>8</code> 和 数组中的下个元素 <code>3</code> 来调用 <code>add</code>，输出 <code>11</code>。</li>
<li><code>reduce</code> 最后一次调用 <code>add</code>，使用 <code>11</code> 和 数组中的最后一个元素 <code>4</code> ，输出 <code>15</code>。</li>
<li><code>reduce</code> 将最终累加值 <code>15</code> 作为结果返回。</li>
</ol>
<h2 id="jie-lun">结论</h2>
<p>从这些集合迭代函数开始，需要逐渐习惯将函数传入其他函数的编程方式。你可能在其他语言中用过，但没有意识到正在做函数式编程。</p>
<h2 id="xia-yi-jie">下一节</h2>
<p>本系列的下一篇文章，<a href="https://adispring.coding.me/2017/06/10/Thinking-in-Ramda-Combining-Functions/" target="_blank" rel="noopener">函数组合</a> 将演示怎样以新的、有趣的方式对函数进行组合。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://adispring.github.io/2016/11/19/Functor-Applicative-Monoid-Monad/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="wangzengdi">
      <meta itemprop="description" content="FE@Meituan.com">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="wangzengdi's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2016/11/19/Functor-Applicative-Monoid-Monad/" class="post-title-link" itemprop="url">Functor/Applicative/Monoid/Monad</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2016-11-19 13:31:25" itemprop="dateCreated datePublished" datetime="2016-11-19T13:31:25+00:00">2016-11-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-11-18 08:07:49" itemprop="dateModified" datetime="2021-11-18T08:07:49+00:00">2021-11-18</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Haskell/" itemprop="url" rel="index"><span itemprop="name">Haskell</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="applicative-lei-de-ding-yi">Applicative类 的定义</h2>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> (<span class="type">Functor</span> <span class="title">f</span>) =&gt; <span class="type">Applicative</span> f <span class="keyword">where</span></span></span><br><span class="line">  pure :: a -&gt; f a</span><br><span class="line">  (&lt;*&gt;) :: f (a -&gt; b) -&gt; f a -&gt; f b</span><br></pre></td></tr></table></figure>
<p>Applicative 中定义了 <code>pure</code> 和 <code>&lt;*&gt;</code></p>
<h2 id="applicative-functor-de-ji-ge-shi-li">Applicative Functor 的几个实例</h2>
<h3 id="maybe">Maybe</h3>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Applicative</span> <span class="type">Maybe</span> <span class="keyword">where</span></span></span><br><span class="line">  pure = <span class="type">Just</span></span><br><span class="line">  <span class="type">Nothing</span> &lt;*&gt; _ = <span class="type">Nothing</span></span><br><span class="line">  (<span class="type">Just</span> f) &lt;*&gt; something = fmap f something</span><br></pre></td></tr></table></figure>
<h3 id="applicative-xiang-jiao-yu-functor-de-gai-jin-zhi-chu">Applicative 相较于 Functor 的改进之处：</h3>
<p>with the Applicative type class, we can chain the use of the &lt;*&gt; function, thus enabling us to seamlessly operate on several applicative values instead of just one. For instance, check this out:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">pure</span>(+) &lt;*&gt; <span class="type">Just</span> <span class="number">3</span> &lt;*&gt; <span class="type">Just</span> <span class="number">5</span> <span class="comment">-- Just 8</span></span><br></pre></td></tr></table></figure>
<p>lift 相当于 <code>pure</code></p>
<h3 id="applicative-zhong-huan-ding-yi-liao-code-lt-gt-code">Applicative 中还定义了 <code>&lt;$&gt;</code></h3>
<p>&lt;$&gt; 相当于中缀版的 fmap，但应用于 Applicative 的链式调用特别方便</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(&lt;$&gt;) :: (<span class="type">Functor</span> f) =&gt; (a -&gt; b) -&gt; f a -&gt; f b</span><br><span class="line"><span class="title">f</span> &lt;$&gt; x = fmap f x</span><br><span class="line"><span class="comment">-- pure f &lt;*&gt; x &lt;*&gt; y &lt;*&gt; ... === fmap f x &lt;*&gt; y... === f &lt;$&gt; x &lt;*&gt; y...</span></span><br></pre></td></tr></table></figure>
<h3 id="list-ye-shi-applicative-functor">List 也是 Applicative Functor</h3>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Applicative</span> [] <span class="keyword">where</span></span></span><br><span class="line">  pure x = [x]</span><br><span class="line">  fs &lt;*&gt; xs = [f x | f &lt;- fs, x &lt;- xs]</span><br></pre></td></tr></table></figure>
<p>理解了 haskell 中 List 的 <code>&lt;*&gt;</code> 也就理解了 Ramda 中的 <code>liftN</code><br>
将 fs 中的每个 f map 到 xs 中的每个 x。</p>
<p>例如</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">fs</span> = [f1, f2, f3]</span><br><span class="line"><span class="title">xs</span> = [x1, x2]</span><br><span class="line"><span class="title">fs</span> &lt;*&gt; xs === [f1 x1, f1 f2, f2 x1, f2 x2, f3 x1, f3 x2]</span><br></pre></td></tr></table></figure>
<h3 id="han-shu-code-gt-r-code-ye-shi-applicative-functor-hen-you-yi-si">函数 <code>(-&gt;) r</code> 也是 Applicative Functor 很有意思</h3>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Function</span> :: ((-&gt;) r)</span><br><span class="line"><span class="type">Function</span> a = ((-&gt;) r) a </span><br><span class="line">           = r -&gt; a</span><br></pre></td></tr></table></figure>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Applicative</span> ((-&gt;) r) <span class="keyword">where</span></span></span><br><span class="line">  pure x = (\_ -&gt; x)</span><br><span class="line">  f &lt;*&gt; g = \x -&gt; f x (g x)</span><br></pre></td></tr></table></figure>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(pure <span class="number">3</span>) <span class="string">"blah"</span> <span class="comment">-- 3</span></span><br><span class="line">(+) &lt;$&gt; (+<span class="number">3</span>) &lt;*&gt; (*<span class="number">100</span>) $ <span class="number">5</span> <span class="comment">-- 508</span></span><br></pre></td></tr></table></figure>
<p><code>&lt;$&gt;</code> + <code>&lt;*&gt;</code> 大致对标 Ramda 中的 converge</p>
<h2 id="laws">Laws</h2>
<h3 id="1-a-href-https-en-wikibooks-org-wiki-haskell-the-functor-class-functor-laws-a">1. <a href="https://en.wikibooks.org/wiki/Haskell/The_Functor_class" target="_blank" rel="noopener">Functor Laws</a></h3>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">fmap</span> id = id</span><br><span class="line"><span class="title">fmap</span> (g . f) = fmap g . fmap f</span><br></pre></td></tr></table></figure>
<h3 id="2-a-href-https-en-wikibooks-org-wiki-haskell-applicative-functors-applicative-functor-laws-a">2. <a href="https://en.wikibooks.org/wiki/Haskell/Applicative_functors" target="_blank" rel="noopener">Applicative Functor Laws</a></h3>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">pure</span> id &lt;*&gt; v = v                             <span class="comment">-- Identity</span></span><br><span class="line"><span class="title">pure</span> f &lt;*&gt; pure x = pure (f x)                <span class="comment">-- Homomorphism</span></span><br><span class="line"><span class="title">u</span> &lt;*&gt; pure y = pure ($ y) &lt;*&gt; u               <span class="comment">-- Interchange</span></span><br><span class="line"><span class="title">pure</span> (.) &lt;*&gt; u &lt;*&gt; v &lt;*&gt; w = u &lt;*&gt; (v &lt;*&gt; w)  <span class="comment">-- Composition</span></span><br></pre></td></tr></table></figure>
<p>a bonus law</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fmap f x = pure f &lt;*&gt; x</span><br></pre></td></tr></table></figure>
<h3 id="3-a-href-https-wiki-haskell-org-monad-laws-monad-laws-a">3. <a href="https://wiki.haskell.org/Monad_laws" target="_blank" rel="noopener">Monad Laws</a></h3>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">return</span> a &gt;&gt;= k  =  k a</span><br><span class="line"><span class="title">m</span> &gt;&gt;= return  =  m</span><br><span class="line"><span class="title">m</span> &gt;&gt;= (x -&gt; k x &gt;&gt;= h)  =  (m &gt;&gt;= k) &gt;&gt;= h</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://adispring.github.io/2016/11/01/Transducers-Explained-Pipelines/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="wangzengdi">
      <meta itemprop="description" content="FE@Meituan.com">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="wangzengdi's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2016/11/01/Transducers-Explained-Pipelines/" class="post-title-link" itemprop="url">Transducers Explained: Pipelines 中文</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2016-11-01 23:25:55" itemprop="dateCreated datePublished" datetime="2016-11-01T23:25:55+00:00">2016-11-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-11-18 08:07:49" itemprop="dateModified" datetime="2021-11-18T08:07:49+00:00">2021-11-18</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>本文是 Transducer Explained 教程的第二篇。在<a href="https://adispring.github.io/2016/10/24/Transducers-Explained-Part-1/">第一篇</a>中，从 <em>reducer</em> 开始讲起，到 <em>transformers</em>，再到在 <code>transduce</code> 中使用 <code>map</code> <em>transducers</em>。本文将介绍四个新的 <em>transducers</em>：<code>filter</code>、<code>remove</code>、<code>drop</code> 和 <code>take</code>。我们将展示如何将 <em>transducers</em> 组合成 流（<em>pipeline</em>s），并讨论转换的顺序。我们还将改变 <code>reduce</code> 的实现，使其能够借助 <code>reduced</code> 提前终止迭代操作。</p>
<p>那么，上次讲到哪了呢？</p>
<h2 id="transformer">Transformer</h2>
<p>在<a href="https://adispring.github.io/2016/10/24/Transducers-Explained-Part-1/">第一篇</a>文章中，通过定义 <em>transformer</em> 协议来规范了 <code>reduce</code> 的步骤。</p>
<p>所有 transformers 都包含3个方法：</p>
<ol>
<li>使用初始值初始化初始化转换，<code>init</code></li>
<li>使用 <em>reducer</em> 来组合每个元素，<code>step</code></li>
<li>将最后累积值转换为输出，<code>result</code></li>
</ol>
<p>在第一篇文章中，我们使用下面的 <em>reducer</em> 来转换输入源: <code>mult</code>、<code>add</code> 和 <code>append</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> append = <span class="function">(<span class="params">value, item</span>) =&gt;</span> &#123;</span><br><span class="line">  value.push(item);</span><br><span class="line">  <span class="keyword">return</span> value;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>本文只会用到 <code>append</code>，将元素拼接到数组的尾部。</p>
<h2 id="reduce">Reduce</h2>
<p>我们定义了自己的 <code>reduce</code> 实现，它接受以下参数：</p>
<ol>
<li>一个 transformer 或者将被封装成 transformer 的 <em>reducer</em></li>
<li>一个初始值（例如<code>[]</code>)。</li>
<li>一个输入源（例如一个将要被归并的数组）</li>
</ol>
<p>目前的实现使用 transformer 的 <code>step</code> 函数作为对原生数组进行归并的 <em>reducer</em>，我们稍后将修改这一实现。</p>
<p>在迭代过程中，<code>step</code> 函数接受两个参数：<code>result</code> 和 <code>item</code>。初始的 <code>result</code> 值 由调用者提供，后续的每个 <code>result</code> 使用当前 <code>step</code> 函数的返回值。</p>
<p><code>item</code> 由迭代过程内部提供。在第一篇文章中展示了两个过程：1. 归并数组的每个元素; 2. 手动调用 <code>step</code> 函数处理每个元素。（在后续文章中将看到更多例子）。</p>
<h2 id="transducer">Transducer</h2>
<p>我们创建了 mapping <em>transducer</em>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> map = <span class="function"><span class="params">f</span> =&gt;</span> <span class="function"><span class="params">xf</span> =&gt;</span> (&#123;</span><br><span class="line">  init: <span class="function"><span class="params">()</span> =&gt;</span> xf.init(),</span><br><span class="line">  step: <span class="function">(<span class="params">result, item</span>) =&gt;</span> xf.step(result, f(item)),</span><br><span class="line">  result: <span class="function"><span class="params">result</span> =&gt;</span> xf.result(result),</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p><code>map</code> transducer 接受一个映射函数：<code>f</code>，并返回一个真正的 transducer：</p>
<ol>
<li>接受一个已有 transformer</li>
<li>返回一个新的 transformer，用来通过 <code>f</code> 转换 <code>items</code></li>
<li>对封装的 transformer 进行代理，添加一些额外的处理过程（如添加映射操作）</li>
</ol>
<p>函数 <code>f</code>，可以是对数据进行映射（转换）的任意函数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> plus1 = <span class="function"><span class="params">input</span> =&gt;</span> input + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> plus2 = <span class="function"><span class="params">input</span> =&gt;</span> input + <span class="number">2</span>;</span><br></pre></td></tr></table></figure>
<p>在本文的例子中将继续使用这两个简单的映射函数。</p>
<h2 id="transduce">Transduce</h2>
<p>我们定义了一个新函数，<code>transduce</code>, 其接受：</p>
<ol>
<li>一个 transducer: 定义转换的过程</li>
<li>一个 stepper（reducer）函数，或 transformer (如 <code>append</code>)</li>
<li>一个 stepper 函数 的初始值 (如 <code>[]</code>)</li>
<li>输入源 (如一个待转换的数组)</li>
</ol>
<p>通过 transducer 和 <code>stepper</code>（reducer） 函数，可以创建一个 transformer, 然后将该 transformer、初始值和输入源一同传入 <code>reduce</code>。</p>
<p>我们已经展示过，同一 transducer 可以生成不同的结果，只要改变传入 <code>transduce</code> 的初始值和 <code>stepper</code> 函数。</p>
<h2 id="composition">Composition</h2>
<p>最后，我们展示了可以通过组合已有 transducers 来创建新的 transducers</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> compose2 = <span class="function">(<span class="params">fn1, fn2</span>) =&gt;</span> <span class="function"><span class="params">item</span> =&gt;</span> fn1(fn2(item));</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> transducer = compose2(</span><br><span class="line">      compose2(map(plus1), map(plus2)),</span><br><span class="line">      map(plus1));</span><br><span class="line"><span class="keyword">const</span> stepper = append;</span><br><span class="line"><span class="keyword">const</span> init = [];</span><br><span class="line"><span class="keyword">const</span> input = [<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>];</span><br><span class="line"><span class="keyword">const</span> output = transduce(transducer, stepper, init, input);</span><br><span class="line"><span class="comment">// [6,7,8]</span></span><br></pre></td></tr></table></figure>
<p>被组合的 transducer 从左向右对输入源进行转换。</p>
<p>本文从这里开始讲起。如果对上面这个例子不太熟悉，可以参考<a href="https://adispring.github.io/2016/10/24/Transducers-Explained-Part-1/">第一篇文章的讲解</a></p>
<h2 id="pipelines-liu-shui-xian">Pipelines (流水线)</h2>
<p>首先，定义一个新的函数，用它可以组合任意数量的函数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> compose = <span class="function">(<span class="params">...fns</span>) =&gt;</span> <span class="function"><span class="params">xf</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> i = fns.length - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span>(; i &gt;=<span class="number">0</span>; i--) &#123; xf = fns[i](xf); &#125;</span><br><span class="line">  <span class="keyword">return</span> xf;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>compose</code> 是对 <code>compose2</code> 的扩展。<code>compose</code> 从右向左进行函数组合：组合出来的函数调用时，右侧函数的返回值，作为左侧函数的输入，不断重复该过程，知道最后一个函数的输出，作为整个函数的结果输出。</p>
<p>可以通过组合 <code>plus1</code> 和 <code>plus2</code> 来创建 <code>plus4</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 手动调用 </span></span><br><span class="line"><span class="keyword">const</span> value = plus1(plus1(plus2(<span class="number">5</span>)));</span><br><span class="line"><span class="comment">// 9</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用组合函数 (允许函数复用)</span></span><br><span class="line"><span class="keyword">const</span> plus4 = compose(plus1, plus1, plus2);</span><br><span class="line"><span class="keyword">const</span> value = plus4(<span class="number">5</span>);</span><br><span class="line"><span class="comment">// 9</span></span><br></pre></td></tr></table></figure>
<p>我们来通过组合 <code>map</code> transducers 来创建一个 <code>plus5</code> transducer。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> transducer = compose(</span><br><span class="line">  map(plus1),  <span class="comment">// [3,4,5]</span></span><br><span class="line">  map(plus2),  <span class="comment">// [5,6,7]</span></span><br><span class="line">  map(plus1),  <span class="comment">// [6,7,8]</span></span><br><span class="line">  map(plus1)); <span class="comment">// [7,8,9]</span></span><br><span class="line"><span class="keyword">const</span> stepper = append;</span><br><span class="line"><span class="keyword">const</span> init = [];</span><br><span class="line"><span class="keyword">const</span> input = [<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>];</span><br><span class="line"><span class="keyword">const</span> output = transduce(transducer, stepper, init, input);</span><br><span class="line"><span class="comment">// [7,8,9]</span></span><br></pre></td></tr></table></figure>
<p>每个 transducer 旁边的注释将每个转换通过数组展示出来，这样每次可以完整的查看整个转换。</p>
<p>然而，需要注意的是，在整个转换过程中，transducers 每次只顺序转换一个 item，并且不会产生中间结果。注释仅仅表示 pipeline 的每步的转换结果。我们将在下面继续讨论这个问题。</p>
<p>实际上，虽然组合是从右向左，转换的顺序实际上是从左向右的（在示例中是从上向下）。（需要将 transducers 的组合顺序 和 组合后 transducers 对输入源的转换顺序区分开)。在本例中顺序并不重要，但下一个例子中，便需要考虑调用顺序了。</p>
<h2 id="filter">Filter</h2>
<p>我们来定义 <code>filter</code> transducer</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> filter = <span class="function"><span class="params">predicate</span> =&gt;</span> <span class="function"><span class="params">xf</span> =&gt;</span> (&#123;</span><br><span class="line">  init: <span class="function"><span class="params">()</span> =&gt;</span> xf.init(),</span><br><span class="line">  step: <span class="function">(<span class="params">value, item</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> allow = predicate(item);</span><br><span class="line">    <span class="keyword">if</span>(allow)&#123;</span><br><span class="line">      value = xf.step(value, item);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">  &#125;,</span><br><span class="line">  result: <span class="function">(<span class="params">value</span>) =&gt;</span> xf.result(value),</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>注意，通过 <code>filter</code> 创建的 transformer，只有在判断函数 <code>predicate</code> 返回 真值 时，才会调用给下一个 transformer。当 <code>predicate</code> 返回 false 时，当前元素会被忽略，并返回上次的迭代结果。</p>
<p>我们创建一个 transducer ，来过滤出所有奇数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> isOdd = <span class="function"><span class="params">num</span> =&gt;</span> num % <span class="number">2</span> === <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> transducer = filter(isOdd);</span><br><span class="line"><span class="keyword">const</span> stepper = append;</span><br><span class="line"><span class="keyword">const</span> init = [];</span><br><span class="line"><span class="keyword">const</span> input = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line"><span class="keyword">const</span> output = transduce(transducer, stepper, init, input);</span><br><span class="line"><span class="comment">// [1,3,5]</span></span><br></pre></td></tr></table></figure>
<p>我们使用 <code>isOdd</code> 的判断函数，来创建一个过滤元素的 transducer。然后使用 <code>transduce</code> 将其作用于一个整数数组，输出数组中只包含奇数。</p>
<p>我们再创建一个函数，该函数调用后，返回一个检查当前输入值是否等于之前输入值的判断函数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// another predicate </span></span><br><span class="line"><span class="keyword">const</span> isEqual = <span class="function"><span class="params">y</span> =&gt;</span> <span class="function"><span class="params">x</span> =&gt;</span> x === y;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> transducer = filter(isEqual(<span class="number">2</span>));</span><br><span class="line"><span class="keyword">const</span> stepper = append;</span><br><span class="line"><span class="keyword">const</span> init = [];</span><br><span class="line"><span class="keyword">const</span> input = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line"><span class="keyword">const</span> output = transduce(transducer, stepper, init, input);</span><br><span class="line"><span class="comment">// [2]</span></span><br></pre></td></tr></table></figure>
<p>可以看到，创建出来的判断函数 <code>isEqual(2)</code> 只允许输出数组中包含数字 2。</p>
<p>再来一个辅助函数，其接受一个判断函数，对其结果取反。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> not = <span class="function"><span class="params">predicate</span> =&gt;</span> <span class="function"><span class="params">x</span> =&gt;</span> !predicate(x);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> transducer = filter(not(isEqual(<span class="number">2</span>)));</span><br><span class="line"><span class="keyword">const</span> stepper = append;</span><br><span class="line"><span class="keyword">const</span> init = [];</span><br><span class="line"><span class="keyword">const</span> input = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line"><span class="keyword">const</span> output = transduce(transducer, stepper, init, input);</span><br><span class="line"><span class="comment">// [1,3,4,5]</span></span><br></pre></td></tr></table></figure>
<p>我们修改了前面的例子：对判断函数 <code>isEqual(2)</code> 取反，由此创建了一个移除输入源中所有数字 2 的 transducer。</p>
<p>现在在我们的 pipeline 库中添加了另一件武器（<code>filter</code>），一起来玩一下吧。</p>
<h2 id="pipeline-shun-xu">Pipeline 顺序</h2>
<p>我们来对每个元素加 1，然后过滤出奇数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> transducer = compose(</span><br><span class="line">  map(plus1),         <span class="comment">// [2,3,4,5,6]</span></span><br><span class="line">  filter(isOdd));     <span class="comment">// [3,5]</span></span><br><span class="line"><span class="keyword">const</span> stepper = append;</span><br><span class="line"><span class="keyword">const</span> init = [];</span><br><span class="line"><span class="keyword">const</span> input = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line"><span class="keyword">const</span> output = transduce(transducer, stepper, init, input);</span><br><span class="line"><span class="comment">// [3,5]</span></span><br></pre></td></tr></table></figure>
<p>首先调用 <code>map(plus1)</code> transducer 对每个元素加 1，然后调用下一步转换：过滤出所有奇数。</p>
<p>我们改变一下 transducers 的顺序，看看会发生什么。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> transducer = compose(</span><br><span class="line">      filter(isOdd),      <span class="comment">// [1,3,5]</span></span><br><span class="line">      map(plus1));        <span class="comment">// [2,4,6]</span></span><br><span class="line"><span class="keyword">const</span> stepper = append;</span><br><span class="line"><span class="keyword">const</span> init = [];</span><br><span class="line"><span class="keyword">const</span> input = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line"><span class="keyword">const</span> output = transduce(transducer, stepper, init, input);</span><br><span class="line"><span class="comment">// [2,4,6]</span></span><br></pre></td></tr></table></figure>
<p>我们首先过滤出所有奇数。<code>filter(isOdd)</code> transformer 只将奇数传给下一个 transformer。所有传到下一步的元素(奇数)会使用 <code>plus1</code> 进行映射。</p>
<p>这展示了 <em>组合 transducers</em> 的两个重要性质：</p>
<ol>
<li>虽然 transducers组合 是从右向左，但数据转换是从左向右。</li>
<li>越早使用 transducers 减少 pipeline 中元素的数量，效率可能会越高。</li>
</ol>
<p>注意到，在最后一个例子中，<code>map(plus1)</code> 仅仅使用所有元素的子集调用。同样的，并未创建中间数组，仅仅作为注释便于理解而已。</p>
<h2 id="remove">Remove</h2>
<p>准备好了吗？现在开始讲另一个 transducer。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> remove = <span class="function"><span class="params">predicate</span> =&gt;</span> filter(not(predicate));</span><br></pre></td></tr></table></figure>
<p>很简单吧。实际上，我们可以通过对 predicate 取反 和 复用 <code>filter</code> 来创建 <code>remove</code> transducer。</p>
<p>现在来实践一下。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> transducer = compose(</span><br><span class="line">  filter(isOdd),        <span class="comment">// [1,3,5]</span></span><br><span class="line">  map(plus1),           <span class="comment">// [2,4,6] </span></span><br><span class="line">  remove(isEqual(<span class="number">4</span>)));  <span class="comment">// [2,6]</span></span><br><span class="line"><span class="keyword">const</span> stepper = append;</span><br><span class="line"><span class="keyword">const</span> init = [];</span><br><span class="line"><span class="keyword">const</span> input = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line"><span class="keyword">const</span> output = transduce(transducer, stepper, init, input);</span><br><span class="line"><span class="comment">// [2,6]</span></span><br></pre></td></tr></table></figure>
<p>首先过滤出奇数，然后对每项加1，然后删除 <code>4</code>。</p>
<h2 id="drop">Drop</h2>
<p>如果想在迭代开始时跳过前 <code>n</code> 个元素，该做么做呢？这正是 <code>drop</code> transducer 的作用。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> drop = <span class="function"><span class="params">n</span> =&gt;</span> <span class="function"><span class="params">xf</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">var</span> left = n;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    init: <span class="function"><span class="params">()</span> =&gt;</span> xf.init(),</span><br><span class="line">    step: <span class="function"><span class="keyword">function</span>(<span class="params">value, item</span>)</span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(left &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        left--;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        value = xf.step(value, item);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> value;</span><br><span class="line">    &#125;,</span><br><span class="line">    result: <span class="function"><span class="params">result</span> =&gt;</span> xf.result(result),</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以这样使用 <code>drop</code>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> transducer = drop(<span class="number">2</span>);</span><br><span class="line"><span class="keyword">var</span> stepper = append;</span><br><span class="line"><span class="keyword">var</span> init = [];</span><br><span class="line"><span class="keyword">var</span> input = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line"><span class="keyword">var</span> output = transduce(transducer, stepper, init, input);</span><br><span class="line"><span class="comment">// [3,4,5]</span></span><br></pre></td></tr></table></figure>
<p><code>drop</code> 接受丢弃元素的个数。这是第一个创建有状态变换的 transducer 的示例。每次调用 <code>drop</code> transducer 创建一个转换时，便会创建一个变量 <code>left</code>，用来指示当前还剩多少个元素需要被丢弃。<code>left</code> 被初始化为 <code>n</code>。</p>
<p>注意，我们使用一个无状态的 transducer 创建了一个有状态的 transformer。这是一个重要的区别。这意味着我们可以重用 <code>drop(2)</code> transducer 任意多次，而不必担心任何状态。状态是在 transformer 中创建的，而不是 transducer 中。</p>
<p>假如我们不想丢弃，而是获取前 <code>n</code> 个元素并丢弃剩余元素，该怎么办呢？为方便实现，假设 <code>n &gt; 0</code>。</p>
<p>我们来尝试一下。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> take = <span class="function"><span class="params">n</span> =&gt;</span> <span class="function"><span class="params">xf</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">var</span> left = n;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    init: <span class="function"><span class="params">()</span> =&gt;</span> xf.init(),</span><br><span class="line">    step: <span class="function"><span class="keyword">function</span>(<span class="params">value, item</span>)</span>&#123;</span><br><span class="line">      value = xf.step(value, item);</span><br><span class="line">      <span class="keyword">if</span>(--left &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">// 如何停止???</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> value;</span><br><span class="line">    &#125;,</span><br><span class="line">    result: <span class="function"><span class="params">result</span> =&gt;</span> xf.result(result),</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>哦噢，麻烦来了。我们知道如何逐步处理每个元素，并且通过 transformer 的状态来保持剩余元素的计数。但是，如何停止对剩余元素的迭代呢？</p>
<p>为什么需要表明转换已经完成，不再接受任何额外元素呢？不仅因为继续接受元素是一种浪费，还因为无法保证迭代能够完成。有可能迭代是无限的。如果可以，我们当然想终止无限迭代。</p>
<p>那么如何表示提前终止呢？我们需要在看一下迭代的源代码：<code>transduce</code>。</p>
<h2 id="reduce-redux-zhong-ji-reduce">Reduce redux (终极 Reduce)</h2>
<p>下面是来自<a href="https://adispring.github.io/2016/10/24/Transducers-Explained-Part-1/">第一篇文章</a>中 <code>transduce</code> 和 <code>reduce</code> 的定义，：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> transduce = <span class="function">(<span class="params">transducer, stepper, init, input</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span>(<span class="keyword">typeof</span> stepper === <span class="string">'function'</span>)&#123;</span><br><span class="line">    stepper = wrap(stepper);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> xf = transducer(stepper);</span><br><span class="line">  <span class="keyword">return</span> reduce(xf, init, input);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> reduce(xf, init, input) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span>(<span class="keyword">typeof</span> xf === <span class="string">'function'</span>)&#123;</span><br><span class="line">    xf = wrap(xf);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 怎样才能结束呢?? </span></span><br><span class="line">  <span class="keyword">var</span> value = input.reduce(xf.step, init); </span><br><span class="line">  <span class="keyword">return</span> xf.result(value);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> wrap = <span class="function"><span class="params">stepper</span> =&gt;</span> (&#123;</span><br><span class="line">  init: <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'init not supported'</span>),</span><br><span class="line">  step: stepper,</span><br><span class="line">  result: <span class="function"><span class="params">value</span> =&gt;</span> value,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>从上面的实现可知，我们正在使用原生数组 <code>reduce</code> 方法进行迭代，<code>reduce</code> 的 <code>reducer</code> 来自 transformer。后续文章中，我们将删除输入源是数组的假设，但现在还需继续使用该假设。我们来定义自己的 <code>arrayReduce</code> 实现。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> reduce = <span class="function">(<span class="params">xf, init, input</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span>(<span class="keyword">typeof</span> xf === <span class="string">'function'</span>)&#123;</span><br><span class="line">    xf = wrap(xf);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> arrayReduce(xf, init, input);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> arrayReduce(xf, init, array) =&gt; &#123;</span><br><span class="line">  <span class="keyword">var</span> value = init;</span><br><span class="line">  <span class="keyword">var</span> idx = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">var</span> length = array.length;</span><br><span class="line">  <span class="keyword">for</span>(; idx &lt; length; idx++)&#123;</span><br><span class="line">    value = xf.step(value, array[idx]);</span><br><span class="line">    <span class="comment">// We need to break here, but how do we know?</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> xf.result(value);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>arrayReduce</code> 的实现接受一个 transformer 、一个初始值和输入数组。然后使用 <code>for</code> 循环遍历每个元素，并使用累加值 value 和数组元素来调用 transformer 的 <code>step</code> 函数。</p>
<p>我们需要一个方法来打破这个循环，打破循环需要依赖某些标记值。幸运的是，我们可以采用已有的 <a href="https://github.com/cognitect-labs/transducers-js#reduced" target="_blank" rel="noopener">transducer 协议</a>。</p>
<p>为了在调用 transformer 中的 <code>step</code> 之后发出提前终止信号，我们可以将 <em>reduced</em> 值封装在包含两个属性的对象中：</p>
<ol>
<li><code>value</code>: 存储实际要封装的值。</li>
<li><code>__transducers_reduced__</code>: bool 类型值，为<code>true</code>时，表示该对象已经 reduced （归并过）了，迭代需要被终止。</li>
</ol>
<p>实现如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> reduced = <span class="function"><span class="params">value</span> =&gt;</span> (&#123;</span><br><span class="line">  value: value,</span><br><span class="line">  __transducers_reduced__: <span class="literal">true</span>,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>我们还将添加一个 predicate 判断函数来确定值是否是 reduced 。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> iReduced = <span class="function"><span class="params">value</span> =&gt;</span> value &amp;&amp; value.__transducers_reduced__;</span><br></pre></td></tr></table></figure>
<p>此外，我还需要一个方法来提取，或 <code>deref</code>(解引用) reduced 的值。</p>
<p>现在我们可以调整一下 <code>arrayReduce</code> 的实现，来来处理提前终止的 reduced 的值。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arrayReduce =&gt; <span class="function">(<span class="params">xf, init, array</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">var</span> value = init;</span><br><span class="line">  <span class="keyword">var</span> idx = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">var</span> length = array.length;</span><br><span class="line">  <span class="keyword">for</span>(; idx &lt; length; idx++)&#123;</span><br><span class="line">    value = xf.step(value, array[idx]);</span><br><span class="line">    <span class="keyword">if</span>(isReduced(value))&#123;</span><br><span class="line">      value = deref(value);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> xf.result(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在可以像以前一样对每个元素进行迭代，但每次调用 <code>step</code> 之后，会先检查是否当前值是否 reduced。如果是，则提取当前值并终止迭代。我们仍然对最终值调用 <code>result</code> 方法，不管它来自 reduced value 还是完整的迭代。</p>
<h2 id="take-2">Take 2</h2>
<p>现在可以完成 <code>take</code> 的实现了：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> take = <span class="function"><span class="params">n</span> =&gt;</span> <span class="function"><span class="params">xf</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">var</span> left = n;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    init: <span class="function"><span class="params">()</span> =&gt;</span> xf.init(),</span><br><span class="line">    step: <span class="function"><span class="keyword">function</span>(<span class="params">value, item</span>)</span>&#123;</span><br><span class="line">      value = xf.step(value, item);</span><br><span class="line">      <span class="keyword">if</span>(--left &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">// 任务完成，发出 reduced 信号</span></span><br><span class="line">        value = reduced(value);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> value;</span><br><span class="line">    &#125;,</span><br><span class="line">    result: <span class="function"><span class="params">value</span> =&gt;</span> xf.result(value),</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>我们之前唯一缺失的是：当检测到转换完成后使用 <code>reduced</code> 对值进行封装。(现在已经补上了)</p>
<p>让我们看看它是否能工作：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> transducer = take(<span class="number">3</span>);</span><br><span class="line"><span class="keyword">const</span> stepper = append;</span><br><span class="line"><span class="keyword">const</span> init = [];</span><br><span class="line"><span class="keyword">const</span> input = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line"><span class="keyword">const</span> output = transduce(transducer, stepper, init, input);</span><br><span class="line"><span class="comment">// [1,2,3]</span></span><br></pre></td></tr></table></figure>
<p>工作正常！</p>
<p>就像任何其他的 transducer，你可以将 <code>drop</code> 和 <code>take</code> 组合成一个 pipeline</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> transducer = compose(</span><br><span class="line">  drop(<span class="number">1</span>),    <span class="comment">// [2,3,4,5]</span></span><br><span class="line">  take(<span class="number">3</span>),    <span class="comment">// [2,3,4]</span></span><br><span class="line">  drop(<span class="number">1</span>));   <span class="comment">// [3,4]</span></span><br><span class="line"><span class="keyword">const</span> stepper = append;</span><br><span class="line"><span class="keyword">const</span> init = [];</span><br><span class="line"><span class="keyword">const</span> input = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line"><span class="keyword">const</span> output = transduce(transducer, stepper, init, input);</span><br><span class="line"><span class="comment">// [3,4]</span></span><br></pre></td></tr></table></figure>
<p>第一个 <code>drop</code> 跳过第一个元素，然后将剩余元素传给下一个 transformer。<code>take</code>  transformer 获取从第一个 <code>drop</code> 传过来的数组中的前三个元素，然后停止迭代。最后一个 <code>drop</code> 删除从 <code>take</code> 传过来的数组中的首个元素，并且在终止之前逐一发送剩余的两个元素。</p>
<h2 id="di-er-bu-fen-zong-jie">第二部分总结</h2>
<p>我们首先总结了在第一篇文章中学到的内容，然后添加了 4 个新的 transducers：<code>filter</code>、<code>remove</code>、<code>take</code>、<code>drop</code>。我们通过组合 transducers 来创建 transformer pipelines，并看到数据变换的顺序是从左到右。</p>
<p>我们看到，除了在转换期间改变元素，transformer 还可以决定跳过任意元素，通过不调用下一个 transformer 的 <code>step</code> 来实现。每一个 transformer 的实现决定了什么会传递到下个 transformer。有些情况下， transformer 可能会发送多个值，例如 <code>cat</code> 或 <a href="https://github.com/transduce/transduce-string" target="_blank" rel="noopener"><code>transduce-string</code></a>。</p>
<p>我们还看到了可以创建有状态变换的 transducer 的一些例子。状态由 transformer 管理，而不是 transducer。这允许无状态 transducer 的重用，即时它们创建的 transformers 管理状态。</p>
<p>当实现 <code>take</code> 时，我们意识到需要添加一个用于提前终止迭代的方法。我们改变了 <code>reduce</code> 的实现来处理和解包 reduced 的值，并且实现 <code>take</code> 用于在取完数据时，终止迭代。</p>
<h2 id="huan-you-bie-de-ma">还有别的吗？</h2>
<p>在入门教程的最后一篇文章中还有一些需要解释的相关问题。我们仍未解释 transformer 的 <code>init</code> 和 <code>reduce</code> 的作用。我们将添加 <code>into</code> 并一般化 <code>reduce</code> 的实现来支持迭代器。</p>
<p>我们还看到输入元素可以是产生 sequence 值的任意东西：惰性列表、无限序列生成器、<a href="http://phuu.net/2014/08/31/csp-and-transducers.html" target="_blank" rel="noopener">CSP</a>、<a href="https://github.com/transduce/transduce-stream" target="_blank" rel="noopener">Node.js streams</a>、迭代器、生成器、immutable-js 数据结构等。</p>
<p>想要获取新文章的通知吗？可以关注 获取 <a href="https://twitter.com/simplectic" target="_blank" rel="noopener">simplectic</a> 的 Twitter。</p>
<h2 id="wo-xian-zai-yi-jing-zhun-bei-hao-liao">我现在已经准备好了！</h2>
<p>已经准备使用 transducers 了吗？如果通读了这篇文章，你应该已经具备良好的知识体系： <a href="https://github.com/cognitect-labs/transducers-js" target="_blank" rel="noopener">transducers-js</a> 和 <a href="https://github.com/jlongster/transducers.js" target="_blank" rel="noopener">transducers.js</a>。我们主要参考 transducers-js 的实现，但这些概念同样适用于 transducers.js。</p>
<p>如果你喜欢 <a href="http://underscorejs.org/" target="_blank" rel="noopener">Underscore.js</a>，可以查看 <a href="http://simplectic.com/projects/underarm" target="_blank" rel="noopener">underarm</a>。它是基于 <a href="https://github.com/transduce/transduce" target="_blank" rel="noopener">transduce</a> 的库，允许针对 transducers.js 和 transducer-js 支持的公共协议定义 API。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/2/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/4/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">wangzengdi</p>
  <div class="site-description" itemprop="description">FE@Meituan.com</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">33</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">1</span>
        <span class="site-state-item-name">tags</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">wangzengdi</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script>
<script src="/js/schemes/muse.js"></script>
<script src="/js/next-boot.js"></script>



  















  

  

</body>
</html>
